### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Egyes feladatok végrehajtása, munkaelemek, feldolgozása aszinkron i/o, várjon, amíg más szálak nevében, és időzítőket feldolgozásához használható szálak biztosít."
  remarks: "Számos alkalmazás létrehozása, amely nagy mennyiségű idő az alvó állapotban várakozik egy adott esemény bekövetkezzen töltött szálak. Más szálak alvó állapotba előfordulhat, hogy csak a kérdezze le az olyan módosítás vagy állapotinformációk frissítése rendszeresen aktiválva. A szálkészlet lehetővé teszi a szálak hatékonyabban használja azáltal, hogy az alkalmazás munkavégző szál, a rendszer által felügyelt készletét. Szál készlet szálak használó műveletek közé tartoznak a következők: - létrehozásakor egy <xref:System.Threading.Tasks.Task>vagy <xref:System.Threading.Tasks.Task%601>objektum néhány feladat végrehajtásához aszinkron módon történik, a feladat van ütemezve egy szál készlet szálon alapértelmezés szerint.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Aszinkron időzítők használja a szálkészlethez. Szál készlet szálak visszahívások végre az <xref:System.Threading.Timer?displayProperty=fullName>osztály és rhető események a az <xref:System.Timers.Timer?displayProperty=fullName>osztályhoz.</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      -Ha regisztrált várakozási kezeli, a rendszer szál várakozási használt leírók számának állapotát figyeli. Egy Várjon, amíg a művelet befejezése után a szál készlet egy munkavégző szál végrehajtja a megfelelő visszahívási függvény.      -Hívás esetén a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>módszer várólistába módszert a végrehajtási szál készlet szálban.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> A metódus átadásával ehhez a <xref:System.Threading.WaitCallback>delegálása.</xref:System.Threading.WaitCallback>   A delegált aláírása <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> ahol `state` olyan objektum, amely tartalmazza a delegált által használt adatok.    A tényleges adatok átadhatók a delegált meghívásával a <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>metódus.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > A felügyelt szálkészlet szála háttérszál. Ez azt jelenti, hogy azok <xref:System.Threading.Thread.IsBackground%2A>tulajdonság `true`.</xref:System.Threading.Thread.IsBackground%2A> Ez azt jelenti, hogy a szálkészlet szál nem közli a után az összes előtérbeli szálak kiléptek futó alkalmazáshoz.      > [!IMPORTANT] > A szálkészlet a rendszer újból felhasználja a szál, amikor az adatok szál helyi tárolóhoz vagy a megjelölt mezők nem törli a <xref:System.ThreadStaticAttribute>attribútum.</xref:System.ThreadStaticAttribute> Ezért, ha metódus megvizsgálja a szál helyi tárolóhoz vagy a mezők, amely lesznek megjelölve a <xref:System.ThreadStaticAttribute>attribútum, az értékeket megtalálja maradhat egy korábbi használatát, a szál készlet szál.</xref:System.ThreadStaticAttribute>       Várjon, amíg a szálkészlethez művelethez nem kapcsolódó munkaelemek várólistán tárolható. Kérte, hogy egy munkaelem egy szál a szálkészlet kell kezelnie, hívja meg a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metódus.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Ez a módszer paraméterként egy hivatkozást a metódus vagy delegált esetén, amely a szálkészlet kiválasztott szál fogja meghívni. Nincs mód munkaelem megszakítja, miután várólistára került.       Időzítő-várólista időzítői és a regisztrált várakozási műveletek is használják a szálkészlethez. A visszahívások várólistára kerülnek a szálkészlethez.       Nincs több szálkészlet folyamatonként. Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a szálkészlet-folyamat az alapértelmezett méret számos tényezőtől függ, például a virtuális címtartomány mérete. A folyamat meghívhatja a <xref:System.Threading.ThreadPool.GetMaxThreads%2A>módszert szálak számának meghatározásához.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> A szálkészlet szálak számát használatával módosítható a <xref:System.Threading.ThreadPool.SetMaxThreads%2A>metódus.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Minden egyes szál használja az alapértelmezett hívásverem mérete, és az alapértelmezett prioritással futtatja.      > [!NOTE] >, Amelyen a .NET-keretrendszer nem felügyelt kód használatával módosíthatja a szálkészlet méretét a `CorSetMaxThreads` függvényt, a mscoree.h fájlban.       A szálkészlet nyújt új munkaszálat vagy i/o-végrehajtási szálak az igény szerinti kategóriákhoz tartozó minimális eléréséig. Legalább elérésekor, a szálkészlet kategória további szálat létrehozni, vagy várjon, amíg befejeződik néhány feladatot. Verziótól kezdve a [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], a szálkészlet hoz létre, és munkaszál megsemmisít átviteli sebességben, ami van definiálva, feladatok, amelyek befejezik időegység alatt optimalizálása érdekében. Túl kevés szálak nem tehetik a rendelkezésre álló erőforrások optimális használatát, mivel túl sok szál Erőforrásverseny nő.      > [!NOTE] > Alacsony igény esetén a minimális értékek csökkenhet is a szál készlet szálak aktuális száma.       Használhatja a <xref:System.Threading.ThreadPool.GetMinThreads%2A>beszerzéséhez minimális értékeiről.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > Használhatja a <xref:System.Threading.ThreadPool.SetMinThreads%2A>metódus szálak minimális számának növeléséhez.</xref:System.Threading.ThreadPool.SetMinThreads%2A> Azonban ezeket az értékeket feleslegesen növelése teljesítményproblémákat okozhat. Ha túl sok feladatok egyszerre indul el, az összes úgy tűnhet, hogy lassú lehet. A legtöbb esetben a szálkészlet javítja a teljesítményt a saját algoritmussal szálak felosztásához."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az operációs rendszer leírójának köti a <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "Egy <xref:System.IntPtr>, amely tartalmazza a leíró.</xref:System.IntPtr> A leíró kell lett megnyitva a nem felügyelt oldalon átlapolt i/o műveletekhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a leíró kötött; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az operációs rendszer leírójának köti a <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "A `osHandle` paraméter kell <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, amelyek az absztrakt <xref:System.Runtime.InteropServices.SafeHandle>osztályból</xref:System.Runtime.InteropServices.SafeHandle> származik</xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "A <xref:System.Runtime.InteropServices.SafeHandle>, amely tartalmazza az operációs rendszer leírójának.</xref:System.Runtime.InteropServices.SafeHandle> A leíró kell lett megnyitva a nem felügyelt oldalon átlapolt i/o műveletekhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a leíró kötött; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekéri a a szálak maximális számát szál készlet által visszaadott közötti különbség a <xref:System.Threading.ThreadPool.GetMaxThreads*>metódust, és a jelenleg aktív számát.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "Ha GetAvailableThreads adja vissza, a változó által megadott `workerThreads` további munkaszál elindítható, és a változó által megadott számú tartalmaz `completionPortThreads` indíthatók el, további aszinkron i/o szálak számát tartalmazza.       Ha nincs elérhető szálak, további szál kérelem marad várakozó szál készlet szálak elérhetővé válnak."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "A rendelkezésre álló munkavégző szál száma."
    - id: completionPortThreads
      type: System.Int32
      description: "A rendelkezésre álló aszinkron i/o-szálak száma."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekéri a szálkészlethez aktív lehet egyidejű kérelmek számát jelenti. Felett, hogy a kívánt összes kérelem maradnak amíg szál készlet szálak elérhetővé válnak."
  remarks: "Ha GetMaxThreads adja vissza, a változó által megadott `workerThreads` tartalmazza a szálkészlet engedélyezett munkaszál, és a változó által meghatározott maximális számának `completionPortThreads` a szálkészlet engedélyezett aszinkron i/o-szálak maximális számát tartalmazza.       Használhatja a <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>módszerrel határozható meg a szálkészlet szálak aktuális száma az adott időpontban.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Használhatja a <xref:System.Threading.ThreadPool.SetMaxThreads%2A>beállítani a munkaszálak és aszinkron i/o-szálak maximális száma a szálkészlethez.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       Mivel sok szál kérelem rendszermemória lehetővé teszi várólistán tárolható. Ha nincs több mint szál készlet szálak, a további kérelmeket marad aszinkron szál készlet szálak elérhetővé válnak."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "A szálkészlet a munkaszálak maximális száma."
    - id: completionPortThreads
      type: System.Int32
      description: "A szálkészlet aszinkron i/o szálak maximális száma."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekéri a szálkészlet hoz létre az igény szerinti szálak minimális száma, új kérések, szál létrehozása és megsemmisítése kezelésére szolgáló algoritmus átváltás előtt."
  remarks: "A szálkészlet nyújt új munkaszálat vagy i/o-végrehajtási szálak az igény szerinti kategóriákhoz tartozó minimális eléréséig. Alapértelmezés szerint a minimális szálak értékre van állítva a rendszer processzorainak számát. A minimális elérésekor, a szálkészlet kategória további szálat létrehozni, vagy várjon, amíg befejeződik néhány feladatot. Verziótól kezdve a [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], a szálkészlet hoz létre, és szálak megsemmisít átviteli sebességben, ami van definiálva, feladatok, amelyek befejezik időegység alatt optimalizálása érdekében. Túl kevés szálak nem tehetik a rendelkezésre álló erőforrások optimális használatát, mivel túl sok szál Erőforrásverseny nő.      > [!NOTE] > Alacsony igény esetén a minimális értékek csökkenhet is a szál készlet szálak aktuális száma."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Ez a módszer adja vissza, ha, amely a szálkészlet igény szerinti hoz munkaszál minimális számát tartalmazza."
    - id: completionPortThreads
      type: System.Int32
      description: "Ez a módszer adja vissza, ha aszinkron i/o-szálak, amely a szálkészlet igény szerinti hoz minimális számát tartalmazza."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Várólisták végrehajtandó metódus. A metódus hajtja végre, amikor egy szál készlet szál elérhetővé válik."
  remarks: "Elhelyezheti a szolgáltatáspéldány-mezők, amelyben módszerét, vagy használhatja az osztály az aszinkron metódus által a <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>, amely fogadja a szükséges adatokat tartalmazó objektum túlterhelési.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Visual Basic-felhasználók kihagyhatja a <xref:System.Threading.WaitCallback>konstruktor, és egyszerűen használhatja a `AddressOf` operátor számára történő átadásakor a visszahívási metódus <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic automatikusan meghívja a megfelelő delegált konstruktorában.      ## Verzió információkat a a .NET-keretrendszer 2.0-s, a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>tulajdonság értéke propagálja munkaszál várólistára használatával a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metódus.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> , amely jelöli, a végrehajtandó metódus."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a metódus sikeresen várólistára; <xref:System.NotSupportedException>vált ki, ha a munkaelem nem helyezi várólistára.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A közös nyelvi futtatókörnyezet (CLR) van-e tárolva, és a gazdagép nem támogatja ezt a műveletet."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A végrehajtási metódus várólisták, és adja meg a metódus által használt adatokat tartalmazó objektum. A metódus hajtja végre, amikor egy szál készlet szál elérhetővé válik."
  remarks: "Ha visszahívási metódus összetett adatokra van szüksége, megadhat egy osztály az adatokat tartalmazza.      > [!NOTE] > Visual Basic-felhasználók kihagyhatja a <xref:System.Threading.WaitCallback>konstruktor, és egyszerűen használhatja a `AddressOf` üzemeltető számára történő átadásakor a visszahívási metódus QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic automatikusan meghívja a megfelelő delegált konstruktorában.      ## Verzió információkat a a .NET-keretrendszer 2.0-s, a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>tulajdonság értéke propagálja munkaszál várólistára használatával a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metódus.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> képviselő végrehajtandó metódus."
    - id: state
      type: System.Object
      description: "A metódus által használt adatokat tartalmazó objektum."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a metódus sikeresen várólistára; <xref:System.NotSupportedException>vált ki, ha a munkaelem nem helyezi várólistára.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A közös nyelvi futtatókörnyezet (CLR) van-e tárolva, és a gazdagép nem támogatja ezt a műveletet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a 32 bites előjeles egész számokat az időtúllépési ezredmásodpercben.</xref:System.Threading.WaitHandle>"
  remarks: "Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A registerwaitforsingleobject függvény metódus várólisták a meghatározott delegált a szálkészlethez. Egy munkavégző szál végrehajtja a delegált esetén a következők egyikét:-a megadott objektum a jelzett állapotban van.      -A időtúllépés eltelt.       A registerwaitforsingleobject függvény metódust a megadott objektum <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> aktuális állapotát ellenőrzi. Ha az objektum állapota unsignaled, a metódus regisztrál egy várakozási művelet. A várakozási művelet egy szál a szálkészlet végzi. A delegált végrehajtása egy munkavégző szál által az objektum állapota jelzést válik, vagy a időtúllépés lejárta. Ha a `timeOutInterval` paraméter nem 0 (nulla) és a `executeOnlyOnce` paraméter `false`, az időzítő pedig nullázásra kerül minden alkalommal, amikor az esemény leállítási jelzést kapott, vagy az időtúllépési időtartam.      > [!IMPORTANT] > Használata egy <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex> Ahelyett, hogy egy <xref:System.Threading.Mutex>, használja a <xref:System.Threading.Semaphore>a maximális számát 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       A várakozási műveletet mégsem folytatja, hívja meg a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A várakozási szálat használ a Win32 `WaitForMultipleObjects` függvény regisztrált várakozási műveletek figyelését. Ezért, ha a ugyanazon operációs rendszere leíró kell használnia a registerwaitforsingleobject függvény több hívást, kell másolatot készít a használatával a Win32-leíró `DuplicateHandle` függvény. Vegye figyelembe, hogy az esemény registerwaitforsingleobject függvény, átadott objektum nem meg kell impulzusos, mert előfordulhat, hogy a várakozási szál nem észleli az, hogy az esemény leállítási jelzést kapott előtt alaphelyzetbe áll.       Kell a visszatérésre, a függvény bizonyos típusú szinkronizálási objektumok állapotának módosítása. Módosítása csak az objektum, amelynek jelzett állapot miatt a várakozási feltétel teljesítettnek történik. Például egy szemafor száma csökken.      ## Verzió információk kezdve a .NET-keretrendszer 2.0-s verziója a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>munkaszál propagálja tulajdonság értéke várólistára használatával a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "A következő delegáltnak átadott objektum."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , amely magában foglalja a natív leíró."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> millisecondsTimeOutInterval </code> paraméter értéke kisebb, mint -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a 64 bites előjeles egész számokat az időtúllépési ezredmásodpercben.</xref:System.Threading.WaitHandle>"
  remarks: "Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A registerwaitforsingleobject függvény metódus várólisták a meghatározott delegált a szálkészlethez. Egy munkavégző szál végrehajtja a delegált esetén a következők egyikét:-a megadott objektum a jelzett állapotban van.      -A időtúllépés eltelt.       A registerwaitforsingleobject függvény metódust a megadott objektum <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> aktuális állapotát ellenőrzi. Ha az objektum állapota unsignaled, a metódus regisztrál egy várakozási művelet. A várakozási művelet egy szál a szálkészlet végzi. A delegált végrehajtása egy munkavégző szál által az objektum állapota jelzést válik, vagy a időtúllépés lejárta. Ha a `timeOutInterval` paraméter nem 0 (nulla) és a `executeOnlyOnce` paraméter `false`, az időzítő pedig nullázásra kerül minden alkalommal, amikor az esemény leállítási jelzést kapott, vagy az időtúllépési időtartam.      > [!IMPORTANT] > Használata egy <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex> Ahelyett, hogy egy <xref:System.Threading.Mutex>, használja a <xref:System.Threading.Semaphore>a maximális számát 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       A várakozási műveletet mégsem folytatja, hívja meg a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A várakozási szálat használ a Win32 `WaitForMultipleObjects` függvény regisztrált várakozási műveletek figyelését. Ezért, ha a ugyanazon operációs rendszere leíró kell használnia a registerwaitforsingleobject függvény több hívást, kell másolatot készít a használatával a Win32-leíró `DuplicateHandle` függvény. Vegye figyelembe, hogy az esemény registerwaitforsingleobject függvény, átadott objektum nem meg kell impulzusos, mert előfordulhat, hogy a várakozási szál nem észleli az, hogy az esemény leállítási jelzést kapott előtt alaphelyzetbe áll.       Kell a visszatérésre, a függvény bizonyos típusú szinkronizálási objektumok állapotának módosítása. Módosítása csak az objektum, amelynek jelzett állapot miatt a várakozási feltétel teljesítettnek történik. Például egy szemafor száma csökken.      ## Verzió információk kezdve a .NET-keretrendszer 2.0-s verziója a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>munkaszál propagálja tulajdonság értéke várólistára használatával a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "Az objektum lett átadva a delegált."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , amely magában foglalja a natív leíró."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> millisecondsTimeOutInterval </code> paraméter értéke kisebb, mint -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a <xref:System.TimeSpan>az időtúllépési érték.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A registerwaitforsingleobject függvény metódus várólisták a meghatározott delegált a szálkészlethez. Egy munkavégző szál végrehajtja a delegált esetén a következők egyikét:-a megadott objektum a jelzett állapotban van.      -A időtúllépés eltelt.       A registerwaitforsingleobject függvény metódust a megadott objektum <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> aktuális állapotát ellenőrzi. Ha az objektum állapota unsignaled, a metódus regisztrál egy várakozási művelet. A várakozási művelet egy szál a szálkészlet végzi. A delegált végrehajtása egy munkavégző szál által az objektum állapota jelzést válik, vagy a időtúllépés lejárta. Ha a `timeOutInterval` paraméter nem 0 (nulla) és a `executeOnlyOnce` paraméter `false`, az időzítő pedig nullázásra kerül minden alkalommal, amikor az esemény leállítási jelzést kapott, vagy az időtúllépési időtartam.      > [!IMPORTANT] > Használata egy <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex> Ahelyett, hogy egy <xref:System.Threading.Mutex>, használja a <xref:System.Threading.Semaphore>a maximális számát 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       A várakozási műveletet mégsem folytatja, hívja meg a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A várakozási szálat használ a Win32 `WaitForMultipleObjects` függvény regisztrált várakozási műveletek figyelését. Ezért, ha a ugyanazon operációs rendszere leíró kell használnia a registerwaitforsingleobject függvény több hívást, kell másolatot készít a használatával a Win32-leíró `DuplicateHandle` függvény. Vegye figyelembe, hogy az esemény registerwaitforsingleobject függvény, átadott objektum nem meg kell impulzusos, mert előfordulhat, hogy a várakozási szál nem észleli az, hogy az esemény leállítási jelzést kapott előtt alaphelyzetbe áll.       Kell a visszatérésre, a függvény bizonyos típusú szinkronizálási objektumok állapotának módosítása. Módosítása csak az objektum, amelynek jelzett állapot miatt a várakozási feltétel teljesítettnek történik. Például egy szemafor száma csökken.      ## Verzió információk kezdve a .NET-keretrendszer 2.0-s verziója a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>munkaszál propagálja tulajdonság értéke várólistára használatával a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "Az objektum lett átadva a delegált."
    - id: timeout
      type: System.TimeSpan
      description: "Az időtúllépés <xref:System.TimeSpan>.</xref:System.TimeSpan> által képviselt Ha `timeout` 0 (nulla), a függvény megvizsgálja az objektum állapota, és azonnal visszaadja. Ha `timeout` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , amely magában foglalja a natív leíró."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> timeout </code> paraméter értéke kisebb, mint -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <code> timeout </code> paraméter értéke nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a 32 bites előjel nélküli egész számokat az időtúllépési ezredmásodpercben.</xref:System.Threading.WaitHandle>"
  remarks: "Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus várólisták a meghatározott delegált a szálkészlethez.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Egy munkavégző szál végrehajtja a delegált esetén a következők egyikét:-a megadott objektum a jelzett állapotban van.      -A időtúllépés eltelt.       A <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>módszer a megadott objektum <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> aktuális állapotát ellenőrzi.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Ha az objektum állapota unsignaled, a metódus regisztrál egy várakozási művelet. A várakozási művelet egy szál a szálkészlet végzi. A delegált végrehajtása egy munkavégző szál által az objektum állapota jelzést válik, vagy a időtúllépés lejárta. Ha a `timeOutInterval` paraméter nem 0 (nulla) és a `executeOnlyOnce` paraméter `false`, az időzítő pedig nullázásra kerül minden alkalommal, amikor az esemény leállítási jelzést kapott, vagy az időtúllépési időtartam.      > [!IMPORTANT] > Használata egy <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex> Ahelyett, hogy egy <xref:System.Threading.Mutex>, használja a <xref:System.Threading.Semaphore>a maximális számát 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       A várakozási műveletet mégsem folytatja, hívja meg a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       A várakozási szálat használ a Win32 `WaitForMultipleObjects` függvény regisztrált várakozási műveletek figyelését. Ezért az ugyanazon operációs rendszere leírójának használata több hívások <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, kell másolatot készít a használatával a Win32-leíró `DuplicateHandle` függvény.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Vegye figyelembe, hogy az esemény átadott objektum nem kell impulzusos <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, mert előfordulhat, hogy a várakozási szál nem észleli az, hogy az esemény leállítási jelzést kapott előtt alaphelyzetbe áll.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Kell a visszatérésre, a függvény bizonyos típusú szinkronizálási objektumok állapotának módosítása. Módosítása csak az objektum, amelynek jelzett állapot miatt a várakozási feltétel teljesítettnek történik. Például egy szemafor száma csökken.      ## Verzió információk kezdve a .NET-keretrendszer 2.0-s verziója a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>munkaszál propagálja tulajdonság értéke várólistára használatával a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> A korábbi verziókban a fő információk nem terjeszthetők."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "Az objektum lett átadva a delegált."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , amely használható a regisztrált Várjon, amíg a művelet megszakításához."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> millisecondsTimeOutInterval </code> paraméter értéke kisebb, mint -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szálkészlet aktív lehet egyidejűleg állítja be kérelmek számát jelenti. Felett, hogy a kívánt összes kérelem maradnak amíg szál készlet szálak elérhetővé válnak."
  remarks: "Nem állíthat munkaszál vagy i/o-végrehajtási szálak maximális száma szám kisebb, mint a processzorok száma. Annak meghatározásához, hány processzorok jelen, értékének beolvasása a <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>tulajdonság.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> Ezenkívül nem be munkaszál vagy i/o végrehajtási szál a munkaszálak megfelelő minimális számánál kisebb számot vagy i/o-végrehajtási szálak maximális számát. Határozza meg a minimális szálkészlet méretét, hívja meg a <xref:System.Threading.ThreadPool.GetMinThreads%2A>metódus.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Ha a közös nyelvi futtatókörnyezet, például az Internet Information Services (IIS) vagy SQL Server által az állomás is korlátozható vagy módosításának megakadályozása a szálkészlet méretét.       Körültekintően járjon el, ha módosítja a szálkészlet szálak maximális számát. A kód előnye, a módosítások merülhetnek ártalmas kód szalagtárak használja.       A szál mérete túl nagy beállítása teljesítményproblémákat okozhat. Ha túl sok szál állnak végrehajtás alatt egy időben, a feladat váltás terhet válik a lényeges szempontja."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "A szálkészlet a munkaszálak maximális száma."
    - id: completionPortThreads
      type: System.Int32
      description: "A szálkészlet aszinkron i/o szálak maximális száma."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a módosítás sikeres; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szálkészlet hoz létre az igény szerinti szálak minimális száma beállítják új kérések, szál létrehozása és megsemmisítése kezelésére szolgáló algoritmus átváltás előtt."
  remarks: "A szálkészlet nyújt új munkaszálat vagy i/o-végrehajtási szálak az igény szerinti kategóriákhoz tartozó minimális eléréséig. A minimális elérésekor, a szálkészlet kategória további szálat létrehozni, vagy várjon, amíg befejeződik néhány feladatot. Verziótól kezdve a [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], a szálkészlet hoz létre, és szálak megsemmisít átviteli sebességben, ami van definiálva, feladatok, amelyek befejezik időegység alatt optimalizálása érdekében. Túl kevés szálak nem tehetik a rendelkezésre álló erőforrások optimális használatát, mivel túl sok szál Erőforrásverseny nő.       Alacsony igény esetén a minimális érték alá eső értékeket szál készlet szálak aktuális száma is.       Ha megad egy negatív szám vagy egy szám nagyobb, mint az aktív szálon készlet szálak maximális száma (segítségével <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads adja vissza `false` nem változik a minimális értékek egyikét.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > Alapértelmezés szerint a minimális szálak értékre van állítva a rendszer processzorainak számát. A SetMinThreads módszer segítségével növelheti a minimális számú ofthreads. Azonban ezeket az értékeket feleslegesen növelése teljesítményproblémákat okozhat. Ha túl sok feladatok egyszerre indul el, az összes úgy tűnhet, hogy lassú lehet. A legtöbb esetben a szálkészlet javítja a teljesítményt a saját algoritmussal szálak felosztásához. A minimális csökkentése a kevesebb, mint a processzorok számát is hátrányosan befolyásolhatja a teljesítményt."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "A minimális száma, amely a szálkészlet igény szerinti hoz létre munkavégző szál."
    - id: completionPortThreads
      type: System.Int32
      description: "A minimális, amely a szálkészlet igény szerinti hoz aszinkron i/o-szálak száma."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a módosítás sikeres; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Várólisták egy átlapolt i/o műveletekhez művelet végrehajtásához."
  remarks: "A natív Win32 használatáról i/o átfedésben vannak, tekintse meg a <xref:System.Threading.Overlapped>osztály, a <xref:System.Threading.NativeOverlapped>struktúra, és a `OVERLAPPED` struktúra, a Win32 Platform SDK.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      > [!CAUTION] > A UnsafeQueueNativeOverlapped használatával metódus véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Ha work UnsafeQueueNativeOverlapped használatával szál készlet szálban kell várakoznia, a szál készlet szál a verem nem áll a tényleges hívóknak keretében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "A <xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> várólista szerkezetének."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a művelet sikeresen várólistára került i/o-befejezési portra; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A megadott delegált a szálkészlethez várólisták, de a hívási veremben a munkavégző szál nem propagálja."
  remarks: "Ellentétben a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metódus, UnsafeQueueUserWorkItem nem propagálja a hívási veremben a munkavégző szál.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Ez lehetővé teszi, hogy megszakítja a hívási verem, és ezáltal emelheti a saját biztonsági jogosultságait.      > [!CAUTION] > Használatával UnsafeQueueUserWorkItem véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Munkahelyi UnsafeQueueUserWorkItem használatával szál készlet szálban kell várakoznia, ha a szál készlet szál a verem nem lesz a tényleges hívóknak környezetében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> , amely a következő delegáltnak meghívni, amikor a szálkészlet szál szerzi be a munkaelem jelöli."
    - id: state
      type: System.Object
      description: "Az objektum, amely a szálkészlet továbbítódik a küldött, amikor javítás."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a metódus sikeres; <xref:System.OutOfMemoryException>vált ki, ha a munkaelem nem helyezi várólistára.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Egy kevés a memória állapot lépett fel."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "A munkaelem nem helyezi várólistára."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, 32 bites előjeles egész számokat használ a időkorlát ezredmásodpercben.</xref:System.Threading.WaitHandle> Ez a módszer nem propagálja a munkavégző szál a hívási verem."
  remarks: "Ellentétben a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus, UnsafeRegisterWaitForSingleObject nem propagálja a hívási veremben a munkavégző szál.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Ez lehetővé teszi, hogy megszakítja a hívási verem, és ezáltal emelheti a saját biztonsági jogosultságait.      > [!CAUTION] > Használatával UnsafeRegisterWaitForSingleObject véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Munkahelyi UnsafeRegisterWaitForSingleObject használatával szál készlet szálban kell várakoznia, ha a szál készlet szál a verem nem lesz a tényleges hívóknak környezetében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében.       Használja a <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex>       Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "A következő delegáltnak átadott objektum."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objektum, amely segítségével a regisztrált várakozási művelet megszakításához."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> millisecondsTimeOutInterval </code> paraméter értéke kisebb, mint -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a 64 bites előjeles egész számokat az időtúllépési ezredmásodpercben.</xref:System.Threading.WaitHandle> Ez a módszer nem propagálja a munkavégző szál a hívási verem."
  remarks: "Ellentétben a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus, UnsafeRegisterWaitForSingleObject nem propagálja a hívási veremben a munkavégző szál.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Ez lehetővé teszi, hogy megszakítja a hívási verem, és ezáltal emelheti a saját biztonsági jogosultságait.      > [!CAUTION] > Használatával UnsafeRegisterWaitForSingleObject véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Munkahelyi UnsafeRegisterWaitForSingleObject használatával szál készlet szálban kell várakoznia, ha a szál készlet szál a verem nem lesz a tényleges hívóknak környezetében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében.       Használja a <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex>       Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "A következő delegáltnak átadott objektum."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objektum, amely segítségével a regisztrált várakozási művelet megszakításához."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> millisecondsTimeOutInterval </code> paraméter értéke kisebb, mint -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a <xref:System.TimeSpan>az időtúllépési érték.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Ez a módszer nem propagálja a munkavégző szál a hívási verem."
  remarks: "Ellentétben a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus, UnsafeRegisterWaitForSingleObject nem propagálja a hívási veremben a munkavégző szál.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Ez lehetővé teszi, hogy megszakítja a hívási verem, és ezáltal emelheti a saját biztonsági jogosultságait.      > [!CAUTION] > Használatával UnsafeRegisterWaitForSingleObject véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Munkahelyi UnsafeRegisterWaitForSingleObject használatával szál készlet szálban kell várakoznia, ha a szál készlet szál a verem nem lesz a tényleges hívóknak környezetében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében.       Használja a <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex>       Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "A következő delegáltnak átadott objektum."
    - id: timeout
      type: System.TimeSpan
      description: "Az időtúllépés <xref:System.TimeSpan>.</xref:System.TimeSpan> által képviselt Ha `timeout` 0 (nulla), a függvény megvizsgálja az objektum állapota, és azonnal visszaadja. Ha `timeout` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objektum, amely segítségével a regisztrált várakozási művelet megszakításához."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <code> timeout </code> paraméter értéke kisebb, mint -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <code> timeout </code> paraméter értéke nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Regisztrálja a történő várakozás delegált egy <xref:System.Threading.WaitHandle>, adja meg a 32 bites előjel nélküli egész számokat az időtúllépési ezredmásodpercben.</xref:System.Threading.WaitHandle> Ez a módszer nem propagálja a munkavégző szál a hívási verem."
  remarks: "Ellentétben a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metódus, UnsafeRegisterWaitForSingleObject nem propagálja a hívási veremben a munkavégző szál.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Ez lehetővé teszi, hogy megszakítja a hívási verem, és ezáltal emelheti a saját biztonsági jogosultságait.      > [!CAUTION] > Használatával UnsafeRegisterWaitForSingleObject véletlenül megnyithat egy biztonsági rést be. Kódelérés-biztonsági engedély ellenőrizze az összes hívó engedélyeit a veremben alapjait. Munkahelyi UnsafeRegisterWaitForSingleObject használatával szál készlet szálban kell várakoznia, ha a szál készlet szál a verem nem lesz a tényleges hívóknak környezetében. Rosszindulatú kódot lehet kihasználni a engedélyek ellenőrzését elkerülése érdekében.       Használja a <xref:System.Threading.Mutex>a `waitObject` nem biztosít a visszahívások kölcsönös kizárás, mert az alapul szolgáló Win32 API-t használja az alapértelmezett `WT_EXECUTEDEFAULT` , így minden visszahívási megtörténik egy külön szálban készlet szálon jelzőt.</xref:System.Threading.Mutex>       Ha készen használatával a <xref:System.Threading.RegisteredWaitHandle>, hogy ez a metódus által visszaadott, hívja az <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>való hivatkozást a várakozási leíró metódus.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Azt javasoljuk, hogy mindig meghívja a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus, még akkor is, ha megadja `true` a `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> A szemétgyűjtés a lehető leghatékonyabban több hívásakor a <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metódus helyett attól függően, hogy a regisztrált várakozási leíró véglegesítőt.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "A <xref:System.Threading.WaitHandle>regisztrálni.</xref:System.Threading.WaitHandle> Egy <xref:System.Threading.WaitHandle>eltérő <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle> használata"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "A delegált hívására, ha a `waitObject` paraméter leállítási jelzést kapott."
    - id: state
      type: System.Object
      description: "A következő delegáltnak átadott objektum."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Az időkorlát ezredmásodpercben. Ha a `millisecondsTimeOutInterval` paraméter értéke 0 (nulla), a függvény az objektum állapota teszteli, és azonnal visszaadja az eredményeket. Ha `millisecondsTimeOutInterval` -1, a függvény időtúllépés soha nem telik."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>jelzi, hogy a szál nem várakozik a `waitObject` paraméter után a meghatalmazott; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy az időzítő pedig nullázásra kerül minden alkalommal, amikor a várakozási művelet befejeződik, amíg a Várjon, amíg nem regisztrált."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "A <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objektum, amely segítségével a regisztrált várakozási művelet megszakításához."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
