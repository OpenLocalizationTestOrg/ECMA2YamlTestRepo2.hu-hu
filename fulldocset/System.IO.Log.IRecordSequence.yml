### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Bejegyzések sorozatát általános felületet biztosít."
  remarks: "A IRecordSequence felület révén rekord célú adatfolyamba absztrakt illesztőfelület. A IRecordSequence példánya írási és olvasási naplórekordokat használható.       A következő lehetőségeket biztosítja a IRecordSequence felületet, - hozzáfűzése napló használatával rögzíti a <xref:System.IO.Log.IRecordSequence.Append%2A>módszerek.</xref:System.IO.Log.IRecordSequence.Append%2A>      -A hozzáfűzött rekordok olvasása használatával a <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -Írni a különleges újraindítás rekord használatával a <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metódus.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Olvasás, indítsa újra a legutóbb írt újraindítás rekord a rekordok a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -Ürítse ki a rekordok tartós tároló használatára a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Hely a rekordok hozzáfűzése lefoglalni.      -Szabad területet a napló a következő speciális által.      -Fogadási <xref:System.IO.Log.IRecordSequence.TailPinned>történő áthelyezéséhez szabadítson fel lemezterületet a napló a következő rendszeresemény-értesítéseket.</xref:System.IO.Log.IRecordSequence.TailPinned>       Naplórekordok IRecordSequence példányhoz lesz hozzáfűzve, és a Minden naplóbejegyzés egyedi sorszámot. Sorozatszámok belül egy adott rekordsorozat szigorúan monoton növekednek. Egy naplóbejegyzést képviselnek nem átlátszó adat, a IRecordSequence példánya a áll egy <xref:System.Collections.IList>a ArraySegments bájt.</xref:System.Collections.IList>       A IRecordSequence felület is közzétesz néhány alapvető tulajdonságaiban, amely tájékoztatást ad azokról a napló határokat.      -A <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>tulajdonsága tartalmazza a sorszám az első érvényes rekord a rekordsorozat.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -A <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>tulajdonsága tartalmazza a sorszámot, amely nagyobb, mint a sorozat száma az utolsó hozzáfűzi a rekordot.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -A <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>tulajdonsága tartalmazza a sorszám az utolsó írásbeli újraindítás terület.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -A <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>tulajdonsága tartalmazza a legnagyobb rekordot, amely lesz hozzáfűzve, vagy a sorozatot olvasására méretét.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -A <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>tulajdonsága tartalmazza az összes foglalások rekord sorozatszáma teljes mérete.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Ha a <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>tulajdonsága `true`, és egy <xref:System.IO.Log.IRecordSequence.Append%2A>művelet sikertelen, mert nincs hely a sorrendben, a rekordsorozat szabadítson fel lemezterületet, majd próbálja megismételni a hozzáfűzési művelet megkísérli.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A kiinduló sorszám napló továbblép."
  remarks: "Ha egy <xref:System.IO.Log.LogRecordSequence>példányt, és próbálja meg a szabadítson fel lemezterületet a napló sorszáma előzetes, az új alap sequence számot egy másik napló mértékben üresen kell megjelölni a korábbi egység kell lennie,.</xref:System.IO.Log.LogRecordSequence> Egységek részben felszabadítása nem támogatott."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A rekordsorozat új alap sequence száma."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>érvénytelen."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>Nincs aktív a naplóba."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a feladatütemezési módosítása."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor a napló rekordot ír a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor az első érvényes rekord sorszámát lekérdezi az aktuális <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Érvényes sorszámok: nagyobb vagy egyenlő BaseSequenceNumber és <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> -nál kisebb       Ez a tulajdonság értékének megváltoztatására meghívásával a <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>vagy <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metódus.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A legalacsonyabb sorszám, amely érvényes rekord megfelel a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, elkezdi egy aszinkron művelet hozzáfűzése."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, elkezdi az aszinkron műveletet, a sorrendben korábban fenntartott helyet hozzáfűzése."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, elkezdi az aszinkron műveletet sorrendben korábban fenntartott helyet hozzáfűzése."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, elkezdi az aszinkron műveletet, a sorrendben korábban fenntartott helyet hozzáfűzése."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, elkezdi az aszinkron kiürítési művelet, a sorrendben korábban fenntartott helyet használja."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>az aktuális metódus által visszaadott a <xref:System.IO.Log.IRecordSequence.EndFlush%2A>módszer annak biztosítására, hogy a kiürítés befejeződött, és erőforrásokat megfelelő felszabadítását.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Egy aszinkron kiürítése közben hiba lép fel, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.IRecordSequence>tartósan íródtak.</xref:System.IO.Log.IRecordSequence>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Aszinkron kiürítési kérés, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák hatására a kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha a <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, hogy hívható meg abban az esetben, ha a kiürítés befejeződött."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron kiürítési kérés megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron flush műveletet, amely sikerült még függőben lehet.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha a felülbírálva a származtatott osztály, egy aszinkron tartalék kezdődik, és hozzáfűzése művelet."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha a felülbírálva a származtatott osztály, egy aszinkron tartalék kezdődik, és hozzáfűzése művelet."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor megkezdi egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használ."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metódus ahhoz, hogy biztosítsa, hogy az újraindítás terület írási művelet befejeződött, és erőforrásokat is megfelelő felszabadítását.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor megkezdi egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használ."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>módszer annak biztosítására, hogy az újraindítási terület írási művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha a származtatott osztály felülbírálva, létrehoz egy új <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Az újonnan létrehozott <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor befejeződik az aszinkron hozzáfűzése művelet."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>metódus.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, befejeződik az aszinkron kiürítési művelet."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron kiürítési kérés, például a lemez i/o kérelem során során előforduló hibákat EndFlush meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>metódus.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, ha a végpontok aszinkron lefoglalni, és a hozzáfűző műveletet."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndReserveAndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>metódus.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, befejeződik az aszinkron újraindítás terület írási művelet."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndWriteRestartArea meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>metódus.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Írásbeli naplórekord sorszámát."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, biztosítja, hogy az összes hozzáfűzött rekord készült."
  remarks: "A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.IRecordSequence>tartósan írt.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, biztosítja, hogy az összes hozzáfűzött rekord a rekord, a megadott sorszám bezárólag tartósan készült."
  remarks: "Ez a módszer biztosítja, hogy az összes rekordot feladatütemezési legfeljebb számok hívása és többek között a megadott sorszám tartósan készült."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha a <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor lekérdezi a sorszám lesz hozzáfűzve utolsó rekordját nagyobb."
  remarks: "Ez a tulajdonság tartalmazza a sorszámot, amely nagyobb, mint a sorozat száma az utolsó hozzáfűzi a rekordot. Érvényes sorszámok nagyobb vagy egyenlő <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>pedig kisebb LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > Egy <xref:System.IO.Log.LogRecordSequence>példányt, <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>értéket is elavulttá válnak mindaddig, amíg a napló tartalmát rekordok</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> használata esetén Olvassa el <xref:System.IO.Log.IRecordSequence.Flush%2A>és a <xref:System.IO.Log.RecordAppendOptions>További tájékoztatást a könyvelési rögzíti.</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám, ez pedig nagyobb, mint az utolsó hozzáfűzött rekord."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, kap a legnagyobb rekordot, amely fűzött vagy olvasni az ebben a sorozatban, bájtban méretét."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "A legnagyobb rekordot, amely fűzött vagy olvasni az ebben a sorozatban, bájtban kifejezett mérete."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, a feladatütemezési adja vissza a rekordok egy enumerálható gyűjteményhez."
  remarks: "Ha felül van bírálva a származtatott osztály, a feladatütemezési adja vissza a rekordok egy enumerálható gyűjteményhez. A felsorolt rekordok függ értékének a `logRecordEnum` paraméter."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Ha a olvasási indítja el az első rekordra sorszámát."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Egy érvényes <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> érték, amely meghatározza a rekordok olvassa el a módon (vagyis előre vagy visszafelé haladva) egy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Rögzíti a sorozatban enumerálható gyűjteménye."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord olvasása közben."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, az újraindítás területek enumerálható gyűjteményt a feladatütemezési adja vissza."
  remarks: "Az újraindítás területek enumerálása a feladatütemezési fordított sorrendben, ez azt jelenti, hogy az a legnagyobb sorszám a legalacsonyabb sorszámmal. Csak indítsa újra a területek sorszámmal közötti utolsó számát, és a kiinduló sorszám enumerálása.      > [!NOTE] > Ha a napló mértékben tartalmazó a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>akkor kerül sérült, ez a módszer segítségével throw egy <xref:System.IO.IOException>a következő hibaüzenettel &quot;a kérelmet nem lehetett végrehajtani, mert váratlan i/o-kivétel.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> A következő hibát jelezte: &quot;80070026&quot; &quot;."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "A feladatütemezési újraindítás területein enumerálható gyűjteménye."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord olvasása közben."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, automatikusan lehetővé teszi egyetlen foglalás, és hozzáfűzi a rekord a feladatütemezési."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, automatikusan lehetővé teszi egyetlen foglalás, és hozzáfűzi a rekord a feladatütemezési."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor lekérdezi a lefoglalt bájtok teljes száma."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "A rekord sorozat összes foglalások teljes mérete."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felül van bírálva a származtatott osztály, amikor lekérdezi a legutóbb írt újraindítási terület sorszámát."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A legtöbb legutóbb írt sorszámát területén indítsa újra."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi vagy beállítja, hogy egy érték, amely jelzi, hogy hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt."
  remarks: "Ha ez a tulajdonság értéke `true`, és egy <xref:System.IO.Log.IRecordSequence.Append%2A>hívás sikertelen lesz, mivel nincs elegendő lemezterület a sorrendben, a rekordsorozat megpróbálja szabadítson fel lemezterületet, és ismételje meg a Hozzáfűzés.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A rekord feladatütemezési határozza meg, hogy a kiegészítő kell áthelyezni előre következik be."
  remarks: "Ezt az eseményt, amikor a rekordsorozat elfogyott a lemezterület is érvényesítést. Ez az esemény akkor következik be, amikor a feladatütemezési (Ez azt jelenti, hogy az alap sorszáma) végének került előre szabadítson fel lemezterületet."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók. Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> , és frissíti az alap sequence száma"
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók. Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> , és frissíti a alap sorszám."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók. Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> foglalás használ, és frissíti a alap sorszám"
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók. Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor egy újraindítás területen írja a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> foglalás használ, és frissíti a alap sorozatszámot."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, elemzi a lekérik az adatokat az utolsó ellenőrzőpont-művelet az újraindítás területen. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók. Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
