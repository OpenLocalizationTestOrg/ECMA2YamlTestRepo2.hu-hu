### YamlMime:ManagedReference
items:
- uid: System.IO.Log.ReservationCollection
  id: ReservationCollection
  children:
  - System.IO.Log.ReservationCollection.#ctor
  - System.IO.Log.ReservationCollection.Add(System.Int64)
  - System.IO.Log.ReservationCollection.Clear
  - System.IO.Log.ReservationCollection.Contains(System.Int64)
  - System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  - System.IO.Log.ReservationCollection.Count
  - System.IO.Log.ReservationCollection.Finalize
  - System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  - System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  - System.IO.Log.ReservationCollection.GetEnumerator
  - System.IO.Log.ReservationCollection.IsReadOnly
  - System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  - System.IO.Log.ReservationCollection.Remove(System.Int64)
  - System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  - System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  - System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  langs:
  - csharp
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
  type: Class
  summary: "Kezeli a rekordsorozat terület foglalások gyűjteménye."
  remarks: "Ez az osztály a rekordsorozat végrehajtott foglalás területek készletét reprezentálja. Új foglalások elemek hozzáadása a gyűjteményhez foglal le. Ezeket a fenntartásokat elemek eltávolítása a gyűjteményből szabadít fel.       Egy alkalmazás fenntartja a hely a naplóban szereplő adatokat, amelyek is bekerülnek a naplóba a jövőben van, de nem írja azonnal. Foglalások biztosítja, hogy az is lehet adatokat írni a napló elérhető kellene írni az adatok esetén adja meg. Naplók használata esetén az alkalmazások gyakran lefoglalni egy vagy több naplóbejegyzést rendező területén. Hozzáfűzés őket előtt kell lefoglalni.       Foglalások segítségével garantálható, hogy egy művelet befejeződött, mielőtt az adatokat véglegesíteni; Ellenkező esetben a módosítás visszavonásra kerül. Is használható a naplóban szereplő &quot;visszavonási művelet&quot; rögzítéséhez. A visszaállítási művelet során egy tranzakciós erőforrás-kezelő (RM) állapotában helyreállíthatja, ha az erőforrás-kezelő a visszaállítási művelet során megszakad kell lennie. A foglalási terület használatával egy erőforrás-kezelő foglalhat lemezterületet a napló használata előtt.       A <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>metódus lemezterület lefoglalása vagy adatokat, vagy mindkettőt, attól függően, hogy a megadott paraméterek, miközben a hozzáfűzése.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Munka időtartamára szerepel egy tranzakcióban, az alkalmazások hozzáfűzése a visszavonási információ, és kompenzációs rekord rajta. A visszaállítási művelet során létrehozott kompenzációs rekordokat azt jelzik, mi volt a lemezen visszavonni. A rekordok használatával korábban lefoglalt terület lesz hozzáfűzve. Ez biztosítja, hogy egy erőforrás-kezelő nem elfogy napló területet, amely Kezelhetetlen körülmény, a visszaállítási művelet végrehajtása közben. A napló megtelik tranzakció során, ha egy alkalmazás biztonságosan vissza lehet vonni egy tranzakció rongál tartós adatok nélkül.       CLFS amely ARIES-kompatibilis naplózási rendszer, azt jelentette, hogy az írási előre naplózás. Írási előre naplózása, az alkalmazás egy visszavonási rekordot ír, mielőtt a rendszer a művelet, a napló írása kompenzációs rekord,-visszavonás során felhasználható tart terület mennyisége foglalása. Később a foglalt területet a kompenzációs rekord ténylegesen írásakor használatos.       Alkalmazások lefoglalni vagy hosszú hely eléréséhez (azok egymást kölcsönösen kizáró műveletek) egy adott időpontban. A véglegesítés után rekord írása a napló alkalmazás is szabadítson fel a lefoglalását a kompenzáció rekordok. Ez a művelet végezhető hívásával vagy a <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>vagy <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> </xref:System.IO.Log.ReservationCollection.FreeReservation%2A> Hívja a <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>módszer biztosítja, hogy a művelet hívása közben atomi a <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>metódus nem.</xref:System.IO.Log.ReservationCollection.FreeReservation%2A> </xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>       Ingyenes rögzíti, amikor szabadítson együtt egy korábbi hívás lefoglalt ugyanazokat a rekordokat a <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>metódus.</xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>      > [!NOTE] > Megvalósítását <xref:System.IO.Log.IRecordSequence>meg kell valósítania a <xref:System.IO.Log.ReservationCollection.MakeReservation%2A>és <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>módszerek a tényleges foglalás lemezfoglalási és -felszabadítás végrehajtásához.</xref:System.IO.Log.ReservationCollection.FreeReservation%2A> </xref:System.IO.Log.ReservationCollection.MakeReservation%2A> </xref:System.IO.Log.IRecordSequence> Emellett a megvalósítás is kell hívnia <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A>Amikor egy olyan rekordot fenntartott hely íródtak.</xref:System.IO.Log.ReservationCollection.ReservationFreed%2A>"
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: 'public abstract class ReservationCollection : System.Collections.Generic.ICollection<long>, System.Collections.Generic.IEnumerable<long>'
  inheritance:
  - System.Object
  implements:
  - System.Collections.Generic.ICollection<System.Int64>
  - System.Collections.Generic.IEnumerable<System.Int64>
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.#ctor
  id: '#ctor'
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationCollection()
  nameWithType: ReservationCollection.ReservationCollection()
  fullName: System.IO.Log.ReservationCollection.ReservationCollection()
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> osztály."
  syntax:
    content: protected ReservationCollection ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Add(System.Int64)
  id: Add(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Add(Int64)
  nameWithType: ReservationCollection.Add(Int64)
  fullName: System.IO.Log.ReservationCollection.Add(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Foglalja le a foglalást, és hozzáadja azt a gyűjteményt. Ez a módszer nem örökölhető."
  remarks: ''
  example:
  - "The following example shows how to manually make a reservation. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public void Add (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A kért foglalás bájtban kifejezett mérete."
  overload: System.IO.Log.ReservationCollection.Add*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>size</code>Érvénytelen, vagy meghaladja a maximális foglalási méret."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba lép fel, az archív pillanatkép létrehozásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Clear
  id: Clear
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Clear()
  nameWithType: ReservationCollection.Clear()
  fullName: System.IO.Log.ReservationCollection.Clear()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A foglalások a gyűjteményben lévő összes kiadását. Ez a módszer nem örökölhető."
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.Clear*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>size</code>Érvénytelen, vagy meghaladja a maximális foglalási méret."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba lép fel, az archív pillanatkép létrehozásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Contains(System.Int64)
  id: Contains(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Contains(Int64)
  nameWithType: ReservationCollection.Contains(Int64)
  fullName: System.IO.Log.ReservationCollection.Contains(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Meghatározza, hogy történt-e a megadott méretű foglalás. Ez a módszer nem örökölhető."
  syntax:
    content: public bool Contains (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "Keresse meg a gyűjtemény mérete."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a megadott méretű legalább egy foglalás történt; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.Contains*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  id: CopyTo(System.Int64[],System.Int32)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: CopyTo(Int64[],Int32)
  nameWithType: ReservationCollection.CopyTo(Int64[],Int32)
  fullName: System.IO.Log.ReservationCollection.CopyTo(Int64[],Int32)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Másolja a teljes gyűjteményt a céltömb megadott indextől kezdődő egydimenziós tömb. Ez a módszer nem örökölhető."
  syntax:
    content: public void CopyTo (long[] array, int arrayIndex);
    parameters:
    - id: array
      type: System.Int64[]
      description: "A másolási és a tömb."
    - id: arrayIndex
      type: System.Int32
      description: "A nulla alapú indexét a tömbben, mely a másolás megkezdése."
  overload: System.IO.Log.ReservationCollection.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>or <code>arrayIndex</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>kisebb nullánál, vagy nagyobb vagy egyenlő hosszának <code>array</code>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nincs elég hely a meghatározott tömbben az adatok másolásához.       – vagy – <code> array </code> nincs egydimenziós tömb, amely csak akkor támogatott a kért művelet."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Count
  id: Count
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Count
  nameWithType: ReservationCollection.Count
  fullName: System.IO.Log.ReservationCollection.Count
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a foglalások száma a gyűjteményben."
  syntax:
    content: public int Count { get; }
    return:
      type: System.Int32
      description: "A gyűjtemény foglalások száma."
  overload: System.IO.Log.ReservationCollection.Count*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Finalize
  id: Finalize
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReservationCollection.Finalize()
  fullName: System.IO.Log.ReservationCollection.Finalize()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lehetővé teszi, hogy a <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> erőforrások felszabadítására előtt a szemétgyűjtő megsemmisül."
  syntax:
    content: ~ReservationCollection ();
    parameters: []
  overload: System.IO.Log.ReservationCollection.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  id: FreeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: FreeReservation(Int64)
  nameWithType: ReservationCollection.FreeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.FreeReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, ha a megadott méretű foglalás kiadását."
  syntax:
    content: protected abstract void FreeReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A foglalás felszabadítása mérete."
  overload: System.IO.Log.ReservationCollection.FreeReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  id: GetBestMatchingReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: GetBestMatchingReservation(Int64)
  nameWithType: ReservationCollection.GetBestMatchingReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.GetBestMatchingReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, amikor lekérdezi a leginkább megfelelő foglalás a megadott méretre."
  remarks: "Ez a metódus neve általában amikor hozzáfűzése egy rekord a rekordsorozat a foglalt területet. A rendszer visszaadja, a visszaadott méretű foglalás el lett távolítva a gyűjteményből. Ha valamilyen okból a fenntartott terület nem ténylegesen érhető el, a <xref:System.IO.Log.ReservationCollection.ReservationMade%2A>metódust kell meghívni, annak érdekében, hogy a <xref:System.IO.Log.ReservationCollection>pontosan adja meg annak a rekordsorozat lefoglalt lemezterületet.</xref:System.IO.Log.ReservationCollection> </xref:System.IO.Log.ReservationCollection.ReservationMade%2A>"
  syntax:
    content: protected long GetBestMatchingReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A foglalás, amely bele kell férnie a mérete."
    return:
      type: System.Int64
      description: "A gyűjteményhez, amely nagyobb vagy egyenlő a megadott méretet, vagy a -1 esetén nincs ilyen foglalás létezik foglalás."
  overload: System.IO.Log.ReservationCollection.GetBestMatchingReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.GetEnumerator
  id: GetEnumerator
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: ReservationCollection.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.GetEnumerator()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Adja vissza, amely képes iterációt számbavevő a <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ez a módszer nem örökölhető."
  syntax:
    content: public System.Collections.Generic.IEnumerator<long> GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerator{System.Int64}
      description: "Enumerátor, amely képes iterációt az <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.GetEnumerator*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A művelet érvénytelen a következő okai:-a számbavétel befejeződött.      – A gyűjtemény módosult.      -A számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.IsReadOnly
  id: IsReadOnly
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
  fullName: System.IO.Log.ReservationCollection.IsReadOnly
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi egy érték, amely azt jelzi, hogy a gyűjtemény csak olvasható."
  remarks: "A <xref:System.IO.Log.ReservationCollection>csak soha nem olvasható.</xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: public bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "Ez a tulajdonság mindig adja vissza <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  id: MakeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: MakeReservation(Int64)
  nameWithType: ReservationCollection.MakeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.MakeReservation(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ha felül van bírálva a származtatott osztály, foglal le a megadott méretű foglalás."
  syntax:
    content: protected abstract void MakeReservation (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A Foglalás lefoglalni mérete."
  overload: System.IO.Log.ReservationCollection.MakeReservation*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.Remove(System.Int64)
  id: Remove(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: Remove(Int64)
  nameWithType: ReservationCollection.Remove(Int64)
  fullName: System.IO.Log.ReservationCollection.Remove(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Feloldja a megadott méretű foglalás, ha egy sincs kijelölve. Ez a módszer nem örökölhető."
  remarks: ''
  example:
  - "The following example shows how to manually make a reservation. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public bool Remove (long item);
    parameters:
    - id: item
      type: System.Int64
      description: "A foglalás felszabadítása mérete."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a megadott méretű foglalás található és eltávolítása; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.Remove*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nem elég nagy a rekord elférne foglalás a megadott foglalási gyűjteményben találhatók."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba lép fel, az archív pillanatkép létrehozásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  id: ReservationFreed(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationFreed(Int64)
  nameWithType: ReservationCollection.ReservationFreed(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationFreed(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Felülbírálja a származtatott osztály, jelzi, hogy a Foglalás kiadása."
  remarks: "Ha öröklése a <xref:System.IO.Log.ReservationCollection>, meg kell hívnia az ezt a módszert foglalás eltávolítaná a gyűjtemény-nem kiadásakor.</xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: protected void ReservationFreed (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A Foglalás kiadott mérete."
  overload: System.IO.Log.ReservationCollection.ReservationFreed*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  id: ReservationMade(System.Int64)
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: ReservationMade(Int64)
  nameWithType: ReservationCollection.ReservationMade(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationMade(Int64)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Amikor felül van bírálva a származtatott osztály, azt jelzi, hogy a foglalás nem lett végrehajtva."
  remarks: "Ha Ön öröklik <xref:System.IO.Log.ReservationCollection>, hívja meg ezt a módszert, ha a Foglalás kívül <xref:System.IO.Log.ReservationCollection.Add%2A>.</xref:System.IO.Log.ReservationCollection.Add%2A> hívása</xref:System.IO.Log.ReservationCollection>"
  syntax:
    content: protected void ReservationMade (long size);
    parameters:
    - id: size
      type: System.Int64
      description: "A Foglalás tett mérete."
  overload: System.IO.Log.ReservationCollection.ReservationMade*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.IO.Log.ReservationCollection
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Adja vissza, amely képes iterációt számbavevő a <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ez a módszer nem örökölhető."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "Enumerátor, amely képes iterációt az <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A művelet érvénytelen a következő okai:-a számbavétel befejeződött.      – A gyűjtemény módosult.      -A számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationCollection.#ctor
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationCollection()
  nameWithType: ReservationCollection.ReservationCollection()
  fullName: System.IO.Log.ReservationCollection.ReservationCollection()
- uid: System.IO.Log.ReservationCollection.Add(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Add(Int64)
  nameWithType: ReservationCollection.Add(Int64)
  fullName: System.IO.Log.ReservationCollection.Add(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.ReservationCollection.Clear
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Clear()
  nameWithType: ReservationCollection.Clear()
  fullName: System.IO.Log.ReservationCollection.Clear()
- uid: System.IO.Log.ReservationCollection.Contains(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Contains(Int64)
  nameWithType: ReservationCollection.Contains(Int64)
  fullName: System.IO.Log.ReservationCollection.Contains(Int64)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: CopyTo(Int64[],Int32)
  nameWithType: ReservationCollection.CopyTo(Int64[],Int32)
  fullName: System.IO.Log.ReservationCollection.CopyTo(Int64[],Int32)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.ReservationCollection.Count
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Count
  nameWithType: ReservationCollection.Count
  fullName: System.IO.Log.ReservationCollection.Count
- uid: System.IO.Log.ReservationCollection.Finalize
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Finalize()
  nameWithType: ReservationCollection.Finalize()
  fullName: System.IO.Log.ReservationCollection.Finalize()
- uid: System.IO.Log.ReservationCollection.FreeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: FreeReservation(Int64)
  nameWithType: ReservationCollection.FreeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.FreeReservation(Int64)
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetBestMatchingReservation(Int64)
  nameWithType: ReservationCollection.GetBestMatchingReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.GetBestMatchingReservation(Int64)
- uid: System.IO.Log.ReservationCollection.GetEnumerator
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetEnumerator()
  nameWithType: ReservationCollection.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.GetEnumerator()
- uid: System.Collections.Generic.IEnumerator{System.Int64}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerator<Int64>
  nameWithType: IEnumerator<Int64>
  fullName: System.Collections.Generic.IEnumerator<System.Int64>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    nameWithType: IEnumerator
    fullName: IEnumerator<System.Int64>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.ReservationCollection.IsReadOnly
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
  fullName: System.IO.Log.ReservationCollection.IsReadOnly
- uid: System.IO.Log.ReservationCollection.MakeReservation(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: MakeReservation(Int64)
  nameWithType: ReservationCollection.MakeReservation(Int64)
  fullName: System.IO.Log.ReservationCollection.MakeReservation(Int64)
- uid: System.IO.Log.ReservationCollection.Remove(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Remove(Int64)
  nameWithType: ReservationCollection.Remove(Int64)
  fullName: System.IO.Log.ReservationCollection.Remove(Int64)
- uid: System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationFreed(Int64)
  nameWithType: ReservationCollection.ReservationFreed(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationFreed(Int64)
- uid: System.IO.Log.ReservationCollection.ReservationMade(System.Int64)
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationMade(Int64)
  nameWithType: ReservationCollection.ReservationMade(Int64)
  fullName: System.IO.Log.ReservationCollection.ReservationMade(Int64)
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.IO.Log.ReservationCollection.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.IO.Log.ReservationCollection.#ctor*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection.ReservationCollection
- uid: System.IO.Log.ReservationCollection.Add*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Add
  nameWithType: ReservationCollection.Add
- uid: System.IO.Log.ReservationCollection.Clear*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Clear
  nameWithType: ReservationCollection.Clear
- uid: System.IO.Log.ReservationCollection.Contains*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Contains
  nameWithType: ReservationCollection.Contains
- uid: System.IO.Log.ReservationCollection.CopyTo*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: CopyTo
  nameWithType: ReservationCollection.CopyTo
- uid: System.IO.Log.ReservationCollection.Count*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Count
  nameWithType: ReservationCollection.Count
- uid: System.IO.Log.ReservationCollection.Finalize*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Finalize
  nameWithType: ReservationCollection.Finalize
- uid: System.IO.Log.ReservationCollection.FreeReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: FreeReservation
  nameWithType: ReservationCollection.FreeReservation
- uid: System.IO.Log.ReservationCollection.GetBestMatchingReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetBestMatchingReservation
  nameWithType: ReservationCollection.GetBestMatchingReservation
- uid: System.IO.Log.ReservationCollection.GetEnumerator*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: GetEnumerator
  nameWithType: ReservationCollection.GetEnumerator
- uid: System.IO.Log.ReservationCollection.IsReadOnly*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: IsReadOnly
  nameWithType: ReservationCollection.IsReadOnly
- uid: System.IO.Log.ReservationCollection.MakeReservation*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: MakeReservation
  nameWithType: ReservationCollection.MakeReservation
- uid: System.IO.Log.ReservationCollection.Remove*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: Remove
  nameWithType: ReservationCollection.Remove
- uid: System.IO.Log.ReservationCollection.ReservationFreed*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationFreed
  nameWithType: ReservationCollection.ReservationFreed
- uid: System.IO.Log.ReservationCollection.ReservationMade*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: ReservationMade
  nameWithType: ReservationCollection.ReservationMade
- uid: System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator*
  parent: System.IO.Log.ReservationCollection
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: ReservationCollection.System.Collections.IEnumerable.GetEnumerator
