### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "Egy rekord feladatütemezési tárolt jelöli egy <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "A LogRecordSequence osztály felett egy közös napló fájl System (Naplófájlrendszer) napló rögzítése feladatütemezési interfész megvalósítását biztosít. A szabványos rekord szolgáltatások, valamint azt a házirend modellt biztosít elkerülve az olyan napló-teljes feltételek, és az ügyfelek ugyanazon a fizikai fájlon multiplexáló. Működik együtt a <xref:System.IO.Log.LogStore>osztály, amely felületet biztosít a közvetlenül kezelésére és kezelése a CLFS naplófájl.</xref:System.IO.Log.LogStore> A következő kapcsolatot a <xref:System.IO.Log.LogStore>és a LogRecordSequence osztály hasonlít egy lemezen levő fájlra közötti kapcsolat és egy <xref:System.IO.FileStream>objektum.</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> A fájl a konkrét tárolására szolgál, és attribútumai a hossz és az utolsó hozzáférés idejének; miközben az <xref:System.IO.FileStream>objektum jeleníti meg a fájlt, amely segítségével, olvasási és írási rá.</xref:System.IO.FileStream> Hasonlóképpen a <xref:System.IO.Log.LogStore>osztály rendelkezik tulajdonságai, például egy házirendet és a lemez egységek; gyűjteménye, és a LogRecordSequence osztály lehetővé teszi a rekord célú adatok írásakor vagy olvasásakor.</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> a megadott naplótároló osztályra."
  remarks: "A puffer mérete határozza meg, hogy a rekord, amely lesz hozzáfűzve, vagy olvassa el a maximális méretét. Ez a konstruktor 64 alapértelmezett értéke van beállítva. A puffer kívánt számát értéke 10."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "A <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> , amelyet a rekord feladatütemezési kell használnia."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>érvénytelen."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> a naplótároló és a hozzáférési mód megadott elérési úttal rendelkező osztály."
  remarks: "Ez a konstruktor inicializál egy új <xref:System.IO.Log.LogRecordSequence>egy új <xref:System.IO.Log.LogStore>objektum, amely a megadott elérési út és mód nyílik.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Olvasási/írási hozzáférést kap, a tárolóba, és a tároló már meg van nyitva megosztása olvasási hozzáférést."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Egy relatív vagy abszolút elérési útját a alap fájljához a naplózási tároló megnyitása."
    - id: mode
      type: System.IO.FileMode
      description: "Egy a <xref href=&quot;System.IO.FileMode&quot;> </xref> érték, amely meghatározza, hogyan kell megnyitni vagy létrehozni a tárolót."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>üres karakterlánc (&quot;&quot;).       – vagy – <code>path</code> csak szóközt tartalmaz.       – vagy – <code>path</code> egy vagy több érvénytelen karaktereket tartalmaz."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>Érvénytelen értéket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A fájl nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba akkor fordul elő, amikor megnyitja a naplótároló."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>nem használható, mert a szükséges általános napló fájl System (Naplófájlrendszer) összetevő nincs telepítve. Telepítse a CLFS-összetevőt, ha a platform érhető el, vagy használja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> a megadott naplótároló, az egyes rekordokhoz, a puffer mérete az osztályhoz, és a puffer száma."
  remarks: "Ez a konstruktor használja, ha az értékek megadása `bufferSize` és `bufferCount` és nem szeretné, hogy az alapértelmezett értéket a 64 `bufferSize` és 10 `bufferCount`."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "A <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> , amelyet a rekord feladatütemezési kell használnia."
    - id: bufferSize
      type: System.Int32
      description: "A kívánt puffer mérete bájtban. A puffer mérete határozza meg, hogy a rekord, amely lesz hozzáfűzve, vagy olvassa el a maximális méretét."
    - id: bufferCount
      type: System.Int32
      description: "A puffer kívánt számát."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>negatív vagy nulla.       – vagy – <code>bufferCount</code> negatív vagy nulla."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> a naplótároló és a hozzáférési és megosztási módokkal megadott elérési úttal rendelkező osztály."
  remarks: "Ez a konstruktor inicializál egy új <xref:System.IO.Log.LogRecordSequence>egy új <xref:System.IO.Log.LogStore>objektum, amely a megadott elérési mód és hozzáférési nyílik.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> A tároló megosztás olvasási hozzáféréssel nyitotta meg."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Egy relatív vagy abszolút elérési útját a alap fájljához a naplózási tároló megnyitása."
    - id: mode
      type: System.IO.FileMode
      description: "Egy a <xref href=&quot;System.IO.FileMode&quot;> </xref> érték, amely meghatározza, hogyan kell megnyitni vagy létrehozni a tárolót."
    - id: access
      type: System.IO.FileAccess
      description: "Egy a <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, hogy a fájl hozzáférhet a <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>üres karakterlánc (&quot;&quot;).       – vagy – <code>path</code> csak szóközt tartalmaz.       – vagy – <code>path</code> egy vagy több érvénytelen karaktereket tartalmaz."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>Érvénytelen értéket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A fájl nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba akkor fordul elő, amikor megnyitja a naplótároló."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>nem használható, mert a szükséges általános napló fájl System (Naplófájlrendszer) összetevő nincs telepítve. Telepítse a CLFS-összetevőt, ha a platform érhető el, vagy használja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> a naplótároló és a hozzáférési mód megadott elérési úttal rendelkező osztály."
  remarks: "Ez a konstruktor inicializál egy új <xref:System.IO.Log.LogRecordSequence>egy új <xref:System.IO.Log.LogStore>objektum, amely a megadott elérési mód és hozzáférési nyílik.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> A tároló megosztás a megadott hozzáférési van megnyitva."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Egy relatív vagy abszolút elérési útját a alap fájljához a naplózási tároló megnyitása."
    - id: mode
      type: System.IO.FileMode
      description: "Egy a <xref href=&quot;System.IO.FileMode&quot;> </xref> érték, amely meghatározza, hogyan kell megnyitni vagy létrehozni a tárolót."
    - id: access
      type: System.IO.FileAccess
      description: "Egy a <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, hogy a fájl hozzáférhet a <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Egy a <xref href=&quot;System.IO.FileShare&quot;> </xref> értékeket határozza meg, hogy hogyan a Naplótároló megosztása folyamatok között."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>üres karakterlánc (&quot;&quot;).       – vagy – <code>path</code> csak szóközt tartalmaz.       – vagy – <code>path</code> egy vagy több érvénytelen karaktereket tartalmaz."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>Érvénytelen értéket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A fájl nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba akkor fordul elő, amikor megnyitja a naplótároló."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>nem használható, mert a szükséges általános napló fájl System (Naplófájlrendszer) összetevő nincs telepítve. Telepítse a CLFS-összetevőt, ha a platform érhető el, vagy használja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> osztály egy adott elérési úton a naplótároló, fájlátvitelhez, hozzáférési és megosztási módokkal, és a puffer mérete és a rekordok száma."
  remarks: "Ez a konstruktor inicializál egy új <xref:System.IO.Log.LogRecordSequence>egy új <xref:System.IO.Log.LogStore>objektum, amely a megadott elérési mód és hozzáférési nyílik.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> A tároló megosztás a megadott hozzáférési van megnyitva."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "Egy relatív vagy abszolút elérési útját a alap fájljához a naplózási tároló megnyitása."
    - id: mode
      type: System.IO.FileMode
      description: "Egy a <xref href=&quot;System.IO.FileMode&quot;> </xref> érték, amely meghatározza, hogyan kell megnyitni vagy létrehozni a tárolót."
    - id: access
      type: System.IO.FileAccess
      description: "Egy a <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, hogy a fájl hozzáférhet a <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Egy a <xref href=&quot;System.IO.FileShare&quot;> </xref> értékeket határozza meg, hogy hogyan a Naplótároló megosztása folyamatok között."
    - id: bufferSize
      type: System.Int32
      description: "A kívánt puffer mérete bájtban. A puffer mérete határozza meg, hogy a rekord, amely lesz hozzáfűzve, vagy olvassa el a maximális méretét."
    - id: bufferCount
      type: System.Int32
      description: "A puffer kívánt számát."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>üres karakterlánc (&quot;&quot;).       – vagy – <code>path</code> csak szóközt tartalmaz.       – vagy – <code>path</code> egy vagy több érvénytelen karaktereket tartalmaz."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>Érvénytelen értéket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A fájl nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba akkor fordul elő, amikor megnyitja a naplótároló."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>nem használható, mert a szükséges általános napló fájl System (Naplófájlrendszer) összetevő nincs telepítve. Telepítse a CLFS-összetevőt, ha a platform érhető el, vagy használja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> osztály."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Egy relatív vagy abszolút elérési útját a alap fájljához a naplózási tároló megnyitása."
    - id: mode
      type: System.IO.FileMode
      description: "Egy érvényes <xref href=&quot;System.IO.FileMode&quot;> </xref> érték, amely meghatározza, hogyan kell megnyitni vagy létrehozni a tárolót."
    - id: access
      type: System.IO.FileAccess
      description: "Egy érvényes <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, hogyan a naplótároló érhető el."
    - id: share
      type: System.IO.FileShare
      description: "Egy érvényes <xref href=&quot;System.IO.FileShare&quot;> </xref> érték, amely meghatározza, hogyan a Naplótároló megosztása folyamatok között."
    - id: bufferSize
      type: System.Int32
      description: "A kívánt puffer mérete bájtban. A puffer mérete határozza meg, hogy a rekord, amely lesz hozzáfűzve, vagy olvassa el a maximális méretét."
    - id: bufferCount
      type: System.Int32
      description: "A puffer kívánt számát."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Egy érvényes <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> érték, amely meghatározza a biztonsági beállítható az újonnan létrehozott tároló, ha az áruházból kell létrehozni."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A megadott fájl <code> path </code> érvénytelen.       – vagy – a megadott naplótároló fájlneve érvénytelen.       – vagy – <code> mode </code> értéke <xref href=&quot;System.IO.FileMode&quot;> </xref>, és írási hozzáférés nélkül nem használható.       – vagy – <code> mode </code> értéke <xref href=&quot;System.IO.FileMode&quot;> </xref>, és írási hozzáférés nélkül nem használható."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott fájl <code> path </code> nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a megadott fájl <code> path </code> nem érhető el, mert használatban van egy másik folyamat.       – vagy – a megadott fájl <code> path </code> nem hozható létre, mert a fájl vagy könyvtár már létezik.       – vagy – a napló leírója nem köthető a szálkészlethez.       – vagy – a megadott naplófájl formátuma vagy verziószáma érvénytelen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>nem használható, mert a szükséges általános napló fájl System (Naplófájlrendszer) összetevő nincs telepítve. Telepítse a CLFS-összetevőt, ha a platform érhető el, vagy használja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A kiinduló sorszám napló továbblép. Ez a módszer nem örökölhető."
  remarks: "Ezt a módszert gyakran használják a a <xref:System.IO.Log.LogRecordSequence.TailPinned>esemény szabadítson fel helyet a rekordban.</xref:System.IO.Log.LogRecordSequence.TailPinned> A <xref:System.IO.Log.LogRecordSequence.TailPinned>esemény azt jelzi, hogy kell-e (Ez azt jelenti, hogy az alap sorszáma) művelet a naplóvég szabadítson fel helyet a továbbítás áthelyezésének.</xref:System.IO.Log.LogRecordSequence.TailPinned> Lemezterület felszabadítása végezhető el vagy írást területek indítsa újra a <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metódus, vagy a napló levágva és a AdvanceBaseSequenceNumber metódussal ahhoz, hogy a napló alap sorszámát által megadott a `newBaseSequenceNumber` paraméter.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> A kód például szakaszában mutatja be a második megközelítés.       Vegye figyelembe, hogy a metódus hívása ugyanaz, mint egy új alap sequence számú használatának beállítása a <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metódus, azzal a különbséggel, hogy nincs újraindítás rekordot ír a naplóban.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Adja meg az új alap <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> a naplóhoz. Ez kell lennie a jelenlegi alap sorszám és az utolsó számát a napló közötti határokat is megengedve."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen.       – vagy – <code> newBaseSequenceNumber </code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A megadott napló nem rendelkezik egyetlen blokkal sem. Egy rekord rekordsorszám használata előtt létre kell hozni egy vagy több blokkot."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A napló rekordot ír a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Hozzáfűz egy naplóbejegyzést képviselnek, hogy a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.IRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A sorszám az első érvényes rekord lekérdezi az aktuális <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "Érvényes sorszámok: nagyobb vagy egyenlő BaseSequenceNumber és <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> -nál kisebb       Ez a tulajdonság értékének megváltoztatására meghívásával a <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metódus vagy <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>metódus.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A legalacsonyabb sorszám, amely érvényes rekord megfelel a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kiürítési művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>az aktuális metódus által visszaadott a <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>módszer annak biztosítására, hogy a kiürítés befejeződött, és erőforrásokat megfelelő felszabadítását.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Egy aszinkron kiürítése közben hiba lép fel, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.LogRecordSequence>tartósan íródtak.</xref:System.IO.Log.LogRecordSequence>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Aszinkron kiürítési kérés, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák hatására a kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha a <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, hogy hívható meg abban az esetben, ha a kiürítés befejeződött."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron kiürítési kérés megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron flush műveletet, amely sikerült még függőben lehet.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A megadott napló nem rendelkezik egyetlen blokkal sem. A rekordsorozat használata előtt létre kell hozni egy vagy több blokkot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron tartalék kezdődik, és a hozzáfűzendő műveletet. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron tartalék kezdődik, és a hozzáfűzendő műveletet. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>módszer annak biztosítására, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>módszer annak biztosítására, hogy az újraindítási terület írási művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensekből álló halmaz zónanevének, és hozzáfűzi a rekordként."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Érvénytelen ebben a sorozatban.       – vagy – a megadott naplószámbavétel kezdő sorszáma érvénytelen.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservation</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több paramétert <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen.       – vagy – <code> newBaseSeqNum </code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>módszer annak biztosítására, hogy az újraindítási terület írási művelet befejeződött, és erőforrások megfelelően szabadítható.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Érvénytelen ebben a sorozatban.       – vagy – a megadott naplószámbavétel kezdő sorszáma érvénytelen.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservationCollection</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több paramétert <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen.       – vagy – <code> newBaseSeqNum </code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Létrehoz egy új <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Az újonnan létrehozott <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Feloldja a vizsgált összetevő által használt erőforrások."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Befejeződik az aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>metódus.</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kiürítési művelet véget ér. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron kiürítési kérés, például a lemez i/o kérelem során során előforduló hibákat EndFlush meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Aszinkron végpontok lefoglalni, és a hozzáfűző műveletet. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndReserveAndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>metódus.</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítási terület írási művelet véget ér. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndWriteRestartArea meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>metódus.</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Írásbeli naplórekord sorszámát."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Biztosítja, hogy az összes hozzáfűzött rekord írva. Ez a módszer nem örökölhető."
  remarks: "A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.LogRecordSequence>tartósan írt.</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ez a művelet nem támogatott."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A megadott napló nem rendelkezik egyetlen blokkal sem. A rekordsorozat használata előtt létre kell hozni egy vagy több blokkot."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Biztosítja, hogy az összes hozzáfűzött rekord a rekord, a megadott sorszám bezárólag tartósan készült. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer biztosítja, hogy az összes rekordot feladatütemezési legfeljebb számok hívása és többek között a megadott sorszám tartósan készült."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha a <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A megadott napló nem rendelkezik egyetlen blokkal sem. A rekordsorozat használata előtt létre kell hozni egy vagy több blokkot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a sorszám lesz hozzáfűzve utolsó rekordját nagyobb"
  remarks: "Ez a tulajdonság tartalmazza a sorszámot, amely nagyobb, mint a sorozat száma az utolsó hozzáfűzi a rekordot. Érvényes sorszámok nagyobb vagy egyenlő <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>pedig kisebb LastSequenceNumber.</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> Minden más sorszámok érvénytelenek."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám, ez pedig nagyobb, mint az utolsó hozzáfűzött rekord."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> , amely tartalmazza az adatokat a rögzítése szekvenciához. Ez a módszer nem örökölhető."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "A <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> , amely tartalmazza az adatokat a rögzítése szekvenciához."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a rekord feladatütemezési hozzáadható rekord maximális méretét."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Egy rekordot, amely lehet hozzáadni a rekord sorozat maximális mérete."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A feladatütemezési a rekordok egy enumerálható gyűjteményhez adja vissza. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer egy rekordok enumerálható gyűjteménye a feladatütemezési adja vissza. A felsorolt rekordok függ értékének a `logRecordEnum` paraméter."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Ha a olvasási indítja el az első rekordra sorszámát."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Egy érvényes <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> érték, amely meghatározza a rekordok olvassa el a módon (vagyis előre vagy visszafelé haladva) egy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Rögzíti a sorozatban enumerálható gyűjteménye."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>Érvénytelen ebben a sorozatban.       – vagy – <code>logRecordEnum</code> érvénytelen.       – vagy – a megadott elem nem található a gyűjteményben."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt.       - vagy a naplórekord mérete nagyobb, mint az olvasásához használt puffer mérete írásához használt puffer mérete.       – vagy – a rekordsorozat sérült.       – vagy – a megadott naplófájl formátuma vagy verziószáma érvénytelen.       – vagy – a rekord a rekordsorozat nem kompatibilis verziójával készült."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A művelet érvénytelen, mert a számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A feladatütemezési egy enumerálható gyűjteményt újraindítás területek adja vissza. Ez a módszer nem örökölhető."
  remarks: "Az újraindítás területek enumerálása a feladatütemezési fordított sorrendben, ez azt jelenti, hogy az a legnagyobb sorszám a legalacsonyabb sorszámmal. Csak indítsa újra a területek sorszámmal közötti utolsó számát, és a kiinduló sorszám enumerálása."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "A feladatütemezési újraindítás területein enumerálható gyűjteménye."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt.       - vagy a naplórekord mérete nagyobb, mint az olvasásához használt puffer mérete írásához használt puffer mérete.       – vagy – a rekordsorozat sérült.       – vagy – a megadott naplófájl formátuma vagy verziószáma érvénytelen.       – vagy – a rekord a rekordsorozat nem kompatibilis verziójával készült."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A művelet érvénytelen, mert a számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>       - vagy a számbavétel befejeződött."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatikusan lehetővé teszi egyetlen foglalást, és hozzáfűzi a rekord a feladatütemezési. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>vagy <code>previousRecord</code> érvénytelen ebben a sorozatban.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservations</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatikusan lehetővé teszi egyetlen foglalást, és hozzáfűzi a rekord a feladatütemezési. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.LogRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a rekord fűznek."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új rekordot tartalmazhat, vagy ellenőrizze a foglalást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>vagy <code>previousRecord</code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a lefoglalt bájtok száma."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "A rekord sorozat összes foglalások teljes mérete."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a napló végét legközelebbi újraindítás terület sorszámát."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használja a <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>metódus, eltávolíthatja a a legutóbb írt újraindítása terület.</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A napló végét legközelebbi újraindítás terület sorszáma."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi vagy beállítja, hogy egy érték, amely azt jelzi-e hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt."
  remarks: "Ha ez a tulajdonság értéke `true`, és egy <xref:System.IO.Log.LogRecordSequence.Append%2A>hívás sikertelen lesz, mivel nincs elegendő lemezterület a sorrendben, a rekordsorozat megpróbálja szabadítson fel lemezterületet, és ismételje meg a Hozzáfűzés.</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Az utolsó rekord beállítja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "A megadott sorszám nagyobb, mint az alap sequence kell lennie.       Ez a módszer befejezését követően az összes azt jelzi, hogy nagyobb, mint a megadott sorszám sorszámmal rendelkezett korábban fűzött nem érhetők el."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Az új utolsó feladatütemezési száma a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>.       Ez a napló a jelenleg aktuális érvényes rekord utal."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen.       – vagy – <code> sequenceNumber </code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – elérte a napló végét.       – vagy – a megadott naplófájl formátuma vagy verziószáma érvénytelen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Helyezze át a művelet a naplóvég szükségességét jelzi."
  remarks: "Ezt az eseményt, amikor a rekordsorozat elfogyott a lemezterület is érvényesítést. Ez az esemény akkor következik be, amikor a végéről a sorozat (Ez azt jelenti, hogy az alap sorszáma) került előre szabadítson fel lemezterületet.       Esemény tetszőleges időpontban, amikor a rögzítése feladatütemezési úgy dönt, hogy azt kell szabadítson fel lemezterületet, bármilyen okból is indítható. Például a CLFS házirendmotor dönthetnek úgy, hogy az eseményt, amikor meghatározza, hogy, hogy ugyanazon naplófájl megosztása két naplófájl ügyfelet szél túl sokkal egymástól érvényesítést. Lemezterület felszabadítása végezhető el, vagy írása újraindítás területek, vagy a a napló levágva és a használatával a <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>metódus területet szabadítanak.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> A kód például szakaszában mutatja be a második megközelítés.       Ön is meghívhatja a <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>metódus szabadítson fel lemezterületet a TailPinned esemény kívül.</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> Egy újraindítás terület hasonlít más rendszerek naplóban egy ellenőrzőpontot. A metódus hívása azt jelzi, hogy az alkalmazás úgy ítéli meg, az összes előzetes rekord előtt a újraindítás területet, a teljes befejeződött, és a jövőbeli rekord használható hozzáfűzi. Bármely más rekordokat hasonló, az ezzel a módszerrel írt rekord tényleges szabad terület szükséges az függvény a naplóban."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Egy tömb szegmens, amely összefűzendő, és hozzáfűzi a rekordként."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> , és frissíti a alap sorszám. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> , és frissíti a alap sorszám. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> foglalás használ, és frissíti a alap sorozatszámot. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az újraindítás területen írása közben."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat nem sikerült elég szabad hely az új újraindítás területet tartalmaz."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> foglalás használ, és frissíti a alap sorozatszámot. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Érvénytelen ebben a sorozatban.       – vagy – a megadott naplószámbavétel kezdő sorszáma érvénytelen.       – vagy – <code>data</code> nem lehet csatolni, mert a mérete meghaladja a maximális rekordméretet.       – vagy – <code>reservationCollection</code> a rekord feladatütemezési nem hozta létre."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több paramétert <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen.       – vagy – <code> newBaseSeqNum </code> nem ebben a sorozatban és utolsó sorszámok között van."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el.       – vagy – a kérelem nem hajtható végre, eszköz i/o-hiba miatt."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadja a hozzáférést a megadott naplókönyvtár feladatsort."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
