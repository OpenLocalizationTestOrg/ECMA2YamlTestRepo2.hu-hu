### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.TcpListener
  id: TcpListener
  children:
  - System.Net.Sockets.TcpListener.#ctor(System.Int32)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpListener.AcceptSocket
  - System.Net.Sockets.TcpListener.AcceptSocketAsync
  - System.Net.Sockets.TcpListener.AcceptTcpClient
  - System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  - System.Net.Sockets.TcpListener.Active
  - System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  - System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.Create(System.Int32)
  - System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.ExclusiveAddressUse
  - System.Net.Sockets.TcpListener.LocalEndpoint
  - System.Net.Sockets.TcpListener.Pending
  - System.Net.Sockets.TcpListener.Server
  - System.Net.Sockets.TcpListener.Start
  - System.Net.Sockets.TcpListener.Start(System.Int32)
  - System.Net.Sockets.TcpListener.Stop
  langs:
  - csharp
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
  type: Class
  summary: "Figyeli a TCP hálózati ügyfelektől érkező kapcsolatokat."
  remarks: "A TcpListener osztály figyelését, és amelyek fogadják szinkron módban blokkolja a bejövő csatlakozási kérések egyszerű módszert biztosít. Választhat egy <xref:System.Net.Sockets.TcpClient>vagy egy <xref:System.Net.Sockets.Socket>a TcpListener kapcsolódni.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpClient> Hozzon létre egy TcpListener használatával egy <xref:System.Net.IPEndPoint>, a helyi IP-cím és port számát, vagy egy portszámot.</xref:System.Net.IPEndPoint> Adja meg <xref:System.Net.IPAddress.Any>a helyi IP-cím és a helyi port számát, ha azt szeretné, hogy az alapul szolgáló szolgáltató rendelhető hozzá ezeket az értékeket, a 0.</xref:System.Net.IPAddress.Any> Ha ezt választja, akkor használhatja a <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>határozza meg a társított adatokat, miután csatlakozott a szoftvercsatorna-tulajdonság.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Használja a <xref:System.Net.Sockets.TcpListener.Start%2A>módszert bejövő csatlakozási kérések figyelését.</xref:System.Net.Sockets.TcpListener.Start%2A> <xref:System.Net.Sockets.TcpListener.Start%2A>várólista bejövő kapcsolatokat, amíg ki nem vagy hívni fogja a <xref:System.Net.Sockets.TcpListener.Stop%2A>módszert, vagy rendelkezik várólistára <xref:System.Net.Sockets.SocketOptionName>.</xref:System.Net.Sockets.SocketOptionName> </xref:System.Net.Sockets.TcpListener.Stop%2A></xref:System.Net.Sockets.TcpListener.Start%2A> Mindkét <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>vagy <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>való lekérésére egy kapcsolat a bejövő kapcsolódási kérelmet várólistából.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Ez a két módszer blokkolja. Ha szeretné elkerülni, használhatja a <xref:System.Net.Sockets.TcpListener.Pending%2A>módszert először határozza meg, ha csatlakozási kérések elérhetők-e a várólista.</xref:System.Net.Sockets.TcpListener.Pending%2A>       Hívja a <xref:System.Net.Sockets.TcpListener.Stop%2A>Zárja be a TcpListener metódust.</xref:System.Net.Sockets.TcpListener.Stop%2A>      > [!NOTE] > A <xref:System.Net.Sockets.TcpListener.Stop%2A>metódus nem zárja be a elfogadott kapcsolatokat.</xref:System.Net.Sockets.TcpListener.Stop%2A> Ön felelősséggel tartozik záró ezek külön-külön."
  example:
  - "The following code example creates a TcpListener.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/t-system.net.sockets.tcp_0_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/t-system.net.sockets.tcp_0_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/t-system.net.sockets.tcp_0_1.vb)]  \n  \n See <xref:System.Net.Sockets.TcpClient> for a client example."
  syntax:
    content: public class TcpListener
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> osztály, amely a megadott porton figyel."
  remarks: "Ez a konstruktor már elavult. Használja a <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>vagy <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName>konstruktorok.</xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName> </xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>       Ez a konstruktor lehetővé teszi, hogy adja meg a portot a bejövő kapcsolódási kísérletek figyelésre. Ezzel a konstruktorral az az alapul szolgáló szolgáltató a legmegfelelőbb hálózati címet rendel hozzá. Ha nem fontos, mely helyi port használatban van, megadhatja a portszám 0. Ebben az esetben a szolgáltató hozzárendel egy elérhető portszámot 1024 és 5000 között. Ha ezt a módszert használja, mely helyi hálózati cím és port számát a rendelték felderítené a <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>tulajdonság.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Hívja a <xref:System.Net.Sockets.TcpListener.Start%2A>módszert bejövő kapcsolódási kísérletek figyelését.</xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.TcpListener> using a local port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_18_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_18_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_18_1.vb)]"
  syntax:
    content: public TcpListener (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "A port, bejövő kapcsolódási kísérletek a figyelésre."
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>nincs a következők között <xref:System.Net.IPEndPoint.MinPort> és <xref:System.Net.IPEndPoint.MaxPort>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> osztály a megadott helyi végponttal."
  remarks: "Ez a konstruktor lehetővé teszi a helyi IP-cím és port számát a bejövő kapcsolatok figyelésre kísérletek. Ez a konstruktor használatához létre kell hoznia egy <xref:System.Net.IPEndPoint>használatával kívánt helyi IP-cím és port számát.</xref:System.Net.IPEndPoint> Ez átadni <xref:System.Net.IPEndPoint>a konstruktornak, mint a `localEP` paraméter.</xref:System.Net.IPEndPoint>       Ha nem fontos, mely helyi cím hozzá van rendelve, akkor létrehozhat egy <xref:System.Net.IPEndPoint>használatával <xref:System.Net.IPAddress.Any?displayProperty=fullName>a cím paraméter, és a mögöttes szolgáltatás szolgáltató rendeli a legmegfelelőbb hálózati cím.</xref:System.Net.IPAddress.Any?displayProperty=fullName> </xref:System.Net.IPEndPoint> Ez segíthet az alkalmazás leegyszerűsítheti, ha több hálózati adapterrel rendelkezik. Ha nem fontos, mely helyi port használatban van, akkor létrehozhat egy <xref:System.Net.IPEndPoint>0 portszámot használja.</xref:System.Net.IPEndPoint> Ebben az esetben a szolgáltató hozzárendel egy elérhető portszámot 1024 és 5000 között. Ha ezt a módszert használja, mely helyi hálózati cím és port számát a rendelték felderítené a <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>tulajdonság.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Hívja a <xref:System.Net.Sockets.TcpListener.Start%2A>módszert bejövő kapcsolódási kísérletek figyelését.</xref:System.Net.Sockets.TcpListener.Start%2A>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using the local endpoint.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_20_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_20_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_20_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPEndPoint localEP);
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "Egy <xref:System.Net.IPEndPoint>, a helyi végpont, amelyhez a figyelő <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> jelöli</xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localEP</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  id: '#ctor(System.Net.IPAddress,System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> osztály, amely figyeli a bejövő kapcsolódási kísérletek megadott helyi IP-cím és port számát."
  remarks: "Ez a konstruktor lehetővé teszi a helyi IP-cím és port számát a bejövő kapcsolatok figyelésre kísérletek. Ez a konstruktor meghívása előtt létre kell hoznia egy <xref:System.Net.IPAddress>a kívánt helyi cím segítségével.</xref:System.Net.IPAddress> Ez átadni <xref:System.Net.IPAddress>a konstruktornak, mint a `localaddr` paraméter.</xref:System.Net.IPAddress> Ha az nem fontos, mely helyi cím hozzá van rendelve, adja meg <xref:System.Net.IPAddress.Any?displayProperty=fullName>a a `localaddr` paraméter, és az alapul szolgáló szolgáltató rendeli a legmegfelelőbb hálózati cím.</xref:System.Net.IPAddress.Any?displayProperty=fullName> Ez segíthet az alkalmazás leegyszerűsítheti, ha több hálózati adapterrel rendelkezik. Ha nem fontos, mely helyi port használatban van, megadhatja a portszám 0. Ebben az esetben a szolgáltató hozzárendel egy elérhető portszámot 1024 és 5000 között. Ha ezt a módszert használja, mely helyi hálózati cím és port számát a rendelték felderítené a <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>tulajdonság.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Hívja a <xref:System.Net.Sockets.TcpListener.Start%2A>módszert bejövő kapcsolódási kísérletek figyelését.</xref:System.Net.Sockets.TcpListener.Start%2A>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using a local IP address and port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/cpp/m-system.net.sockets.tcp_19_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/csharp/m-system.net.sockets.tcp_19_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_19_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPAddress localaddr, int port);
    parameters:
    - id: localaddr
      type: System.Net.IPAddress
      description: "Egy <xref:System.Net.IPAddress>, amely a helyi IP-címet jelenti.</xref:System.Net.IPAddress>"
    - id: port
      type: System.Int32
      description: "A port, bejövő kapcsolódási kísérletek a figyelésre."
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localaddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>nincs a következők között <xref:System.Net.IPEndPoint.MinPort> és <xref:System.Net.IPEndPoint.MaxPort>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  id: AcceptSocket
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "A függőben lévő kapcsolódási kérelmet fogad el."
  remarks: "AcceptSocket a blokkolási módszer adja vissza egy <xref:System.Net.Sockets.Socket>, hogy segítségével adatokat küldeni és fogadni.</xref:System.Net.Sockets.Socket> Ha szeretné elkerülni, használja a <xref:System.Net.Sockets.TcpListener.Pending%2A>módszer annak meghatározására, hogy ha csatlakozási kérések érhető el a bejövő kapcsolat várólistáján.</xref:System.Net.Sockets.TcpListener.Pending%2A>       A <xref:System.Net.Sockets.Socket>visszaadott inicializálva van a távoli állomás IP-cím és port száma.</xref:System.Net.Sockets.Socket> Bármelyikét használhatja a <xref:System.Net.Sockets.Socket.Send%2A>és <xref:System.Net.Sockets.Socket.Receive%2A>elérhető módszerek a <xref:System.Net.Sockets.Socket>osztály a távoli gazdagéppel folytatott kommunikációhoz.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> Ha készen használatával a <xref:System.Net.Sockets.Socket>, ügyeljen arra, hogy a hívás a <xref:System.Net.Sockets.Socket.Close%2A>metódus.</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> Ha az alkalmazás viszonylag egyszerű, érdemes lehet használni a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>helyett a AcceptSocket metódus.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>biztosít az egyszerű adatot küldeni és fogadni szinkron módban blokkolja a hálózaton keresztül.</xref:System.Net.Sockets.TcpClient>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "In the following code example, the AcceptSocket method is used to return a <xref:System.Net.Sockets.Socket>. This <xref:System.Net.Sockets.Socket> is used to communicate with the newly connected client.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_7_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_7_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_7_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket AcceptSocket ();
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>használt adatokat küldeni és fogadni.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocket*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A figyelő nem indult el <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*> hívása"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  id: AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy aszinkron művelet egy függőben lévő kapcsolódási kérelmet fogad el."
  remarks: "Ez a művelet nem fogja tiltani. A visszaadott <xref:System.Threading.Tasks.Task%601>objektum befejezi a szoftvercsatorna-kapcsolat elfogadását követően.</xref:System.Threading.Tasks.Task%601>       A <xref:System.Net.Sockets.Socket>által visszaadott <xref:System.Threading.Tasks.Task%601>inicializálva van a távoli állomás IP-cím és port száma.</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.Socket> Bármelyikét használhatja a <xref:System.Net.Sockets.Socket.Send%2A>és <xref:System.Net.Sockets.Socket.Receive%2A>elérhető módszerek a <xref:System.Net.Sockets.Socket>osztály a távoli gazdagéppel folytatott kommunikációhoz.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> Ha készen használatával a <xref:System.Net.Sockets.Socket>, ügyeljen arra, hogy a hívás a <xref:System.Net.Sockets.Socket.Close%2A>metódus.</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> Ha az alkalmazás viszonylag egyszerű, érdemes lehet használni a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>helyett a AcceptSocketAsync metódus.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>biztosít az egyszerű adatot küldeni és fogadni szinkron módban blokkolja a hálózaton keresztül.</xref:System.Net.Sockets.TcpClient>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptSocketAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
      description: "Beolvasása &lt;xref:System.Threading.Tasks.Task%601&gt; az aszinkron művelet képviselő feladat objektum. A &lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt; feladat objektum tulajdonságának adja vissza egy <xref:System.Net.Sockets.Socket>használt adatokat küldeni és fogadni.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A figyelő nem indult el <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*> hívása"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  id: AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "A függőben lévő kapcsolódási kérelmet fogad el."
  remarks: "AcceptTcpClient a blokkolási módszer adja vissza egy <xref:System.Net.Sockets.TcpClient>, hogy segítségével adatokat küldeni és fogadni.</xref:System.Net.Sockets.TcpClient> Használja a <xref:System.Net.Sockets.TcpListener.Pending%2A>módszerrel határozható meg, ha csatlakozási kérések érhetők el a bejövő kapcsolat várólista Ha azt szeretné elkerülni.</xref:System.Net.Sockets.TcpListener.Pending%2A>       A <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>módszer az alapul szolgáló <xref:System.Net.Sockets.NetworkStream>a visszaadott <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> az</xref:System.Net.Sockets.NetworkStream> beszerzése</xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> A <xref:System.Net.Sockets.NetworkStream>biztosítja azokat a módszerekkel történő küldésére és fogadására a távoli állomással.</xref:System.Net.Sockets.NetworkStream> Amikor áll keresztül a a <xref:System.Net.Sockets.TcpClient>, ügyeljen arra, hogy a hívás a <xref:System.Net.Sockets.TcpClient.Close%2A>metódus.</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> Ha azt szeretné, hogy nagyobb rugalmasságot <xref:System.Net.Sockets.TcpClient>nyújt, érdemes lehet <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient> mint      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "In the following code example, the AcceptTcpClient method is used to return a <xref:System.Net.Sockets.TcpClient>. This <xref:System.Net.Sockets.TcpClient> is used to communicate with the newly connected client.  \n  \n [!code-cs[Classic TcpListenerExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_15_1.cs)]\n [!code-cpp[Classic TcpListenerExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_15_1.cpp)]\n [!code-vb[Classic TcpListenerExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_15_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient AcceptTcpClient ();
    parameters: []
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> használt adatokat küldeni és fogadni."
  overload: System.Net.Sockets.TcpListener.AcceptTcpClient*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A figyelő nem indult el <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*> hívása"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Használja a &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; tulajdonságnak a konkrét hibakód megtekinthető. Ez a kód szerezte be, amikor a Windows Sockets 2-es verziójú API hiba dokumentációja az MSDN-en a hiba részletes leírását is hivatkozunk."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  id: AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy aszinkron művelet egy függőben lévő kapcsolódási kérelmet fogad el."
  remarks: "Ez a művelet nem fogja tiltani. A visszaadott <xref:System.Threading.Tasks.Task%601>objektum befejeződik, az TCP-kapcsolat elfogadását követően.</xref:System.Threading.Tasks.Task%601>       A <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>módszer az alapul szolgáló <xref:System.Net.Sockets.NetworkStream>, a visszaadott <xref:System.Net.Sockets.TcpClient>a <xref:System.Threading.Tasks.Task%601>.</xref:System.Threading.Tasks.Task%601> az</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> beszerzése</xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> A <xref:System.Net.Sockets.NetworkStream>biztosítja azokat a módszerekkel történő küldésére és fogadására a távoli állomással.</xref:System.Net.Sockets.NetworkStream> Amikor áll keresztül a a <xref:System.Net.Sockets.TcpClient>, ügyeljen arra, hogy a hívás a <xref:System.Net.Sockets.TcpClient.Close%2A>metódus.</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> Ha azt szeretné, hogy nagyobb rugalmasságot <xref:System.Net.Sockets.TcpClient>nyújt, érdemes lehet <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>vagy <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient> mint      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.TcpClient> AcceptTcpClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
      description: "Beolvasása &lt;xref:System.Threading.Tasks.Task%601&gt; az aszinkron művelet képviselő feladat objektum. A &lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt; feladat objektum tulajdonságának adja vissza egy <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> használt adatokat küldeni és fogadni."
  overload: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A figyelő nem indult el <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*> hívása"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Használja a &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; tulajdonságnak a konkrét hibakód megtekinthető. Ez a kód szerezte be, amikor a Windows Sockets 2-es verziójú API hiba dokumentációja az MSDN-en a hiba részletes leírását is hivatkozunk."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Active
  id: Active
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lekérdezi egy érték, amely azt jelzi, hogy <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> aktívan figyeli a ügyfélkapcsolatokat."
  remarks: "A származtatott osztályainak <xref:System.Net.Sockets.TcpListener>e tulajdonság segítségével határozza meg, hogy a <xref:System.Net.Sockets.Socket>jelenleg figyeli a bejövő kapcsolódási kísérletek.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> A <xref:System.Net.Sockets.TcpClient.Active%2A>tulajdonság elkerülése érdekében redundáns használható <xref:System.Net.Sockets.TcpListener.Start%2A>megpróbál.</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpClient.Active%2A>"
  syntax:
    content: protected bool Active { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> aktívan figyelő; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.TcpListener.Active*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  id: AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Engedélyezheti vagy letilthatja a hálózati címfordítás (NAT) átjárás a egy <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> példány."
  remarks: "A AllowNatTraversal módszert engedélyezheti vagy tilthatja le a NAT-átvitel egy <xref:System.Net.Sockets.TcpListener>példány.</xref:System.Net.Sockets.TcpListener> NAT-átvitel is megadható a Teredo, 6to4 vagy az ISATAP-alagút használatával.       Ha a `allowed` paraméter értéke false, <xref:System.Net.Sockets.SocketOptionName>a társított szoftvercsatornán beállítás <xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> Ez a NAT-átvitel explicit módon letiltja a <xref:System.Net.Sockets.TcpListener>példány.</xref:System.Net.Sockets.TcpListener>       Ha a `allowed` paraméter értéke igaz, <xref:System.Net.Sockets.SocketOptionName>a társított szoftvercsatornán beállítás <xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> Ez a NAT-átvitel tehetik lehetővé a <xref:System.Net.Sockets.TcpListener>attól függően, hogy a helyen, a rendszer a tűzfalszabályok.</xref:System.Net.Sockets.TcpListener>       A AllowNatTraversal metódus hívása előtt kell meghívni a <xref:System.Net.Sockets.TcpListener.Start%2A>metódust (előtt a szoftvercsatorna kötött) bejövő csatlakozási kérések figyelését.</xref:System.Net.Sockets.TcpListener.Start%2A> Ha AllowNatTraversal módszer neve után a <xref:System.Net.Sockets.TcpListener.Start%2A>módszer, majd egy <xref:System.InvalidOperationException>fog jelezni.</xref:System.InvalidOperationException> </xref:System.Net.Sockets.TcpListener.Start%2A>       A Teredo-címeknek az IPv6-címet a előtaggal 2001:: / 32. Teredo-címek vissza normál DNS-névfeloldás keresztül, vagy egy helyi interfészhez rendelt IPv6-címként számba."
  syntax:
    content: public void AllowNatTraversal (bool allowed);
    parameters:
    - id: allowed
      type: System.Boolean
      description: "Egy logikai érték, amely megadja, hogy engedélyezi vagy letiltja a NAT-átvitel."
  overload: System.Net.Sockets.TcpListener.AllowNatTraversal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A AllowNatTraversal metódus lett meghívva a <xref:System.Net.Sockets.TcpListener.Start*>metódus</xref:System.Net.Sockets.TcpListener.Start*> hívása után"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  id: BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy aszinkron művelet bejövő kapcsolat megkísérelni kezdődik."
  remarks: "Hívja a BeginAcceptSocket aszinkron műveletet kell végrehajtania a <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> A metódus által indított általában a `callback` delegálni.       Ez a módszer nem blokkolja a művelet befejezéséig. Csak a művelet befejeződése után letilthatja, használja a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>       Az aszinkron programozási modell használatával kapcsolatos részletes információkért lásd: [hívása szinkron módszerek aszinkron módon](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Hívása a <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>tulajdonság a visszaadott <xref:System.Net.Sockets.Socket>a távoli állomás hálózati cím és port számának azonosításához.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > Ha megjelenik egy <xref:System.Net.Sockets.SocketException>, használja a <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>tulajdonság beszerzése a konkrét hibakód megtekinthető, és a Windows Sockets 2-es verziójú API hiba kód dokumentációjában az MSDN-könyvtárban, [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) a hiba részletes leírását.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the BeginAcceptSocket method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/1d0c3046-b366-41a2-aab6-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/1d0c3046-b366-41a2-aab6-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/1d0c3046-b366-41a2-aab6-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "Egy <xref:System.AsyncCallback>delegált esetén, amely a művelet befejezésekor a meghívni kívánt metódus hivatkozik.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Olyan felhasználói objektum elfogadás működésével kapcsolatos adatokat tartalmazó. Ez az objektum átadott a `callback` delegálása, ha a művelet befejeződött."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely hivatkozik a <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> aszinkron létrehozása</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Hiba történt a szoftvercsatorna elérésére tett kísérlet során. További információt a Megjegyzések című szakaszában talál."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A <xref:System.Net.Sockets.Socket>be lett zárva.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  id: BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Egy aszinkron művelet bejövő kapcsolat megkísérelni kezdődik."
  remarks: "Hívja a BeginAcceptTcpClient aszinkron műveletet kell végrehajtania a <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>metódus.</xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> A metódus által indított általában a `callback` delegálni.       Ez a módszer nem blokkolja a művelet befejezéséig. Csak a művelet befejeződése után letilthatja, használja a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>       Az aszinkron programozási modell használatával kapcsolatos részletes információkért lásd: [hívása szinkron módszerek aszinkron módon](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Ha megjelenik egy <xref:System.Net.Sockets.SocketException>, használja a <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>tulajdonság beszerzése a konkrét hibakód megtekinthető, és a Windows Sockets 2-es verziójú API hiba kód dokumentációjában az MSDN-könyvtárban, [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) a hiba részletes leírását.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the BeginAcceptTcpClient method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/5290dfb8-7e8f-4cf6-b64e-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/5290dfb8-7e8f-4cf6-b64e-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/5290dfb8-7e8f-4cf6-b64e-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "Egy <xref:System.AsyncCallback>delegált esetén, amely a művelet befejezésekor a meghívni kívánt metódus hivatkozik.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Olyan felhasználói objektum elfogadás működésével kapcsolatos adatokat tartalmazó. Ez az objektum átadott a `callback` delegálása, ha a művelet befejeződött."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>aszinkron létrehozásának hivatkozik, amely a <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Hiba történt a szoftvercsatorna elérésére tett kísérlet során. További információt a Megjegyzések című szakaszában talál."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A <xref:System.Net.Sockets.Socket>be lett zárva.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  id: Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Létrehoz egy új <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> példány a megadott porton figyeljen."
  syntax:
    content: public static System.Net.Sockets.TcpListener Create (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "A port, bejövő kapcsolódási kísérletek a figyelésre."
    return:
      type: System.Net.Sockets.TcpListener
      description: "Returns <xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>.       Egy új <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> példány a megadott porton figyeljen."
  overload: System.Net.Sockets.TcpListener.Create*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  id: EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Aszinkron módon fogad egy bejövő kapcsolódási kísérlet, és létrehoz egy új <xref:System.Net.Sockets.Socket>távoli állomás kommunikáció kezelésére.</xref:System.Net.Sockets.Socket>"
  remarks: "A metódus blokkok addig, amíg a művelet nem végezze el. Ez a művelet szinkron módon végrehajtásához használja a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>      > [!NOTE] > Hívása a <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>tulajdonság a visszaadott <xref:System.Net.Sockets.Socket>a távoli állomás hálózati cím és port számának azonosításához.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > Ha megjelenik egy <xref:System.Net.Sockets.SocketException>, használja a <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>tulajdonság beszerzése a konkrét hibakód megtekinthető, és a Windows Sockets 2-es verziójú API hiba kód dokumentációjában az MSDN-könyvtárban, [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) a hiba részletes leírását.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> method to create and connect a socket. The callback delegate calls the EndAcceptSocket method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_14_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_14_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_14_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>hívás által visszaadott a <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>metódus.</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>       A <xref:System.Net.Sockets.Socket>használt adatokat küldeni és fogadni.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.EndAcceptSocket*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az alapul szolgáló <xref:System.Net.Sockets.Socket>be lett zárva.</xref:System.Net.Sockets.Socket>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <code> asyncResult </code> paraméter nem a hívásával jött létre a <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>metódus.</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A EndAcceptSocket metódus korábban lett meghívva."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Hiba történt a <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> elérésére tett kísérlet során További információt a Megjegyzések című szakaszában talál."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  id: EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Aszinkron módon fogad egy bejövő kapcsolódási kísérlet, és létrehoz egy új <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> távoli állomás kommunikáció kezelésére."
  remarks: "A metódus blokkok addig, amíg a művelet nem végezze el. Ez a művelet szinkron módon végrehajtásához használja a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>      > [!NOTE] > Hívása a <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>tulajdonság az alapul szolgáló szoftvercsatorna (<xref:System.Net.Sockets.TcpClient.Client%2A>) azonosítására a távoli állomás hálózati cím és port számát.</xref:System.Net.Sockets.TcpClient.Client%2A> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > Ha megjelenik egy <xref:System.Net.Sockets.SocketException>, használja a <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>tulajdonság beszerzése a konkrét hibakód megtekinthető, és a Windows Sockets 2-es verziójú API hiba kód dokumentációjában az MSDN-könyvtárban, [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) a hiba részletes leírását.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> method to create and connect a socket. The callback delegate calls the EndAcceptTcpClient method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/m-system.net.sockets.tcp_8_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/m-system.net.sockets.tcp_8_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_8_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>hívás által visszaadott a <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*>metódus.</xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>.       A <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> használt adatokat küldeni és fogadni."
  overload: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lekérdezi vagy beállítja a <xref:System.Boolean>érték, amely megadja, hogy a <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> lehetővé teszi, hogy a megadott port figyelésére csak egy alapul szolgáló szoftvercsatorna</xref:System.Boolean>"
  remarks: "Alapértelmezés szerint több figyelők egy adott port figyelésére is. A figyelők csak az egyik azonban hajthat végre műveleteket a hálózati forgalmat a portra küldi. Ha egynél több figyelő megkísérli egy adott porthoz, pontosabban meghatározott IP-címét egy adott port a hálózati forgalmat kezeli. A <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>tulajdonság az adott porton figyel több figyelői megelőzése</xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>       Ez a tulajdonság hívása előtt állítsa <xref:System.Net.Sockets.TcpListener.Start%2A>, vagy hívja a <xref:System.Net.Sockets.TcpListener.Stop%2A>módszer, majd állítsa be ezt a tulajdonságot.</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example gets and sets the ExclusiveAddressUse property.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/cpp/p-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/csharp/p-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> lehetővé teszi, hogy csak az egyik <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> figyelésére egy adott portot; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. . Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Windows Server 2003 és Windows XP Service Pack 2 és újabb verziók, és <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> egyéb verziói esetén."
  overload: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> el lett indítva. Hívja a <xref href=&quot;System.Net.Sockets.TcpListener.Stop&quot;> </xref> metódus és majd állítsa be a <xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>tulajdonság.</xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Hiba történt az alapul szolgáló szoftvercsatorna eléréséhez."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az alapul szolgáló <xref:System.Net.Sockets.Socket>be lett zárva.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  id: LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lekérdezi az alapul szolgáló <xref:System.Net.EndPoint>az aktuális <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>.</xref:System.Net.EndPoint>"
  remarks: "A LocalEndpoint tulajdonság segítségével azonosíthatja a használt ügyfél csatlakozási kérelmeket, a figyelésére, miután egy szoftvercsatorna-kapcsolat létrejött helyi hálózati felület és a port számát. Először a <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint>.</xref:System.Net.IPEndPoint> </xref:System.Net.EndPoint> kell alakítania Majd hívása a <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>tulajdonság a helyi IP-cím beolvasása és a <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName>tulajdonság beolvasása a helyi portszámmal.</xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> </xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>"
  example:
  - "The following code example displays the local IP address and port number on which the <xref:System.Net.Sockets.TcpListener> is listening for incoming connection requests.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/p-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public System.Net.EndPoint LocalEndpoint { get; }
    return:
      type: System.Net.EndPoint
      description: "A <xref:System.Net.EndPoint>, amelyhez a <xref:System.Net.Sockets.Socket>van kötve.</xref:System.Net.Sockets.Socket> </xref:System.Net.EndPoint>"
  overload: System.Net.Sockets.TcpListener.LocalEndpoint*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Pending
  id: Pending
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Azt határozza meg, ha nincsenek függő csatlakozási kérelmek."
  remarks: "Ez a módszer nem blokkoló meghatározza, hogy vannak-e a függőben lévő kapcsolat kéréseit. Mert a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>és <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>módszerek blokkolása végrehajtás, amíg a <xref:System.Net.Sockets.TcpListener.Start%2A>metódus egy bejövő kapcsolódási kérelmet rendelkezik várólistára, a függőben lévő módszer akkor használható, ha kapcsolatok elérhető meghatározásához fogadja el a feltételeket megkísérlése előtt.</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>"
  example:
  - "The following code example checks the Pending method. If a connection request is waiting to be accepted, then a call to the <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> method is made.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public bool Pending ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a kapcsolatok várakoznak; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.TcpListener.Pending*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A figyelő nem indult el <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*> hívása"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Server
  id: Server
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lekérdezi a mögöttes hálózati <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.TcpListener>létrehoz egy <xref:System.Net.Sockets.Socket>figyelni a bejövő ügyfélkérelmeket kapcsolat.</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.TcpListener> Osztályok származó <xref:System.Net.Sockets.TcpListener>használhatja ezt a tulajdonságot a <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> beolvasása</xref:System.Net.Sockets.TcpListener> Használja az alapul szolgáló <xref:System.Net.Sockets.Socket>a kiszolgáló tulajdonsága által visszaadott, ha túl hozzáférést amely <xref:System.Net.Sockets.TcpListener>biztosít.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.Socket>      > [!NOTE] > A kiszolgáló következő tulajdonsága csak adja vissza a <xref:System.Net.Sockets.Socket>figyelni a bejövő ügyfélkérelmeket kapcsolat használatával.</xref:System.Net.Sockets.Socket> Használja a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>módszert, fogadja el a függőben lévő kapcsolódási kérelmet, és szerezze be a <xref:System.Net.Sockets.Socket>vonatkozó adatot küldeni és fogadni.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Is használhatja a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>módszert, fogadja el a függőben lévő kapcsolódási kérelmet, és szerezze be a <xref:System.Net.Sockets.TcpClient>vonatkozó adatot küldeni és fogadni.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>"
  example:
  - "The following code example demonstrates the use of the Server property. The underlying <xref:System.Net.Sockets.Socket> is retrieved and the <xref:System.Net.Sockets.SocketOptionName><xref:System.Net.Sockets.Socket> option is configured to time out after 10 seconds if data still remains in the network buffer after the connection is closed.  \n  \n [!code-vb[TcpListenerProtectedMembers1#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_10_1.vb)]\n [!code-cs[TcpListenerProtectedMembers1#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_10_1.cs)]"
  syntax:
    content: public System.Net.Sockets.Socket Server { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "Az alapul szolgáló <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start
  id: Start
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Elindítja a bejövő kapcsolódási kérések figyelését."
  remarks: "A Start metódus inicializálja az alapul szolgáló <xref:System.Net.Sockets.Socket>köti azt a helyi végpont és figyeli a bejövő kapcsolódási kísérletek.</xref:System.Net.Sockets.Socket> Ha a kapcsolódási kérelem érkezik, a Start metódus a kérelem várólistára helyezése és továbbra is figyeli a további kérelmeket, amíg meg nem hívja a <xref:System.Net.Sockets.TcpListener.Stop%2A>metódus.</xref:System.Net.Sockets.TcpListener.Stop%2A> Ha <xref:System.Net.Sockets.TcpListener>a kapcsolódási kérelem fogadása után azt a rendelkezik már sorban áll kapcsolatok maximális számát, azt kivételhibát egy <xref:System.Net.Sockets.SocketException>az ügyfélen.</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       A bejövő kapcsolat várólistából távolítható el a kapcsolatot, a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódust vagy a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> A <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódus lesz kapcsolat eltávolítása a sorból, és térjen vissza a <xref:System.Net.Sockets.TcpClient>, hogy segítségével adatokat küldeni és fogadni.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> A <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus visszatér a <xref:System.Net.Sockets.Socket>használható ugyanerre.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Ha az alkalmazás csak a szinkron i/o, használja a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> További részletes viselkedési vezérlő használja a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Mindkét módszer blokkolása mindaddig, amíg a várólista érhető el a kapcsolódási kérelmet.       Használja a <xref:System.Net.Sockets.TcpListener.Stop%2A>metódus bezárásához a <xref:System.Net.Sockets.TcpListener>és a figyelést.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> Ön felelősséggel tartozik a elfogadott kapcsolatok bezárásával külön-külön.      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how Start is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_6_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_6_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_6_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Használja a &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; tulajdonságnak a konkrét hibakód megtekinthető. Ez a kód szerezte be, amikor a Windows Sockets 2-es verziójú API hiba dokumentációja az MSDN-en a hiba részletes leírását is hivatkozunk."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  id: Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Elindítja a figyelést a csatlakozási kérelmeket a függőben lévő kapcsolat maximális számát."
  remarks: "A <xref:System.Net.Sockets.TcpListener.Start%2A>metódus inicializálja az alapul szolgáló <xref:System.Net.Sockets.Socket>köti azt a helyi végpont és figyeli a bejövő kapcsolódási kísérletek.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.Start%2A> Ha a kapcsolódási kérelem érkezik, <xref:System.Net.Sockets.TcpListener.Start%2A>fogja a kérelem várólistára helyezése, és továbbra is figyeli a további kérelmeket, amíg meg nem hívja a <xref:System.Net.Sockets.TcpListener.Stop%2A>metódus.</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A> Ha <xref:System.Net.Sockets.TcpListener>csatlakozási kérést kap, miután azt rendelkezik már sorban áll azt kivételhibát kapcsolatok maximális számát egy <xref:System.Net.Sockets.SocketException>az ügyfélen.</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       A bejövő kapcsolat várólistából távolítható el a kapcsolatot, a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódust vagy a <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> A <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>metódus lesz kapcsolat eltávolítása a sorból, és térjen vissza a <xref:System.Net.Sockets.TcpClient>, hogy segítségével adatokat küldeni és fogadni.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> A <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus visszatér a <xref:System.Net.Sockets.Socket>használható ugyanerre.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Ha az alkalmazás csak a szinkron i/o, használja a <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Részletes viselkedési vezérlő, használjon <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>metódus.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Mindkét módszer blokkolása mindaddig, amíg a várólista érhető el a kapcsolódási kérelmet.       Használja a <xref:System.Net.Sockets.TcpListener.Stop%2A>metódus bezárásához a <xref:System.Net.Sockets.TcpListener>és a figyelést.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> Ön felelősséggel tartozik a elfogadott kapcsolatok bezárásával külön-külön.      > [!NOTE] > Használja a <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>tulajdonság beszerzése a konkrét hibakód megtekinthető, és a Windows Sockets 2-es verziójú API hiba kód dokumentációjában az MSDN-könyvtárban, [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) a hiba részletes leírását.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how <xref:System.Net.Sockets.TcpListener.Start%2A> is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_17_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_17_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_17_1.vb)]"
  syntax:
    content: public void Start (int backlog);
    parameters:
    - id: backlog
      type: System.Int32
      description: "A függőben lévő kapcsolatok várólista maximális hossza."
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Hiba történt a szoftvercsatorna elérése közben. További információt a Megjegyzések című szakaszában talál."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A<code>  backlog </code> paraméter kisebb, mint nulla vagy meghaladja az engedélyezett kapcsolatok maximális számát."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Az alapul szolgáló <xref:System.Net.Sockets.Socket>Null értékű.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Stop
  id: Stop
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "A figyelő bezárása."
  remarks: "Állítsa le a figyelő bezárása után. Bármilyen elfogadhatatlan csatlakozási kérések a várólistán lévő el fog veszni. Távoli állomások kapcsolatot vár el kell fogadni kivételhibát <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> Ön felelősséggel tartozik a elfogadott kapcsolatok bezárásával külön-külön.      > [!NOTE] > Ehhez a taghoz kiírja a nyomkövetési adatokat, ha engedélyezi a hálózati nyomkövetés az alkalmazásban. További információkért lásd: [hálózati nyomkövetés a .NET-keretrendszer](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates using the Stop method to close the underlying <xref:System.Net.Sockets.Socket>.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Stop*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Használja a &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; tulajdonságnak a konkrét hibakód megtekinthető. Ez a kód szerezte be, amikor a Windows Sockets 2-es verziójú API hiba dokumentációja az MSDN-en a hiba részletes leírását is hivatkozunk."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
- uid: System.Net.IPEndPoint
  parent: System.Net
  isExternal: true
  name: IPEndPoint
  nameWithType: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: true
  name: IPAddress
  nameWithType: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Socket>
  nameWithType: Task<Socket>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.Socket>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.Socket>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.Socket
    name: Socket
    nameWithType: Socket
    fullName: Socket
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
- uid: System.Net.Sockets.TcpClient
  parent: System.Net.Sockets
  isExternal: false
  name: TcpClient
  nameWithType: TcpClient
  fullName: System.Net.Sockets.TcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<TcpClient>
  nameWithType: Task<TcpClient>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.TcpClient>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.TcpClient>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    nameWithType: TcpClient
    fullName: TcpClient
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.Active
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
- uid: System.Net.Sockets.TcpListener
  parent: System.Net.Sockets
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: true
  name: EndPoint
  nameWithType: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net.Sockets.TcpListener.Pending
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
- uid: System.Net.Sockets.TcpListener.Server
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
- uid: System.Net.Sockets.TcpListener.Stop
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
- uid: System.Net.Sockets.TcpListener.#ctor*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener.TcpListener
- uid: System.Net.Sockets.TcpListener.AcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket
  nameWithType: TcpListener.AcceptSocket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync
  nameWithType: TcpListener.AcceptSocketAsync
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient
  nameWithType: TcpListener.AcceptTcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync
  nameWithType: TcpListener.AcceptTcpClientAsync
- uid: System.Net.Sockets.TcpListener.Active*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal
  nameWithType: TcpListener.AllowNatTraversal
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket
  nameWithType: TcpListener.BeginAcceptSocket
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient
  nameWithType: TcpListener.BeginAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.Create*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create
  nameWithType: TcpListener.Create
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket
  nameWithType: TcpListener.EndAcceptSocket
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient
  nameWithType: TcpListener.EndAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
- uid: System.Net.Sockets.TcpListener.Pending*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending
  nameWithType: TcpListener.Pending
- uid: System.Net.Sockets.TcpListener.Server*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start
  nameWithType: TcpListener.Start
- uid: System.Net.Sockets.TcpListener.Stop*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop
  nameWithType: TcpListener.Stop
