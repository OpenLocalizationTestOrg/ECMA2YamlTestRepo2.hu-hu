### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Érkezési sorrendben történő kiküldési objektumok gyűjteményét képviseli."
  remarks: "Ez az osztály a várólista körkörös tömbként valósítja meg. A sorhoz tárolt objektumok beszúrni egy végén, és eltávolítja a másik.       A várólisták és a verem hasznosak, ha szüksége ideiglenes tárolóra vonatkozó adatokat. Ez azt jelenti, hogy mikor érdemes vesse el egy elem értékének beolvasása után. Várólista használata, ha ugyanabban a sorrendben, hogy az a gyűjteményekben tárolt információk eléréséhez szükséges. Használjon <xref:System.Collections.Stack>kell-e fordított sorrendben hozzáférhet az adatokhoz.</xref:System.Collections.Stack> Használjon <xref:System.Collections.Concurrent.ConcurrentQueue%601>vagy <xref:System.Collections.Concurrent.ConcurrentStack%601>Ha eléréséhez szükséges a gyűjtemény több szál egyidejűleg.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       A várólista és az elemei végrehajtható három fő műveletek:- <xref:System.Collections.Queue.Enqueue%2A>elemet ad hozzá a sor végéig.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>a legrégebbi elem eltávolítása a várólista elejére.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>adja vissza a legrégebbi elem a sor elején, de nem távolítja el a sorból.</xref:System.Collections.Queue.Peek%2A>       A várólista kapacitása a várólista tárolására képes elemek száma. Elemek hozzáadása egy üzenetsorba, automatikusan nagyobb-e a kapacitás szükség szerint keresztül foglalásainak módosítása.  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, ha a várólista konstruált. Az alapértelmezett növekedési tényező 2.0. A várólista kapacitás legalább legalább négy, függetlenül a növekedési tényező mindig nő. Például egy növekedési tényező 1.0 rendelkező várólista mindig növekszik kapacitás négy Ha nagyobb kapacitású szükség.       Várólista fogad `null` mint érvényes értéket, és lehetővé teszi a duplikált elemeket.       Ez a gyűjtemény általános verziója:<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Queue&quot;> </xref> osztály, amely üres, az alapértelmezett kezdeti kapacitása, és használja az alapértelmezett növekedési mutatója."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma a <xref:System.Collections.Queue>tárolására képes.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elemek hozzáadása a egy <xref:System.Collections.Queue>, automatikusan jobb lesz, a kapacitás szükség szerint keresztül foglalásainak módosítása.</xref:System.Collections.Queue>  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, amikor a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue>       Ez a konstruktor O(1) során."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Queue&quot;> </xref> osztály, amely átmásolja a megadott gyűjtemény olyan elemet tartalmaz a azonos kezdeti kapacitása a másolt elemek számának, és használja az alapértelmezett növekedési mutatója."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma a <xref:System.Collections.Queue>tárolására képes.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elemek hozzáadása a egy <xref:System.Collections.Queue>, automatikusan jobb lesz, a kapacitás szükség szerint keresztül foglalásainak módosítása.</xref:System.Collections.Queue>  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, amikor a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue>       Az elemek másolja az <xref:System.Collections.Queue>ugyanabban a sorrendben a <xref:System.Collections.IEnumerator> <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> által olvasott</xref:System.Collections.Queue>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "A <xref:System.Collections.ICollection>Másolandó elemek.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Queue&quot;> </xref> osztály, amely üres, a megadott kezdeti kapacitása, és használja az alapértelmezett növekedési mutatója."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma a <xref:System.Collections.Queue>tárolására képes.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elemek hozzáadása a egy <xref:System.Collections.Queue>, automatikusan jobb lesz, a kapacitás szükség szerint keresztül foglalásainak módosítása.</xref:System.Collections.Queue>  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, amikor a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue>       Ha a gyűjtemény méreténél becsülhető, adja meg a kezdeti kapacitása szükségtelenné teszi többféle átméretezési műveletek elemek a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> való hozzáadása közben       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "A kezdeti elemek száma, amelyek a <xref href=&quot;System.Collections.Queue&quot;> </xref> tartalmazhat."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Queue&quot;> </xref> osztály, amely üres, a megadott kezdeti kapacitása, és használja a megadott növekedési mutatója."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma a <xref:System.Collections.Queue>tárolására képes.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elemek hozzáadása a egy <xref:System.Collections.Queue>, automatikusan jobb lesz, a kapacitás szükség szerint keresztül foglalásainak módosítása.</xref:System.Collections.Queue>  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, amikor a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue> A kapacitása a <xref:System.Collections.Queue>mindig megnöveli a minimális érték, függetlenül a növekedési tényező; a növekedési tényező 1.0 nem fogja megakadályozni a <xref:System.Collections.Queue>száma nő a.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ha a gyűjtemény méreténél becsülhető, adja meg a kezdeti kapacitása szükségtelenné teszi többféle átméretezési műveletek elemek a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> való hozzáadása közben       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "A kezdeti elemek száma, amelyek a <xref href=&quot;System.Collections.Queue&quot;> </xref> tartalmazhat."
    - id: growFactor
      type: System.Single
      description: "A tényező kapacitása a <xref href=&quot;System.Collections.Queue&quot;> </xref> ki van bontva."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla.       – vagy – <code>growFactor</code> kisebb, mint 1.0-ás vagy annál nagyobb 10.0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Eltávolítja az összes objektum a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>van nullára van állítva, és a gyűjtemény elemeinek más objektumokra mutató hivatkozásokat is kiadásakor.</xref:System.Collections.Queue.Count%2A>       A kapacitás változatlan marad. Alaphelyzetbe állítja a <xref:System.Collections.Queue> <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> hívja,</xref:System.Collections.Queue> a kapacitás Egy üres díszítésre <xref:System.Collections.Queue>kapacitásának beállítja a <xref:System.Collections.Queue>alapértelmezett kapacitással.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Sekély másolatot készít a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Egy gyűjtemény sekély másolatát másolja át a gyűjtemény csak azokat az elemeket, hogy-e a referencia típusoknak vagy értéktípusok, de nem másolja át az objektumokat, amely hivatkozik a hivatkozásokat. Az új gyűjtemény szereplő hivatkozások a azonos objektumok, amelyek az eredeti gyűjtemény elemben található hivatkozások mutasson.       Ezzel szemben egy gyűjtemény mély másolatát másolja át az elemeket, és mindent közvetlenül vagy közvetetten hivatkozik az elemeket.       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Sekély másolatát a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Meghatározza, hogy egy elem található a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Ez a módszer egyenlőség <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> meghívásával azt határozza meg.       Ez a módszer egy lineáris keresést; hajt végre. Ez a módszer ezért O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       A .NET-keretrendszer 2.0-s verziótól kezdődően ez a módszer a gyűjtemény-objektumokat használ <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>metódusai `obj` meghatározásához e `item` létezik.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> A .NET-keretrendszer korábbi verzióiban ez a döntés használatával történt a <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>módszerek a `obj` paraméter a gyűjtemény objektumokon.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "A <xref:System.Object>keresik a <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> Az érték lehet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Másolja a <xref href=&quot;System.Collections.Queue&quot;> </xref> elemek egy meglévő egydimenziós <xref:System.Array>, a megadott tömb indexe a induló.</xref:System.Array>"
  remarks: "Az elemek másolja az <xref:System.Array>ugyanabban a sorrendben, amelyben a számbavevő a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> telepítéseket</xref:System.Array>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Az egydimenziós <xref:System.Array>átmásolva elem, amely a cél <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> A <xref:System.Array>kell rendelkeznie a nulla alapú indexelést.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "A nulla alapú indexét `array` mely másolása megkezdődik."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>kisebb, mint nulla."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>többdimenziós.       – vagy – a forrás elemeinek száma <xref href=&quot;System.Collections.Queue&quot;> </xref> nagyobb, mint a rendelkezésre álló terület <code>index</code> a cél végére <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "A forrás típusa <xref href=&quot;System.Collections.Queue&quot;> </xref> nem konvertálható automatikusan a cél típusa <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi a levő elemek száma a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma, amelyek a <xref:System.Collections.Queue>tárolhatja.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Leképezésszáma, amelyek ténylegesen az <xref:System.Collections.Queue>.</xref:System.Collections.Queue> elemeinek száma       A kapacitása egy <xref:System.Collections.Queue>mindig kisebb, mint számánál.</xref:System.Collections.Queue> Ha száma meghaladja a kapacitását elem hozzáadása közben, a kapacitás automatikusan növekszik a belső tömbnek újra-hozzárendelése előtt másolja a régi és az új elemekkel. Az új határozza meg, a jelenlegi kapacitásnál megszorozzuk a növekedési tényező, amely határozza meg, ha a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue> A kapacitása a <xref:System.Collections.Queue>mindig megnöveli a minimális érték, függetlenül a növekedési tényező; a növekedési tényező 1.0 nem fogja megakadályozni a <xref:System.Collections.Queue>száma nő a.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Levő elemek száma a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Eltávolítja és elején objektumot a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Ez a módszer hasonlít a <xref:System.Collections.Queue.Peek%2A>metódust, de <xref:System.Collections.Queue.Peek%2A>nem módosítja a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`felveheti a <xref:System.Collections.Queue>értékként.</xref:System.Collections.Queue> Null értékű, és vége megkülönböztetni a <xref:System.Collections.Queue>, ellenőrizze a <xref:System.Collections.Queue.Count%2A>tulajdonság vagy catch a <xref:System.InvalidOperationException>, amely vált ki, ha a <xref:System.Collections.Queue>üres.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Ez a módszer O(1) során."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "Az objektum, amely a rendszer eltávolítja a kezdetétől a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> üres."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Objektum hozzáadása az végén a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A kapacitása egy <xref:System.Collections.Queue>elemek száma a <xref:System.Collections.Queue>tárolására képes.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elemek hozzáadása a egy <xref:System.Collections.Queue>, automatikusan jobb lesz, a kapacitás szükség szerint keresztül foglalásainak módosítása.</xref:System.Collections.Queue>  A kapacitás csökkenthetők <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> meghívásával       A növekedési arányt a szám, amely a jelenlegi kapacitásnál megszorozzuk egy nagyobb kapacitással, szükség.  A növekedési tényező határozza meg, amikor a <xref:System.Collections.Queue>összeállított.</xref:System.Collections.Queue> A kapacitása a <xref:System.Collections.Queue>mindig megnöveli a minimális érték, függetlenül a növekedési tényező; a növekedési tényező 1.0 nem fogja megakadályozni a <xref:System.Collections.Queue>száma nő a.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ha <xref:System.Collections.Queue.Count%2A>kisebb, mint a kapacitás, a belső tömbnek, ez a módszer egy O(1) művelet.</xref:System.Collections.Queue.Count%2A> Ha a belső tömbnek kell foglalhatók le újra az új elem befogadásához, ez a módszer válik O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Az objektum hozzáadása az <xref href=&quot;System.Collections.Queue&quot;> </xref>. Az érték lehet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Adja vissza, amely megismétli a számbavevő a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A `foreach` utasítás a C# nyelv (`for each` a Visual Basic nyelvben) elrejti a enumerálók összetettsége.  Ezért használatával `foreach` ajánlott, az adatbázis közvetlen módosítása az enumerátor helyett.       Enumerálók beolvasni az adatokat a gyűjtemény használható, de nem használható az alapul szolgáló gyűjtemény módosításához.       Kezdetben a számbavevő a gyűjtemény első eleme elé. <xref:System.Collections.IEnumerator.Reset%2A>is jelent a számbavevő vissza az ebben a helyzetben.</xref:System.Collections.IEnumerator.Reset%2A>  Ennél a pozíciónál <xref:System.Collections.IEnumerator.Current%2A>nincs definiálva.</xref:System.Collections.IEnumerator.Current%2A> Ezért meg kell hívnia <xref:System.Collections.IEnumerator.MoveNext%2A>ahhoz, hogy a számbavevő a <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> értékének olvasása előtt a gyűjtemény első eleme</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>az azonos objektumot ad vissza, amíg újra nem indítják <xref:System.Collections.IEnumerator.MoveNext%2A>vagy <xref:System.Collections.IEnumerator.Reset%2A>nevezik.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Beállítja a <xref:System.Collections.IEnumerator.Current%2A>átállítása.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Ha <xref:System.Collections.IEnumerator.MoveNext%2A>gyűjteményének, a számbavevő a gyűjtemény utolsó eleme mögé van elhelyezve fázisok és <xref:System.Collections.IEnumerator.MoveNext%2A>adja vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> A számbavevő ezen a helyen, az ezt követő hívások esetén <xref:System.Collections.IEnumerator.MoveNext%2A>is vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Ha az utolsó irányuló hívás <xref:System.Collections.IEnumerator.MoveNext%2A>visszaadott `false`, <xref:System.Collections.IEnumerator.Current%2A>nincs definiálva.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>Ebben az esetben a gyűjtemény első eleme a hívása <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> követ</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> beállítása       Enumerátor érvényes marad mindaddig, amíg a gyűjtemény változatlan marad. Ha módosítják a gyűjteményhez, hozzáadása, módosítása vagy törlése elemek, például a számbavevő visszavonhatatlanul érvénytelenített és annak viselkedését nincs definiálva.       A számbavevő nem rendelkezik kizárólagos hozzáférése a gyűjteményhez; egy gyűjtemény számbavétele ezért alapvetően nem szálbiztos eljárást.  Szál biztonsági felsorolásakor biztosításához zárolhatja a teljes számbavételi művelet során a gyűjteményben.  A gyűjteményt, amelyben több szál olvasására vagy írására érhető el, hogy meg kell valósítani a saját szinkronizálási.       Ez a módszer O(1) során."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy érték, amely jelzi, hogy hozzáférést lekérdezi a <xref href=&quot;System.Collections.Queue&quot;> </xref> van (a többszálú futtatásra) szinkronizálva."
  remarks: "A szál biztonságának szavatolása a <xref:System.Collections.Queue>, a burkoló által visszaadott összes műveleteket kell elvégezni a <xref:System.Collections.Queue.Synchronized%2A>metódus.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       Egy gyűjtemény számbavétele alapvetően nem szálbiztos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a hozzáférést a <xref href=&quot;System.Collections.Queue&quot;> </xref> van (a többszálú futtatásra) szinkronizált; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Elején objektumot ad vissza a <xref href=&quot;System.Collections.Queue&quot;> </xref> eltávolítása nélkül."
  remarks: "Ez a módszer hasonlít a <xref:System.Collections.Queue.Dequeue%2A>metódust, de a betekintés nem módosítja a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`felveheti a <xref:System.Collections.Queue>értékként.</xref:System.Collections.Queue> Null értékű, és vége megkülönböztetni a <xref:System.Collections.Queue>, ellenőrizze a <xref:System.Collections.Queue.Count%2A>tulajdonság vagy catch a <xref:System.InvalidOperationException>, amely vált ki, ha a <xref:System.Collections.Queue>üres.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Ez a módszer O(1) során."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Az objektum elején a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> üres."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Visszaadja egy új <xref href=&quot;System.Collections.Queue&quot;> </xref> , amely az eredeti várólista becsomagolja, és többszálú futtatásra."
  remarks: "Ez a metódus által visszaadott a burkoló a várólista zárolja, így szálbiztos módon végezhető el egy művelet végrehajtása előtt.       A szál biztonságának szavatolása a <xref:System.Collections.Queue>, csak a burkoló minden műveletet kell elvégezni.</xref:System.Collections.Queue>       Egy gyűjtemény számbavétele alapvetően nem szálbiztos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> szinkronizálásához."
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> burkoló, amely szinkronizálva (többszálú futtatásra)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Olyan objektum, amely segítségével való hozzáférés szinkronizálása lekérdezi a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A szinkronizált verziót hoz létre a <xref:System.Collections.Queue>, használja a <xref:System.Collections.Queue.Synchronized%2A>metódus.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> Hogy a származtatott osztályok, adja meg a saját szinkronizált verzióját a <xref:System.Collections.Queue>a SyncRoot tulajdonság használatával.</xref:System.Collections.Queue> A szinkronizálási kódot kell műveleteket a SyncRoot a <xref:System.Collections.Queue>, nem közvetlenül a <xref:System.Collections.Queue>.</xref:System.Collections.Queue> a</xref:System.Collections.Queue> Ez biztosítja, hogy a gyűjtemények más objektumok származó megfelelő működését. Pontosabban, tart fenn a megfelelő szinkronizálási más szállal, amely előfordulhat, hogy egyidejűleg módosítása a <xref:System.Collections.Queue>objektum.</xref:System.Collections.Queue>       Egy gyűjtemény számbavétele alapvetően nem szálbiztos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Olyan objektum, amely segítségével való hozzáférés szinkronizálása a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Másolja a <xref href=&quot;System.Collections.Queue&quot;> </xref> elemet egy új tömbhöz."
  remarks: "A <xref:System.Collections.Queue>nem módosul.</xref:System.Collections.Queue> Az új tömb elemeinek sorrendje megegyezik az elejétől elemek sorrendjét a <xref:System.Collections.Queue>végéhez.</xref:System.Collections.Queue>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Egy új átmásolva elemeket tartalmazó tömb a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "A kapacitás állítja az elemek tényleges száma a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Ez a módszer használható egy várólista memória terhet minimalizálhatja nem új elemek nem kerülnek a várólistára.       Alaphelyzetbe állítja a <xref:System.Collections.Queue>hívja meg a kezdeti állapotot, a <xref:System.Collections.Queue.Clear%2A>metódus TrimToSize hívása előtt.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> Egy üres díszítésre <xref:System.Collections.Queue>kapacitásának beállítja a <xref:System.Collections.Queue>alapértelmezett kapacitással.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> csak olvasható."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
