### YamlMime:ManagedReference
items:
- uid: System.Collections.Hashtable
  id: Hashtable
  children:
  - System.Collections.Hashtable.#ctor
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  - System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  - System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  - System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.Add(System.Object,System.Object)
  - System.Collections.Hashtable.Clear
  - System.Collections.Hashtable.Clone
  - System.Collections.Hashtable.comparer
  - System.Collections.Hashtable.Contains(System.Object)
  - System.Collections.Hashtable.ContainsKey(System.Object)
  - System.Collections.Hashtable.ContainsValue(System.Object)
  - System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  - System.Collections.Hashtable.Count
  - System.Collections.Hashtable.EqualityComparer
  - System.Collections.Hashtable.GetEnumerator
  - System.Collections.Hashtable.GetHash(System.Object)
  - System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.hcp
  - System.Collections.Hashtable.IsFixedSize
  - System.Collections.Hashtable.IsReadOnly
  - System.Collections.Hashtable.IsSynchronized
  - System.Collections.Hashtable.Item(System.Object)
  - System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  - System.Collections.Hashtable.Keys
  - System.Collections.Hashtable.OnDeserialization(System.Object)
  - System.Collections.Hashtable.Remove(System.Object)
  - System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  - System.Collections.Hashtable.SyncRoot
  - System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Hashtable.Values
  langs:
  - csharp
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
  type: Class
  summary: "A kulcs/érték párok rendezett alapján a kulcs kivonatkódját gyűjteményét képviseli.       Keresse meg a .NET-keretrendszer forráskód ehhez a típushoz, tekintse meg a [hivatkozás forrás](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)."
  remarks: "> [!NOTE]> Forráskódját .NET-keretrendszer ehhez a típushoz, tekintse meg a [hivatkozás forrás](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd). Tallózzon a forráskód online, töltse le a hivatkozás nélküli megtekintéshez és a források (beleértve a javítások és frissítések) végighaladhat hibakeresési; Lásd: [utasításokat](http://referencesource.microsoft.com/).       Minden eleme egy tárolt kulcs/érték pár egy <xref:System.Collections.DictionaryEntry>objektum.</xref:System.Collections.DictionaryEntry> A kulcs nem lehet `null`, de érték lehet.       A kulcsok egy kivonattáblát által felülbírálása kötelezőként használt objektumok a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>metódus (vagy a <xref:System.Collections.IHashCodeProvider>felület) és a <xref:System.Object.Equals%2A?displayProperty=fullName>metódus (vagy a <xref:System.Collections.IComparer>felület).</xref:System.Collections.IComparer> </xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> Módszerek és a felületek végrehajtásának kell kezelni a kis-és nagybetűk ugyanúgy; Ellenkező esetben a kivonattábla helytelenül viselkedése. Például amikor egy kivonattáblát kell használnia a <xref:System.Collections.CaseInsensitiveHashCodeProvider>osztály (minden nem betűérzékeny vagy <xref:System.Collections.IHashCodeProvider>megvalósítása) rendelkező a <xref:System.Collections.CaseInsensitiveComparer>osztály (minden nem betűérzékeny vagy <xref:System.Collections.IComparer>megvalósítása).</xref:System.Collections.IComparer> </xref:System.Collections.CaseInsensitiveComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.CaseInsensitiveHashCodeProvider>       Ezenkívül ezek a módszerek kell ugyanazt az eredményt hívásakor az ugyanezen paraméterekkel rendelkező, amíg a kulcs létezik a kivonattábla a. Egy kivonattáblát konstruktor használata helyett egy <xref:System.Collections.IEqualityComparer>paraméter.</xref:System.Collections.IEqualityComparer> Ha a kulcs egyenlőség egyszerűen hivatkozási egyenlőség, örökölt végrehajtásának volt <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>elegendő lenne.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Kulcs objektumnak kell lennie nem módosítható, amíg használhatók a kivonattábla a kulcsokat.       Egy elem a Kivonattáblába való hozzáadásakor az elem elhelyezi a gyűjtő a kulcs kivonatkódját alapján. A kulcs kereséseknél a kulcs kivonatkódját segítségével csak egy adott gyűjtő, így lényegesen kevesebb kulcs összehasonlítást talált egy elemet kell keresni.       A terhelési faktor egy kivonattáblát a gyűjtők elemek maximális aránya határozza meg. Kisebb terhelés tényezők miatt gyorsabban átlagos keresési alkalommal nagyobb memória-felhasználás használ. Az alapértelmezett a terhelési faktort 1.0 általában biztosítja a legjobb egyensúlyt sebesség és a méret között. Egy másik hitelesítési tényezőt is megadható a kivonattábla létrehozásakor.       Elemek hozzáadása egy kivonattáblát a, növeli a tényleges terhelési faktort, a kivonattábla kulcsa. Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, a kivonattábla gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint kétszer Hashtable gyűjtők aktuális száma.       A Hashtable főbb objektumok biztosítania kell a saját kivonatoló funkció, amely <xref:System.Collections.Hashtable.GetHash%2A>.</xref:System.Collections.Hashtable.GetHash%2A> meghívásával érhető el Azonban bármely megvalósító objektum <xref:System.Collections.IHashCodeProvider>átadhatók egy kivonattáblát konstruktor alkalmaz, és a kivonatoló függvényt a táblázat összes objektumára vonatkozóan.</xref:System.Collections.IHashCodeProvider>       Egy kivonattáblát kapacitása a kivonattábla tárolására képes elemek száma. Elemek hozzáadása egy kivonattáblát a, automatikusan nagyobb-e a kapacitás szükség szerint keresztül foglalásainak módosítása.       Nagyon nagy Hashtable objektumok is növelheti a maximális 2 milliárd elemek egy 64 bites rendszeren úgy, hogy a `enabled` attribútumot a konfigurációs elem `true` a futásidejű környezetben.       A `foreach` utasítás a C# nyelv (`For Each` a Visual Basic nyelvben) a gyűjtemény elemeinek típusú objektum beolvasása. Mivel egyes elemei a kivonattábla kulcsa a kulcs/érték pár, az elem típusa nincs a kulcs típusú vagy az érték típusa. Ehelyett a elemtípusa <xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> Például: [!code-cpp [System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)][!code-cs[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/csharp/t-system.collections.has_1.cs)][!code-vb[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb) ] a `foreach` a számbavevő, olvasása, nem írása, a gyűjtemény csak így csomagolásának utasítás.           Szerializálása és deszerializálása enumerátor egy kivonattáblát is oka a elemek újra lesz, mert nincs lehetőség számbavételi hívása nélkül folytatja a <xref:System.Collections.IEnumerator.Reset%2A>metódus.</xref:System.Collections.IEnumerator.Reset%2A>      > [!NOTE] > Mert kulcsok öröklődjenek és azok viselkedését megváltozott, a abszolút egyediségi nem garantálható összehasonlításával használatával a <xref:System.Type.Equals%2A>metódus.</xref:System.Type.Equals%2A>"
  example:
  - "The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.  \n  \n [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/cpp/t-system.collections.has_2.cpp)]\n [!code-cs[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/csharp/t-system.collections.has_2.cs)]\n [!code-vb[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/visualbasic/t-system.collections.has_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor
  id: '#ctor'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály az alapértelmezett kezdeti tartalékkapacitását használja, és töltse be a tényező, kivonatoló kódszolgáltató és összehasonlító."
  remarks: "Egy kivonattáblát kapacitás kiszámítása kivonatát tábla gyűjtők a terhelési faktor alapján optimális száma szolgál. Automatikusan nő a kapacitás szükség szerint.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Ez a konstruktor O(1) során."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_4_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_4_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_4_1.vb)]"
  syntax:
    content: public Hashtable ();
    parameters: []
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból az új osztály <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és az alapértelmezett a terhelési faktort, kivonatoló kódszolgáltató és összehasonlító használ."
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.has_1_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.has_1_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.has_1_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály az alapértelmezett kezdeti tartalékkapacitását használja, és betölti a tényező, és a megadott <xref:System.Collections.IEqualityComparer>objektum.</xref:System.Collections.IEqualityComparer>"
  remarks: "Egy kivonattáblát kapacitás kiszámítása kivonatát tábla gyűjtők a terhelési faktor alapján optimális száma szolgál. Automatikusan nő a kapacitás szükség szerint.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A <xref:System.Collections.IEqualityComparer>objektum a kivonatoló kódot szolgáltató és a összehasonlító is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>objektum nem szükségesek felülbírálásához a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       A <xref:System.Collections.IEqualityComparer>például a módon végzett keresések nem betűérzékeny karakterláncok olyan forgatókönyveket tesz lehetővé.</xref:System.Collections.IEqualityComparer>       Ez a konstruktor O(1) során."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_5_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_5_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_5_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>objektum, amely meghatározza a kivonatoló kódot szolgáltató és a összehasonlító használata a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IEqualityComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az alapértelmezett kivonatoló kódot szolgáltatója és az alapértelmezett összehasonlítót használja. Az alapértelmezett kivonatoló kódot szolgáltató minden kulcs végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; , és az alapértelmezett összehasonlítót minden kulcs végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> megadott kezdeti kapacitása, és az alapértelmezett a terhelési faktort, kivonatoló kódot szolgáltató segítségével, és összehasonlító osztályban."
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van `capacity`."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.has_2_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.has_2_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.has_2_1.vb)]"
  syntax:
    content: public Hashtable (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból egy új osztályt <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és használja az alapértelmezett a terhelési faktort, és a megadott <xref:System.Collections.IEqualityComparer>objektum.</xref:System.Collections.IEqualityComparer>"
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A <xref:System.Collections.IEqualityComparer>objektum a kivonatoló kódot szolgáltató és a összehasonlító is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>objektum nem szükségesek felülbírálásához a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       A <xref:System.Collections.IEqualityComparer>például a módon végzett keresések nem betűérzékeny karakterláncok olyan forgatókönyveket tesz lehetővé.</xref:System.Collections.IEqualityComparer>       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/81cd87de-02b7-42cc-8fdd-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/81cd87de-02b7-42cc-8fdd-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/81cd87de-02b7-42cc-8fdd-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>objektum, amely meghatározza a kivonatoló kódot szolgáltató és a összehasonlító használata a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az alapértelmezett kivonatoló kódot szolgáltatója és az alapértelmezett összehasonlítót használja. Az alapértelmezett kivonatoló kódot szolgáltató minden kulcs végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; , és az alapértelmezett összehasonlítót minden kulcs végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  id: '#ctor(System.Collections.IDictionary,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból az új osztály <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és a megadott terhelési faktort, és alapértelmezett kivonatoló kódszolgáltató és összehasonlító."
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/fb1cfbc8-7454-4619-a6e7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/fb1cfbc8-7454-4619-a6e7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/fb1cfbc8-7454-4619-a6e7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>kisebb, mint 0,1 van.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály használatával alapértelmezett kezdeti kapacitása és tényező, és a megadott kivonatoló kódszolgáltató és összehasonlító betöltése."
  remarks: "Egy kivonattáblát kapacitás kiszámítása kivonatát tábla gyűjtők a terhelési faktor alapján optimális száma szolgál. Automatikusan nő a kapacitás szükség szerint.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az egyéni kivonatoló kódot szolgáltató és az egyéni összehasonlító lehetővé teszik a forgatókönyvek például a módon végzett keresések nem betűérzékeny karakterláncok.       Ez a konstruktor O(1) során."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/1ff65986-0234-4702-94b7-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/1ff65986-0234-4702-94b7-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/1ff65986-0234-4702-94b7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "A <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> objektum, amely megadja a kivonat a minden kulcs kódok a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használható az alapértelmezett kivonatoló kódot szolgáltató, ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>objektum segítségével állapítsa meg, hogy két kulccsal mint.</xref:System.Collections.IComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használhatja az alapértelmezett összehasonlítót, hogy ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály használata a megadott kezdeti kapacitása és <xref:System.Collections.IEqualityComparer>, és az alapértelmezett a terhelési faktort.</xref:System.Collections.IEqualityComparer>"
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A <xref:System.Collections.IEqualityComparer>objektum a kivonatoló kódot szolgáltató és a összehasonlító is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>felülbírálása nem szükségesek a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       A <xref:System.Collections.IEqualityComparer>például a módon végzett keresések nem betűérzékeny karakterláncok olyan forgatókönyveket tesz lehetővé.</xref:System.Collections.IEqualityComparer>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van a `capacity` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/5067e9ac-cd98-4da8-9418-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/5067e9ac-cd98-4da8-9418-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/5067e9ac-cd98-4da8-9418-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>objektum, amely meghatározza a kivonatoló kódot szolgáltató és a összehasonlító használata a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az alapértelmezett kivonatoló kódot szolgáltatója és az alapértelmezett összehasonlítót használja. Az alapértelmezett kivonatoló kódot szolgáltató minden kulcs végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; , és az alapértelmezett összehasonlítót minden kulcs végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály használata a megadott kezdeti kapacitása és tényező, és az alapértelmezett kivonatoló kódszolgáltató és összehasonlító betöltése."
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van a `capacity` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/m-system.collections.has_8_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/m-system.collections.has_8_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/m-system.collections.has_8_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla.       – vagy – <code>loadFactor</code> 0,1-nál kisebb.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>capacity</code>túlcsordulás okozza."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály, amely használatával a megadott szerializálható <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> és <xref:System.Runtime.Serialization.StreamingContext>objektumok.</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "Egy kivonattáblát kapacitás kiszámítása kivonatát tábla gyűjtők a terhelési faktor alapján optimális száma szolgál. Automatikusan nő a kapacitás szükség szerint.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       Mivel szerializálása és deszerializálása a számbavevő a <xref:System.Collections.Hashtable>válnak átrendezésekor elemek okozhat, ezért nem lehet számbavételi hívása nélkül folytatja a <xref:System.Collections.IEnumerator.Reset%2A>metódus.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> objektum szerializálása szükséges adatokat tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>objektum a forrás- és a szerializált folyam társított tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból az új osztály <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és az alapértelmezett a terhelési faktort, és a megadott kivonatoló kódszolgáltató és összehasonlító használ. Ez az API már elavult. A másik lehetőség, lásd: &lt;xref:System.Collections.Hashtable.%23ctor%2A&gt;."
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az egyéni kivonatoló kódot szolgáltató és az egyéni összehasonlító lehetővé teszik a forgatókönyvek például a módon végzett keresések nem betűérzékeny karakterláncok.       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/9a30e378-7c34-4854-b12f-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/9a30e378-7c34-4854-b12f-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/9a30e378-7c34-4854-b12f-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "A <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> objektum, amely megadja a kivonat a minden kulcs kódok a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használható az alapértelmezett kivonatoló kódot szolgáltató, ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>objektum segítségével állapítsa meg, hogy két kulccsal mint.</xref:System.Collections.IComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használhatja az alapértelmezett összehasonlítót, hogy ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból az új osztály <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és használja a megadott terhelési faktort és <xref:System.Collections.IEqualityComparer>objektum.</xref:System.Collections.IEqualityComparer>"
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A <xref:System.Collections.IEqualityComparer>objektum a kivonatoló kódot szolgáltató és a összehasonlító is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>objektum nem szükségesek felülbírálásához a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       A <xref:System.Collections.IEqualityComparer>például a módon végzett keresések nem betűérzékeny karakterláncok olyan forgatókönyveket tesz lehetővé.</xref:System.Collections.IEqualityComparer>       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/a92f83be-9de4-470a-8cbb-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/a92f83be-9de4-470a-8cbb-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/a92f83be-9de4-470a-8cbb-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>objektum, amely meghatározza a kivonatoló kódot szolgáltató és a összehasonlító használata a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az alapértelmezett kivonatoló kódot szolgáltatója és az alapértelmezett összehasonlítót használja. Az alapértelmezett kivonatoló kódot szolgáltató minden kulcs végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; , és az alapértelmezett összehasonlítót minden kulcs végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>kisebb, mint 0,1 van.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> megadott kezdeti kapacitása, kivonatoló kódot szolgáltató segítségével, összehasonlítóval, és az alapértelmezett a terhelési faktort osztályban."
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az egyéni kivonatoló kódot szolgáltató és az egyéni összehasonlító lehetővé teszik a forgatókönyvek például a módon végzett keresések nem betűérzékeny karakterláncok.       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van a `capacity` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/2154dba0-3cc6-41f7-aa9b-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/2154dba0-3cc6-41f7-aa9b-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/2154dba0-3cc6-41f7-aa9b-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "A <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> objektum, amely megadja a kivonat a minden kulcs kódok a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használható az alapértelmezett kivonatoló kódot szolgáltató, ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>objektum segítségével állapítsa meg, hogy két kulccsal mint.</xref:System.Collections.IComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használhatja az alapértelmezett összehasonlítót, hogy ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály a megadott kezdeti kapacitás, és a terhelési faktort, és <xref:System.Collections.IEqualityComparer>objektum.</xref:System.Collections.IEqualityComparer>"
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A <xref:System.Collections.IEqualityComparer>objektum a kivonatoló kódot szolgáltató és a összehasonlító is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>felülbírálása nem szükségesek a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       A <xref:System.Collections.IEqualityComparer>például a módon végzett keresések nem betűérzékeny karakterláncok olyan forgatókönyveket tesz lehetővé.</xref:System.Collections.IEqualityComparer>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van a `capacity` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/30b60c47-7bce-44a2-8d17-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/30b60c47-7bce-44a2-8d17-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/30b60c47-7bce-44a2-8d17-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>objektum, amely meghatározza a kivonatoló kódot szolgáltató és a összehasonlító használata a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az alapértelmezett kivonatoló kódot szolgáltatója és az alapértelmezett összehasonlítót használja. Az alapértelmezett kivonatoló kódot szolgáltató minden kulcs végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; , és az alapértelmezett összehasonlítót minden kulcs végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla.       – vagy – <code>loadFactor</code> 0,1-nál kisebb.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek másolása a megadott szótárból az új osztály <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum. Az új <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum másolt elemeinek száma egyenlő kezdeti eredően, és a megadott terhelési faktort, kivonatoló kódszolgáltató és összehasonlító használ."
  remarks: "A kezdeti kapacitása értéke a forrás szótár elemeinek száma. Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a kulcsok kivonatoló kódok a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az egyéni kivonatoló kódot szolgáltató és az egyéni összehasonlító lehetővé teszik a forgatókönyvek például a módon végzett keresések nem betűérzékeny karakterláncok.       Az új elemek <xref:System.Collections.Hashtable>ugyanabban a sorrendben, amelyben a számbavevő telepítéseket a rendszer rendezi a <xref:System.Collections.IDictionary>objektum.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ez a konstruktor egy O (`n`) műveletet, ahol `n` lévő elemek száma a `d` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/c67b166f-bc6a-49e5-9bd7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/c67b166f-bc6a-49e5-9bd7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/c67b166f-bc6a-49e5-9bd7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "A <xref:System.Collections.IDictionary>átmásolása az új objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "A <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> objektum, amely megadja a kivonat a minden kulcs kódok a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használható az alapértelmezett kivonatoló kódot szolgáltató, ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>objektum segítségével állapítsa meg, hogy két kulccsal mint.</xref:System.Collections.IComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használhatja az alapértelmezett összehasonlítót, hogy ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>kisebb, mint 0,1 van.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az új, üres példányát inicializálja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> osztály a megadott kezdeti tartalékkapacitását használja, és töltse be a tényező, kivonatoló kódszolgáltató és összehasonlító."
  remarks: "Adja meg a kezdeti kapacitása szükségtelenné teszi számos elemek hozzáadása során átméretezési műveletek végrehajtásához a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable> Kapacitás a rendszer automatikusan nőtt szükség szerint a terhelési faktor alapján.       A terhelési faktor értéke gyűjtők elemek maximális aránya. A kisebb a terhelési faktort azt jelenti, hogy a gyorsabb keresési nagyobb memória-felhasználás használ. A terhelési faktor 1.0 a legjobb egyensúlyt és mérete közötti.       Amikor a tényleges terhelési faktort eléri a megadott terhelési faktort, gyűjtők száma automatikusan nőtt a legkisebb prime számát, amely nagyobb, mint a gyűjtők kétszer aktuális száma.       A kivonatoló kódot szolgáltató biztosítja a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok kivonatoló kódok Az alapértelmezett kivonatoló kódot szolgáltató a kulcs végrehajtásának <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       A összehasonlító meghatározza, hogy két kulccsal egyenlő. Minden kulcs egy <xref:System.Collections.Hashtable>egyedinek kell lennie.</xref:System.Collections.Hashtable> Az alapértelmezett összehasonlítót a kulcs végrehajtásának <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Az egyéni kivonatoló kódot szolgáltató és az egyéni összehasonlító lehetővé teszik a forgatókönyvek például a módon végzett keresések nem betűérzékeny karakterláncok.       Ez a konstruktor egy O (`n`) műveletet, ahol `n` van a `capacity` paraméter."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/86ed2545-c9ee-4654-a1a4-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/86ed2545-c9ee-4654-a1a4-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/86ed2545-c9ee-4654-a1a4-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Az elemek hozzávetőleges számát, amely a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> objektum kezdetben tartalmazhat."
    - id: loadFactor
      type: System.Single
      description: "Egy szám 0,1 és 1,0, amely az alapértelmezett érték, amely a lehető legjobb teljesítményt biztosít a rendszer megszorozza a közé. A gyűjtők elemek maximális aránya eredménye."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "A <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> objektum, amely megadja a kivonat a minden kulcs kódok a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használható az alapértelmezett kivonatoló kódot szolgáltató, ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>objektum segítségével állapítsa meg, hogy két kulccsal mint.</xref:System.Collections.IComparer>       – vagy – <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> használhatja az alapértelmezett összehasonlítót, hogy ez az egyes kulcsok végrehajtásának &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>kisebb, mint nulla.       – vagy – <code>loadFactor</code> 0,1-nál kisebb.       – vagy – <code>loadFactor</code> nagyobb, mint 1.0."
  platform:
  - net462
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "A megadott kulcs és az érték egy elem hozzáadása a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "A kulcs nem lehet `null`, de érték lehet.       Olyan objektum, amely nincs összefüggésben állapotát és a kivonatot kód között általában nem használandó az kulcsként. Például karakterlánc objektum jobb, mint a StringBuilder objektum számára adható meg kulcsként.       Használhatja a <xref:System.Collections.Hashtable.Item%2A>tulajdonság új elemek hozzáadásához úgy, hogy a kulcs értékét, amely nem szerepel a <xref:System.Collections.Hashtable>, például `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Item%2A> Azonban ha a megadott kulcs már létezik a <xref:System.Collections.Hashtable>beállításánál a <xref:System.Collections.Hashtable.Item%2A>tulajdonság felülírja a régi értéket.</xref:System.Collections.Hashtable.Item%2A> </xref:System.Collections.Hashtable> Az Add metódus ellentétben nem módosítja a meglévő elemeket.       Ha <xref:System.Collections.Hashtable.Count%2A>kisebb, mint a kapacitása a <xref:System.Collections.Hashtable>, ez a módszer során O(1).</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Count%2A> Ha a kapacitás növelhető meg, hogy megfeleljen az új elem, ez a módszer válik O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Add Example#1](~/add/codesnippet/cpp/m-system.collections.has_6_1.cpp)]\n [!code-cs[Classic Hashtable.Add Example#1](~/add/codesnippet/csharp/m-system.collections.has_6_1.cs)]\n [!code-vb[Classic Hashtable.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_6_1.vb)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "Adja hozzá az elem kulcsa."
    - id: value
      type: System.Object
      description: "Az elem hozzáadása a értékét. Az érték lehet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Már létezik ilyen kulccsal rendelkező elemet a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható.       – vagy – a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rögzített méretű rendelkezik."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clear
  id: Clear
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Eltávolítja az összes elem a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "<xref:System.Collections.Hashtable.Count%2A>van nullára van állítva, és a gyűjtemény elemeinek más objektumokra mutató hivatkozásokat is kiadásakor.</xref:System.Collections.Hashtable.Count%2A> A kapacitás változatlan marad.       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.has_10_1.cpp)]\n [!code-vb[Classic Hashtable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_10_1.vb)]\n [!code-cs[Classic Hashtable.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.has_10_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Hashtable.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clone
  id: Clone
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Sekély másolatot készít a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Egy gyűjtemény sekély másolatát másolja át a gyűjtemény csak azokat az elemeket, hogy-e a referencia típusoknak vagy értéktípusok, de nem másolja át az objektumokat, amely hivatkozik a hivatkozásokat. Az új gyűjtemény szereplő hivatkozások a azonos objektumok, amelyek az eredeti gyűjtemény elemben található hivatkozások mutasson.       Ezzel szemben egy gyűjtemény mély másolatát másolja át az elemeket, és mindent közvetlenül vagy közvetetten hivatkozik az elemeket.       A <xref:System.Collections.Hashtable>klón számára az azonos száma, az azonos kapacitás, a azonos <xref:System.Collections.IHashCodeProvider>végrehajtása, és az azonos <xref:System.Collections.IComparer>az eredeti <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> végrehajtása</xref:System.Collections.IComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.Hashtable>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Sekély másolatát a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.comparer
  id: comparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi vagy beállítja a <xref:System.Collections.IComparer>való használatra a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  remarks: "Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: protected System.Collections.IComparer comparer { get; set; }
    return:
      type: System.Collections.IComparer
      description: "A <xref:System.Collections.IComparer>való használatra a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  overload: System.Collections.Hashtable.comparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A tulajdonság egy értékre van beállítva, de a kivonattábla <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer> használatával lett létrehozva"
  platform:
  - net462
- uid: System.Collections.Hashtable.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Meghatározza, hogy a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> egy adott kulcs tartalmazza."
  remarks: "Megvalósítja <xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> tartalmaz Hasonlóan viselkednek, mint a <xref:System.Collections.Hashtable.ContainsKey%2A>.</xref:System.Collections.Hashtable.ContainsKey%2A> pontosan       Ez a módszer O(1) során.       A .NET-keretrendszer 2.0-s verziótól kezdődően ez a módszer a gyűjtemény-objektumokat használ <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>metódusai `item` annak meghatározásához, hogy létezik-e elem.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> A .NET-keretrendszer korábbi verzióiban ez a döntés használatával történt a <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>módszerek a `item` paraméter a gyűjtemény objektumokon.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_12_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_12_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "A kulcsot, keresse meg a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rendelkezik a megadott kulcs; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Meghatározza, hogy a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> egy adott kulcs tartalmazza."
  remarks: "Ezzel a módszerrel úgy viselkedik, pontosan a <xref:System.Collections.Hashtable.Contains%2A>.</xref:System.Collections.Hashtable.Contains%2A>       Ez a módszer O(1) során.       A .NET-keretrendszer 2.0-s verziótól kezdődően ez a módszer a gyűjtemény-objektumokat használ <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>metódusai `item` annak meghatározásához, hogy létezik-e elem.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> A .NET-keretrendszer korábbi verzióiban ez a döntés használatával történt a <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>módszerek a `item` paraméter a gyűjtemény objektumokon.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_7_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_7_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_7_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "A kulcsot, keresse meg a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rendelkezik a megadott kulcs; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Meghatározza, hogy a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> egyedi értéket tartalmaz."
  remarks: "A elemeinek értékei a <xref:System.Collections.Hashtable>a megadott értékkel történő összehasonlítja a <xref:System.Object.Equals%2A?displayProperty=fullName>metódus.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.Hashtable>       Ez a módszer egy lineáris keresést; hajt végre. Ez a módszer ezért O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       A .NET-keretrendszer 2.0-s verziótól kezdődően ez a módszer a gyűjtemény-objektumokat használ <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>metódusai `item` annak meghatározásához, hogy létezik-e elem.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> A .NET-keretrendszer korábbi verzióiban ez a döntés használatával történt a <xref:System.Object.Equals%2A>és <xref:System.IComparable.CompareTo%2A>módszerek a `item` paraméter a gyűjtemény objektumokon.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_9_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_9_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_9_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Keresse meg az értéket a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>. Az érték lehet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rendelkezik a megadott <code> value </code>; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Másolja a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elemek egy egydimenziós <xref:System.Array>példány a megadott indexpozíciónál.</xref:System.Array>"
  remarks: "Az elemek másolja az <xref:System.Array>ugyanabban a sorrendben, amelyben a számbavevő a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> telepítéseket</xref:System.Array>       Csak a kulcsok másolása a <xref:System.Collections.Hashtable>, használjon `Hashtable.Keys.CopyTo`.</xref:System.Collections.Hashtable>       A csak azok az értékek másolásához a <xref:System.Collections.Hashtable>, használjon `Hashtable.Values.CopyTo`.</xref:System.Collections.Hashtable>       Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to copy the list of keys or the list of values in a <xref:System.Collections.Hashtable> into a one-dimensional <xref:System.Array>.  \n  \n [!code-cs[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.has_0_1.cs)]\n [!code-vb[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_0_1.vb)]\n [!code-cpp[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.has_0_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "Az egydimenziós <xref:System.Array>célját, amely a <xref:System.Collections.DictionaryEntry>átmásolva objektumok <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.DictionaryEntry> </xref:System.Array> A <xref:System.Array>kell rendelkeznie a nulla alapú indexelést.</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "A nulla alapú indexét `array` mely másolása megkezdődik."
  overload: System.Collections.Hashtable.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>kisebb, mint nulla."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>többdimenziós.       – vagy – a forrás elemeinek száma <xref href=&quot;System.Collections.Hashtable&quot;> </xref> nagyobb, mint a rendelkezésre álló terület <code>arrayIndex</code> a cél végére <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "A forrás típusa <xref href=&quot;System.Collections.Hashtable&quot;> </xref> nem konvertálható automatikusan a cél típusa <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Count
  id: Count
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "A tárolt kulcs/érték párok száma lekérdezi a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "A tárolt kulcs/érték párok száma a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.EqualityComparer
  id: EqualityComparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi a <xref:System.Collections.IEqualityComparer>való használatra a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  remarks: "A <xref:System.Collections.IEqualityComparer>a összehasonlító és a kivonatoló kódszolgáltató is tartalmaz.</xref:System.Collections.IEqualityComparer> Ha egy <xref:System.Collections.IEqualityComparer>szerepel a <xref:System.Collections.Hashtable>konstruktor, a kulcsként használt objektumok a <xref:System.Collections.Hashtable>felülbírálása nem szükségesek a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>és <xref:System.Object.Equals%2A?displayProperty=fullName>módszerek.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: protected System.Collections.IEqualityComparer EqualityComparer { get; }
    return:
      type: System.Collections.IEqualityComparer
      description: "A <xref:System.Collections.IEqualityComparer>való használatra a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  overload: System.Collections.Hashtable.EqualityComparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A tulajdonság egy értékre van beállítva, de a kivonattábla lett létrehozva egy <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> és <xref:System.Collections.IComparer>.</xref:System.Collections.IComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Értéket ad vissza egy <xref:System.Collections.IDictionaryEnumerator>keresztül, amely megismétli a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "[A Visual Basic, a C#]       A `foreach` utasítás a C# nyelv (`for each` a Visual Basic nyelvben) elrejti a enumerálók összetettsége.  Ezért használatával `foreach` ajánlott, az adatbázis közvetlen módosítása az enumerátor helyett.       Enumerálók beolvasni az adatokat a gyűjtemény használható, de nem használható az alapul szolgáló gyűjtemény módosításához.       Kezdetben a számbavevő a gyűjtemény első eleme elé. <xref:System.Collections.IEnumerator.Reset%2A>is jelent a számbavevő vissza az ebben a helyzetben.</xref:System.Collections.IEnumerator.Reset%2A>  Ennél a pozíciónál <xref:System.Collections.IEnumerator.Current%2A>nincs definiálva.</xref:System.Collections.IEnumerator.Current%2A> Ezért meg kell hívnia <xref:System.Collections.IEnumerator.MoveNext%2A>ahhoz, hogy a számbavevő a <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> értékének olvasása előtt a gyűjtemény első eleme</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>az azonos objektumot ad vissza, amíg újra nem indítják <xref:System.Collections.IEnumerator.MoveNext%2A>vagy <xref:System.Collections.IEnumerator.Reset%2A>nevezik.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Beállítja a <xref:System.Collections.IEnumerator.Current%2A>átállítása.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Ha <xref:System.Collections.IEnumerator.MoveNext%2A>gyűjteményének, a számbavevő a gyűjtemény utolsó eleme mögé van elhelyezve fázisok és <xref:System.Collections.IEnumerator.MoveNext%2A>adja vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> A számbavevő ezen a helyen, az ezt követő hívások esetén <xref:System.Collections.IEnumerator.MoveNext%2A>is vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Ha az utolsó irányuló hívás <xref:System.Collections.IEnumerator.MoveNext%2A>visszaadott `false`, <xref:System.Collections.IEnumerator.Current%2A>nincs definiálva.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>Ebben az esetben a gyűjtemény első eleme a hívása <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> követ</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> beállítása       Enumerátor érvényes marad mindaddig, amíg a gyűjtemény változatlan marad. Ha módosítják a gyűjteményhez, hozzáadása, módosítása vagy törlése elemek, például a számbavevő visszavonhatatlanul érvénytelenített és annak viselkedését nincs definiálva.       A számbavevő nem rendelkezik kizárólagos hozzáférése a gyűjteményhez; egy gyűjtemény számbavétele ezért alapvetően nem biztonságos szál eljárást.  Szál biztonsági felsorolásakor biztosításához zárolhatja a teljes számbavételi művelet során a gyűjteményben.  A gyűjteményt, amelyben több szál olvasására vagy írására érhető el, hogy meg kell valósítani a saját szinkronizálási.       Ez a módszer O(1) során.       Mivel szerializálása és deszerializálása a számbavevő a <xref:System.Collections.Hashtable>válnak átrendezésekor elemek okozhat, ezért nem lehet számbavételi hívása nélkül folytatja a <xref:System.Collections.IEnumerator.Reset%2A>metódus.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  example:
  - "The following example compares the use of GetEnumerator and `foreach` to enumerate the contents of a <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable Example#2](~/add/codesnippet/cpp/m-system.collections.has_3_1.cpp)]\n [!code-cs[Classic Hashtable Example#2](~/add/codesnippet/csharp/m-system.collections.has_3_1.cs)]\n [!code-vb[Classic Hashtable Example#2](~/add/codesnippet/visualbasic/m-system.collections.has_3_1.vb)]"
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Hashtable&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Hashtable.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.GetHash(System.Object)
  id: GetHash(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "A megadott kulcs kivonatkódját adja vissza."
  remarks: "Ha egy adott hozták létre a kivonattábla <xref:System.Collections.IHashCodeProvider>, ezt a módszert használ a kivonatoló kódot szolgáltatót; ellenkező esetben használja a <xref:System.Object.GetHashCode%2A?displayProperty=fullName>végrehajtásának `key`.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider>       Ez a módszer O(1) során."
  syntax:
    content: protected virtual int GetHash (object key);
    parameters:
    - id: key
      type: System.Object
      description: "A <xref:System.Object>, amelyhez a kivonatkód visszaadandó.</xref:System.Object>"
    return:
      type: System.Int32
      description: "A kivonatoló kódját <code> key </code>."
  overload: System.Collections.Hashtable.GetHash*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Megvalósítja a <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> felületet, és visszaadja az adatokat szükség lehet, mert a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> objektum szerializálása szükséges adatokat tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>objektum a forrás- és a szerializált folyam társított tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A gyűjtemény módosult."
  platform:
  - net462
- uid: System.Collections.Hashtable.hcp
  id: hcp
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi vagy beállítja az objektum, amely a kivonatoló kódokat is eredményeként."
  remarks: "Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: protected System.Collections.IHashCodeProvider hcp { get; set; }
    return:
      type: System.Collections.IHashCodeProvider
      description: "Az objektum, amely a kivonatoló kódokat is eredményeként."
  overload: System.Collections.Hashtable.hcp*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A tulajdonság egy értékre van beállítva, de a kivonattábla <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer> használatával lett létrehozva"
  platform:
  - net462
- uid: System.Collections.Hashtable.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi, hogy egy érték, amely jelzi, hogy a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rögzített méretű rendelkezik."
  remarks: "Rögzített méretű gyűjtemény nem teszi lehetővé hozzáadását és eltávolítását, az elem után a gyűjtemény létrejött, de lehetővé teszi a meglévő elemeket módosítása.       A gyűjtemény rögzített méretű egyszerűen egy gyűjteménybe, és egy burkoló, amely megakadályozza a hozzáadása és eltávolítása elemek; Ezért ha módosítás történik az alapul szolgáló gyűjtemény, hozzáadását és eltávolítását, az elem, beleértve a rögzített méretű gyűjtemény tükrözi ezeket a módosításokat.       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rendelkezik egy rögzített méretű; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi, hogy egy érték, amely jelzi, hogy a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható."
  remarks: "A csak olvasható gyűjtemény nem teszi lehetővé a hozzáadása, eltávolítása vagy módosítása az elem a gyűjtemény létrehozása után.       A gyűjtemény csak olvasható egyszerűen egy gyűjteménybe, és egy burkoló, amely megakadályozza a módosítását a gyűjtemény; Ezért ha az alapul szolgáló gyűjtemény módosításai, a csak olvasható gyűjtemény tükrözi ezeket a módosításokat.       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy érték, amely jelzi, hogy hozzáférést lekérdezi a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> van (a többszálú futtatásra) szinkronizálva."
  remarks: "A <xref:System.Collections.Hashtable>támogathat egy író és a több olvasót.</xref:System.Collections.Hashtable> Több írók támogatásához minden műveleteket kell elvégezni a burkoló által visszaadott a <xref:System.Collections.Hashtable.Synchronized%2A>metódus.</xref:System.Collections.Hashtable.Synchronized%2A>       Egy gyűjtemény számbavétele nincs belsőleg egy szál biztonságos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket.       Az alábbi példakód bemutatja, hogyan a gyűjteményhez történő zárolja a <xref:System.Collections.Hashtable.SyncRoot%2A>a teljes enumerálása során: [!code-cpp [klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)][!code-vb[klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)][!code-cs[klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs) ]     </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.has_1_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.has_1_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.has_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a hozzáférést a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> van (a többszálú futtatásra) szinkronizált; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi vagy beállítja az adott kulcshoz hozzárendelt értéket."
  remarks: "Ez a tulajdonság lehetővé teszi a hozzáférést egy adott elem a gyűjteményben a következő szintaxissal: `myCollection[key]`.       Az elemtulajdonság is használhatja új elemek hozzáadásához állítsa az értéket, amely nem létezik a kulcs a <xref:System.Collections.Hashtable>, például `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> Azonban ha a megadott kulcs már létezik a <xref:System.Collections.Hashtable>, a cikk tulajdonság beállítása felülírja a régi értéket.</xref:System.Collections.Hashtable> Ezzel szemben a <xref:System.Collections.Hashtable.Add%2A>metódus nem módosítja a meglévő elemeket.</xref:System.Collections.Hashtable.Add%2A>       A kulcs nem lehet `null`, de érték lehet. Megkülönböztetésére `null` , amely ad vissza, mert a megadott kulcs nem található és `null` , amely ad vissza, mert a megadott kulcs értéke `null`, használja a <xref:System.Collections.Hashtable.Contains%2A>metódust vagy a <xref:System.Collections.Hashtable.ContainsKey%2A>módszer annak meghatározásához, hogy a kulcs létezik-e a listában.</xref:System.Collections.Hashtable.ContainsKey%2A> </xref:System.Collections.Hashtable.Contains%2A>       Ez a tulajdonság értékének beolvasása során O(1); a következő tulajdonság beállítása során is O(1).       A C# nyelv meghatározására az indexelők végrehajtási helyett a kulcsszó használ a <xref:System.Collections.IList.Item%2A>tulajdonság.</xref:System.Collections.IList.Item%2A> Visual Basic elem megvalósítja az alapértelmezett tulajdonság, amely indexelési ugyanezt a funkcionalitást biztosítja."
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "A kulcs értéke beolvasni vagy megadni."
    return:
      type: System.Object
      description: "A megadott kulcshoz hozzárendelt értéket. Ha a megadott kulcs nem található, próbál szerezni az értéket ad vissza <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, és állítsa be úgy próbál hoz létre egy új elem a megadott kulcs használatával."
  overload: System.Collections.Hashtable.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A tulajdonság értéke és az <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható.       – vagy – a tulajdonság értéke, <code> key </code> nem létezik a gyűjteményben, és a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rögzített méretű rendelkezik."
  platform:
  - net462
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  id: KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Egy konkrét összehasonlítja <xref:System.Object>az adott kulccsal a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Object>"
  remarks: "Ha egy adott hozták létre a kivonattábla <xref:System.Collections.IComparer>végrehajtására, ezt a módszert használja, hogy összehasonlító; amely, <xref:System.Collections.IComparer.Compare%2A>(`item`, `key`).</xref:System.Collections.IComparer.Compare%2A> </xref:System.Collections.IComparer> Ellenkező esetben használja `item.Equals(key)`.       Ez a módszer O(1) során."
  syntax:
    content: protected virtual bool KeyEquals (object item, object key);
    parameters:
    - id: item
      type: System.Object
      description: "A <xref:System.Object>való összehasonlításra `key`.</xref:System.Object>"
    - id: key
      type: System.Object
      description: "A kulcs a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> való összehasonlításra `item`."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> and <code>key</code> are equal; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Hashtable.KeyEquals*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>item</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>key</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Keys
  id: Keys
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi egy <xref:System.Collections.ICollection>tartalmazó a kulcsokat a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "A kulcsok sorrendje a <xref:System.Collections.ICollection>nincs megadva, de ugyanabban a sorrendben, mint a hozzájuk társított értékeket a <xref:System.Collections.ICollection>által visszaadott a <xref:System.Collections.Hashtable.Values%2A>metódus.</xref:System.Collections.Hashtable.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       A visszaadott <xref:System.Collections.ICollection>Nincs statikus másolatát; ehelyett a <xref:System.Collections.ICollection>hivatkozik vissza az eredeti <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> kulcsok</xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Ezért megváltozik a <xref:System.Collections.Hashtable>továbbra is megjelennek a <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Hashtable>       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "Egy <xref:System.Collections.ICollection>tartalmazó a kulcsokat a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  id: OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Megvalósítja a <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> felületet, és a deszerializálás eseményt, amikor befejeződött a deszerializálás riasztást."
  remarks: "Ez a módszer egy O (`n`) műveletet, ahol `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       Mivel szerializálása és deszerializálása a számbavevő a <xref:System.Collections.Hashtable>válnak átrendezésekor elemek okozhat, ezért nem lehet számbavételi hívása nélkül folytatja a <xref:System.Collections.IEnumerator.Reset%2A>metódus.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: public virtual void OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "A deszerializálási esemény forrását."
  overload: System.Collections.Hashtable.OnDeserialization*
  exceptions:
  - type: System.Runtime.Serialization.SerializationException
    commentId: T:System.Runtime.Serialization.SerializationException
    description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> társított az aktuális objektum <xref href=&quot;System.Collections.Hashtable&quot;> </xref> érvénytelen."
  platform:
  - net462
- uid: System.Collections.Hashtable.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Az elem eltávolítja a megadott kulccsal a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Ha a <xref:System.Collections.Hashtable>nem tartalmaz egy elemet a megadott kulccsal, a <xref:System.Collections.Hashtable>változatlan marad.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> Nincs kivétel történt.       Ez a módszer O(1) során."
  example:
  - "The following example shows how to remove elements from the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.has_13_1.cpp)]\n [!code-cs[Classic Hashtable.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.has_13_1.cs)]\n [!code-vb[Classic Hashtable.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_13_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Az eltávolítandó elem kulcsa."
  overload: System.Collections.Hashtable.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A <xref href=&quot;System.Collections.Hashtable&quot;> </xref> csak olvasható.       – vagy – a <xref href=&quot;System.Collections.Hashtable&quot;> </xref> rögzített méretű rendelkezik."
  platform:
  - net462
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  id: Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "A szinkronizált (szálbiztos) burkolót adja vissza a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "A Synchronized metódus több olvasók és írók szálbiztos. Továbbá a szinkronizált burkoló biztosítja, hogy van-e írása egyszerre csak egy író.       Egy gyűjtemény számbavétele alapvetően nem szálbiztos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket.       Az alábbi példakód bemutatja, hogyan a gyűjteményhez történő zárolja a <xref:System.Collections.Hashtable.SyncRoot%2A>a teljes enumerálása során: [!code-cpp [klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)][!code-vb[klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)][!code-cs[klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs) ] Ez a módszer során O(1).    </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.has_11_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.has_11_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_11_2.vb)]"
  syntax:
    content: public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);
    parameters:
    - id: table
      type: System.Collections.Hashtable
      description: "A <xref href=&quot;System.Collections.Hashtable&quot;> </xref> szinkronizálásához."
    return:
      type: System.Collections.Hashtable
      description: "A szinkronizált (szálbiztos) burkolót a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.SyncRoot
  id: SyncRoot
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Olyan objektum, amely segítségével való hozzáférés szinkronizálása lekérdezi a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "A szinkronizált verziót hoz létre a <xref:System.Collections.Hashtable>, használja a <xref:System.Collections.Hashtable.Synchronized%2A>metódus.</xref:System.Collections.Hashtable.Synchronized%2A> </xref:System.Collections.Hashtable> Hogy a származtatott osztályok, adja meg a saját szinkronizált verzióját a <xref:System.Collections.Hashtable>a SyncRoot tulajdonság használatával.</xref:System.Collections.Hashtable> A szinkronizálási kódot kell műveleteket a SyncRoot a <xref:System.Collections.Hashtable>, nem közvetlenül a <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> a</xref:System.Collections.Hashtable> Ez biztosítja, hogy a gyűjtemények más objektumok származó megfelelő működését. Pontosabban, tart fenn a megfelelő szinkronizálási más szállal, amely előfordulhat, hogy egyidejűleg módosítása a <xref:System.Collections.Hashtable>objektum.</xref:System.Collections.Hashtable>       Egy gyűjtemény számbavétele nincs belsőleg egy szál biztonságos eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket.       Az alábbi példakód bemutatja, hogyan zárolni az adatgyűjtést, a SyncRoot a teljes enumerálása során: [!code-cpp [klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)][!code-vb[klasszikus Hashtable.IsSynchronized&#2;. példa](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)][!code-cs[klasszikus Hashtable.IsSynchronized&#2;. példa    ](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Olyan objektum, amely segítségével való hozzáférés szinkronizálása a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Adja vissza, amely egy gyűjtemény telepítéseket számbevevőre."
  remarks: "[A Visual Basic, a C#]       A `foreach` utasítás a C# nyelv (`for each` a Visual Basic nyelvben) elrejti a enumerálók összetettsége.  Ezért használatával `foreach` ajánlott, az adatbázis közvetlen módosítása az enumerátor helyett.       Enumerálók beolvasni az adatokat a gyűjtemény használható, de nem használható az alapul szolgáló gyűjtemény módosításához.       Kezdetben a számbavevő a gyűjtemény első eleme elé. <xref:System.Collections.IEnumerator.Reset%2A>is jelent a számbavevő vissza az ebben a helyzetben.</xref:System.Collections.IEnumerator.Reset%2A> At ez elhelyezése, hívja <xref:System.Collections.IEnumerator.Current%2A>kivételt jelez.</xref:System.Collections.IEnumerator.Current%2A> Ezért meg kell hívnia <xref:System.Collections.IEnumerator.MoveNext%2A>ahhoz, hogy a számbavevő a <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> értékének olvasása előtt a gyűjtemény első eleme</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>az azonos objektumot ad vissza, amíg újra nem indítják <xref:System.Collections.IEnumerator.MoveNext%2A>vagy <xref:System.Collections.IEnumerator.Reset%2A>nevezik.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Beállítja a <xref:System.Collections.IEnumerator.Current%2A>átállítása.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Ha <xref:System.Collections.IEnumerator.MoveNext%2A>gyűjteményének, a számbavevő a gyűjtemény utolsó eleme mögé van elhelyezve fázisok és <xref:System.Collections.IEnumerator.MoveNext%2A>adja vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> A számbavevő ezen a helyen, az ezt követő hívások esetén <xref:System.Collections.IEnumerator.MoveNext%2A>is vissza `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Ha az utolsó irányuló hívás <xref:System.Collections.IEnumerator.MoveNext%2A>visszaadott `false`, hívó <xref:System.Collections.IEnumerator.Current%2A>kivételt jelez.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>Ebben az esetben a gyűjtemény első eleme a hívása <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> követ</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> beállítása       Enumerátor érvényes marad mindaddig, amíg a gyűjtemény változatlan marad. Ha módosítják a gyűjteményhez, hozzáadása, módosítása vagy törlése elemek, például a számbavevő érvénytelenítve lenne, és <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A>egy <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> jelez</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> , vagy hívja a következő Ha a gyűjtemény módosítás közötti <xref:System.Collections.IEnumerator.MoveNext%2A>és <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A>adja vissza az elem, értékűre van állítva, akkor is, ha a számláló már érvénytelenné válik.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       A számbavevő nem rendelkezik kizárólagos hozzáférése a gyűjteményhez; egy gyűjtemény számbavétele ezért alapvetően nem biztonságos szál eljárást. Még ha egy gyűjtemény szinkronizálása, más szálak továbbra is módosíthatja a gyűjteményhez, amely azt eredményezi, a számbavevő a kivételt jelez. Szál biztonsági garantálja a számbavételi művelet során, a gyűjteményt, a teljes felsorolásakor zárolása vagy más szálak által végrehajtott módosítások eredő kivételeket.       Ez a módszer O(1) során."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "Egy <xref:System.Collections.IEnumerator>, amelyek segítségével a gyűjtemény iterációt.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Values
  id: Values
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lekérdezi egy <xref:System.Collections.ICollection>az értékeket tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "Az értékek sorrendjét a <xref:System.Collections.ICollection>nincs megadva, de ugyanabban a sorrendben, mint a hozzá tartozó kulcsok a <xref:System.Collections.ICollection>által visszaadott a <xref:System.Collections.Hashtable.Keys%2A>metódus.</xref:System.Collections.Hashtable.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       A visszaadott <xref:System.Collections.ICollection>Nincs statikus másolatát; ehelyett a <xref:System.Collections.ICollection>hivatkozik vissza az eredeti <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> értékek</xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Ezért megváltozik a <xref:System.Collections.Hashtable>továbbra is megjelennek a <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.Hashtable>       Ez a tulajdonság értékének beolvasása során O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "Egy <xref:System.Collections.ICollection>az értékeket tartalmazó a <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Runtime.Serialization.SerializationException
  isExternal: true
  name: System.Runtime.Serialization.SerializationException
- uid: System.Collections.Hashtable.#ctor
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: true
  name: IEqualityComparer
  nameWithType: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
- uid: System.Collections.IHashCodeProvider
  parent: System.Collections
  isExternal: false
  name: IHashCodeProvider
  nameWithType: IHashCodeProvider
  fullName: System.Collections.IHashCodeProvider
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
- uid: System.Collections.Hashtable.Clear
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
- uid: System.Collections.Hashtable.Clone
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
- uid: System.Collections.Hashtable.comparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
- uid: System.Collections.Hashtable.Contains(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Hashtable.Count
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Hashtable.GetHash(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Collections.Hashtable.hcp
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
- uid: System.Collections.Hashtable.Keys
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
- uid: System.Collections.Hashtable.Remove(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
- uid: System.Collections.Hashtable
  parent: System.Collections
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
- uid: System.Collections.Hashtable.SyncRoot
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Hashtable.Values
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
- uid: System.Collections.Hashtable.#ctor*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable.Hashtable
- uid: System.Collections.Hashtable.Add*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add
  nameWithType: Hashtable.Add
- uid: System.Collections.Hashtable.Clear*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear
  nameWithType: Hashtable.Clear
- uid: System.Collections.Hashtable.Clone*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone
  nameWithType: Hashtable.Clone
- uid: System.Collections.Hashtable.comparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
- uid: System.Collections.Hashtable.Contains*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains
  nameWithType: Hashtable.Contains
- uid: System.Collections.Hashtable.ContainsKey*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey
  nameWithType: Hashtable.ContainsKey
- uid: System.Collections.Hashtable.ContainsValue*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue
  nameWithType: Hashtable.ContainsValue
- uid: System.Collections.Hashtable.CopyTo*
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo
  nameWithType: Hashtable.CopyTo
- uid: System.Collections.Hashtable.Count*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator
  nameWithType: Hashtable.GetEnumerator
- uid: System.Collections.Hashtable.GetHash*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash
  nameWithType: Hashtable.GetHash
- uid: System.Collections.Hashtable.GetObjectData*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData
  nameWithType: Hashtable.GetObjectData
- uid: System.Collections.Hashtable.hcp*
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item
  nameWithType: Hashtable.Item
- uid: System.Collections.Hashtable.KeyEquals*
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals
  nameWithType: Hashtable.KeyEquals
- uid: System.Collections.Hashtable.Keys*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
- uid: System.Collections.Hashtable.OnDeserialization*
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization
  nameWithType: Hashtable.OnDeserialization
- uid: System.Collections.Hashtable.Remove*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove
  nameWithType: Hashtable.Remove
- uid: System.Collections.Hashtable.Synchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized
  nameWithType: Hashtable.Synchronized
- uid: System.Collections.Hashtable.SyncRoot*
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Hashtable.Values*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
