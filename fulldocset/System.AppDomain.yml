### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Egy alkalmazástartomány, amely egy elszigetelt környezetben, ahol az alkalmazások hajtható végre jelöli. Ez az osztály nem örökölhető."
  remarks: "Az alkalmazástartomány objektumokat képviseli, alkalmazástartományok biztosítható elkülönítést, a memóriából való eltávolítása és a biztonsági határokat a felügyelt kód végrehajtása.      -Alkalmazástartományok használja, előfordulhat, hogy állítsa le a folyamat feladatok elkülönítése. Adó metódus végrehajtása a feladat állapotának instabillá válik, ha az AppDomain is távolítható el a memóriából a folyamat befolyásolása nélkül. Ez akkor fontos, ha a folyamat hosszú ideig kell futnia, újraindítás nélkül. Alkalmazástartományok különítheti el az adatokat nem megosztó feladatokhoz használhatja.      -Ha a szerelvény be töltve az alapértelmezett alkalmazástartomány be, nem lehet memóriából, a művelet végrehajtása közben. Azonban ha megnyit egy második alkalmazástartomány betöltéskor és végrehajtáskor a szerelvény, a szerelvény esetén memóriából adott alkalmazástartomány távolítva a memóriából. Ez a módszer segítségével nagy DLL-ek alkalmanként használó hosszan futó folyamatok munkakészletének minimalizálása érdekében.       Több alkalmazás tartomány futtathat egyetlen folyamat; azonban nincs a követelmények alkalmazástartományok és szálak között. Egy alkalmazástartomány több szál is tartozik, és egy adott szálon nem korlátozódik egyetlen alkalmazástartományt, egy adott időpontban, amíg a szál végrehajtja a egyetlen alkalmazás tartományban.       Alkalmazástartományok használatával hozhatók létre a <xref:System.AppDomain.CreateDomain%2A>metódus.</xref:System.AppDomain.CreateDomain%2A> AppDomain példányok használt betöltéskor és végrehajtáskor szerelvények (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Ha egy AppDomain tartományban már nincs használatban, is távolítható el a memóriából.       Az AppDomain osztály megvalósítja az eseményeket, amelyek lehetővé teszik az alkalmazások viselkedését, amikor egy szerelvény be van töltve, ha egy alkalmazástartomány el lesz távolítva, vagy ha egy nem kezelt kivétel történt egy készletét.       Alkalmazástartományok használatával kapcsolatos további információkért lásd: [alkalmazástartományok](~/add/includes/ajax-current-ext-md.md).       Ez az osztály megvalósítja a <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, és <xref:System.Security.IEvidenceFactory>felületek.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       Soha ne hozzon létre egy távolról használható burkoló alkalmazástartomány objektumhoz. Így sikerült közzétenni, hogy AppDomain, ilyen például a módszerek távoli hivatkozást <xref:System.AppDomain.CreateInstance%2A>távelérési és hatékonyan megsemmisítése kódelérés-biztonsági az adott AppDomain.</xref:System.AppDomain.CreateInstance%2A> A távvezérlés AppDomain csatlakozó rosszindulatú ügyfeleket sikerült férhet hozzá bármilyen olyan erőforrás hozzáfér az AppDomain magát. Ne hozzon létre a távolról használható burkolóit a(z) bármilyen, amely kiterjeszti a <xref:System.MarshalByRefObject>, amely megvalósítja a rosszindulatú ügyfelek által a biztonsági rendszer megkerülésére használható módszerek és.</xref:System.MarshalByRefObject>      > [!CAUTION] > Az alapértelmezett érték a <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>tulajdonság `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Ez a beállítás nem biztonságos szolgáltatások. Szolgáltatások részben megbízható kód letöltése érdekében ez a tulajdonság beállítása `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Az aktiválási környezet lekérdezi az aktuális alkalmazás tartományhoz."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Az aktiválási környezet aktuális alkalmazástartományhoz képviselő objektumot vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nincs aktiválási környezet a tartomány-e."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott könyvtárnév hozzáfűzi a titkos útvonalak listájában."
  remarks: "Ez a tulajdonság használata nem ajánlott, mert az lehet, hogy a vizsgálathoz használt elérési utat módosítsa szerelvények követően már betöltött. Használja a <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>tulajdonság helyette.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       A belső elérési út vagy a keresési relatív elérési útja, nem a elérési útját, ahol a szerelvény feloldó vizsgálat titkos szerelvények alapkönyvtárának viszonyítva."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "A belső elérési út hozzáfűzendő könyvtár nevét."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az alkalmazáshoz az alkalmazástartományt."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Egy objektum, amely azonosítja az alkalmazást az alkalmazástartományt."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Az alkalmazások és az alkalmazás rendelkezik-e a megbízhatósági szintet, amely lehetővé teszi annak futtatását számára megadott engedélyeket leíró adatokat lekérdezi."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Alkalmazás alkalmazáshoz engedéllyel és megbízhatósági információt beágyazó objektum."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A szerelvény megjelenítendő név házirend alkalmazása utáni beolvasása."
  remarks: "A módszer egy szerelvény veszi ApplyPolicy megjelenítendő nevet, és a házirend utáni megjelenítendő név. Ez akkor hasznos, ha be kell tölteni egy szerelvény, a házirend, mert az csak reflexiós környezetben nem alkalmazza a házirend."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény által megadott formában megjelenített nevet, a &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    return:
      type: System.String
      description: "A szerelvény tartalmazó karakterlánc megjelenített név házirend alkalmazása után."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor egy szerelvény be töltve."
  remarks: "A <xref:System.AssemblyLoadEventHandler>delegálni, az az esemény azt jelzi, hogy milyen szerelvény be van töltve.</xref:System.AssemblyLoadEventHandler>       Ez az esemény eseménykezelő regisztrálásához rendelkeznie kell a szükséges engedélyekkel, vagy egy <xref:System.Security.SecurityException>vált ki.</xref:System.Security.SecurityException>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor egy szerelvény feloldása sikertelen."
  remarks: "A felelőssége a <xref:System.ResolveEventHandler>ezt az eseményt a szerelvény vissza, amely megadja a <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>tulajdonság, vagy adjon vissza null értéket, ha a szerelvény nem ismerhető fel.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> A szerelvény betöltve ebbe a végrehajtási környezet; kell lennie. Ha azt tölti be a csak reflexiós környezetben, a terhelés, ami miatt a eseményre sikertelen lesz.       Ez az esemény használatára vonatkozó útmutatásért lásd: [feloldása szerelvény terhelések](~/add/includes/ajax-current-ext-md.md).       Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>tulajdonság adja vissza, amely nem oldható fel a szerelvény betöltése a kért szerelvény.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Például a betöltő nem tölthető be a kérelmező szerelvény függősége, mert a kérelmező szerelvényt és a hozzá tartozó függőségek nem találhatók a vizsgálathoz használt elérési út lehet. Ismerete, a kérelmező szerelvény identitása akkor lehet hasznos a függőség kereséséhez vagy azonosítható a megfelelő verzióját, ha egynél több függőség verziója érhető el. További információkért lásd: <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Verziótól kezdve a [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], a <xref:System.ResolveEventHandler>egy esemény jelenik meg az összes szerelvényben, beleértve az erőforrás-szerelvényeket.</xref:System.ResolveEventHandler> A korábbi verziókban az esemény nem időpontja erőforrás szerelvények. Ha az operációs rendszer honosítva van, a kezelő neve lehet többször: minden kulturális környezet visszaváltási láncában egy alkalommal.       Ezt az eseményt a <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>tulajdonság a szerelvény nevét adja vissza, a házirend alkalmazása előtt.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Egynél több eseményleíró regisztrálva van az eseményhez, ha az esemény handlersarecalled ahhoz, amíg egy eseménykezelő értéket ad vissza, amely nem `null`. Az eseménykezelők későbbi figyelmen kívül lesznek hagyva.       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a alapkönyvtárának, amelyeket a szerelvény feloldó szerelvények mintavételi használ."
  remarks: "Ennek a tulajdonságnak felel meg a <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>tulajdonság.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Azt is beolvashatók használatával a <xref:System.AppDomain.GetData%2A>metódus a következő karakterláncot: &quot;alkalmazás GYÖKÉRKÖNYVTÁRÁN&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "A alapkönyvtárának, amelyeket a szerelvény feloldó szerelvények mintavételi használ."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Alaphelyzetbe állítja az elérési utat, az üres karakterlánc titkos szerelvények elérési útja (&quot;&quot;)."
  remarks: "A privát elérési út egy, amelyek a közös nyelvi futtatókörnyezet keres titkos összeállításokat alapkönyvtárának viszonyítva.       További információkért lásd: <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Alaphelyzetbe állítja az üres karakterlánc árnyékmásolat szerelvények tartalmazó könyvtárak listája (&quot;&quot;)."
  remarks: "Az árnyékmásolat másolása elérési út árnyékmásolat szerelvények másolatának tárolására könyvtárainak listáját tárolja.       További információkért lásd: <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>és [árnyékmásolat másolása szerelvények](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott COM-típusú. A paraméterek meg a típust tartalmazó szerelvény tartalmazó fájl neve és a típus neve."
  remarks: "Ezt a módszert objektumok létrehozásához távolról anélkül, hogy helyileg a típus betöltésekor.       A visszatérési érték nem lehet burkolatlan valódi objektum elérésére.       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> attribútum értéke az `true` kell alkalmazni kifejezetten vagy alapértelmezés szerint a COM típus a metódus az adott típusú; példány létrehozásához egyébként <xref:System.TypeLoadException>vált ki.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Egy szerelvény, amely meghatározza a kérelmezett típust tartalmazó fájl neve."
    - id: typeName
      type: System.String
      description: "A kért típus neve."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "A típus nem tölthető be."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs nyilvános paraméter nélküli konstruktor található."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>absztrakt osztály van.       – vagy – a tag egy késői kötés mechanizmus lett meghívva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>üres karakterlánc (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "A COM-objektum az említett <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott COM-típusú. A paraméterek meg a típust tartalmazó szerelvény tartalmazó fájl neve és a típus neve."
  remarks: "Ezt a módszert objektumok létrehozásához távolról anélkül, hogy helyileg a típus betöltésekor.       A visszatérési érték nem lehet burkolatlan valódi objektum elérésére.       A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>attribútum értéke az `true` kell alkalmazni kifejezetten vagy alapértelmezés szerint a COM típus a metódus az adott típusú; példány létrehozásához egyébként <xref:System.TypeLoadException>vált ki.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Egy szerelvény, amely meghatározza a kérelmezett típust tartalmazó fájl neve."
    - id: typeName
      type: System.String
      description: "A kért típus neve."
    - id: hashValue
      type: System.Byte[]
      description: "A számított kivonat kód értékét jelöli."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "A szerelvény jegyzékének által használt kivonatoló algoritmus jelöli."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "A típus nem tölthető be."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs nyilvános paraméter nélküli konstruktor található."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>absztrakt osztály van.       – vagy – a tag egy késői kötés mechanizmus lett meghívva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>az üres karakterlánc (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "A COM-objektum az említett <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott névvel."
  remarks: "A `friendlyName` paraméter az célja, hogy olyan módon, hogy az emberek kifejező tartományának azonosításához. Ez a karakterlánc felhasználói felületek megjelenítéshez megfelelő legyen.       Ez a módszer túlterhelés használja a <xref:System.AppDomainSetup>az alapértelmezett alkalmazástartomány adatait.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott névvel, a megadott bizonyító adatok használatával."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve. Ez a név olvasható felhasználói felületek tartományának azonosításához. További információkért lásd: <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Arra vonatkozóan, hogy létrehozza a kódot, amely futtatja az alkalmazás identitását. Adjon át <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az aktuális alkalmazás tartomány tanúsítás használata."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott név, a bizonyító adatok és a telepítő tartományadatokat alkalmazás használatával."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve. Ez a név olvasható felhasználói felületek tartományának azonosításához. További információkért lásd: <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Arra vonatkozóan, hogy létrehozza a kódot, amely futtatja az alkalmazás identitását. Adjon át <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az aktuális alkalmazás tartomány tanúsítás használata."
    - id: info
      type: System.AppDomainSetup
      description: "Egy objektum, amely tartalmazza az alkalmazás tartományadatokat inicializálása."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott név, bizonyító adatok, alkalmazás telepítő tartományadatokat, alapértelmezett engedélyek beállítása és teljesen megbízható szerelvények tömbje."
  remarks: "Meg kell adni a <xref:System.AppDomainSetup.ApplicationBase%2A>tulajdonsága a <xref:System.AppDomainSetup>objektum, amely hozzá kell adni az `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> Ellenkező esetben a rendszer kivételt hoz létre.       Ha `securityInfo` értéke nincs megadva, az az aktuális tartományból alkalmazás bizonyító adatok alapján történik.       A megadott információkat `grantSet` és `fullTrustAssemblies` hozhatók létre egy <xref:System.Security.Policy.ApplicationTrust>objektumot az új alkalmazás tartomány.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve. Ez a név olvasható felhasználói felületek tartományának azonosításához. További információkért lásd: <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*> leírása"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Arra vonatkozóan, hogy létrehozza a kódot, amely futtatja az alkalmazás identitását. Adjon át <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az aktuális alkalmazás tartomány tanúsítás használata."
    - id: info
      type: System.AppDomainSetup
      description: "Egy objektum, amely tartalmazza az alkalmazás tartományadatokat inicializálása."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Alapértelmezett engedélycsoport, amely rendelkeznek az összes szerelvényben betölti az új alkalmazás-tartomány, amely nem rendelkezik konkrét biztosít."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "A szerelvények teljesen figyelembe kell venni képviselő erős nevének tömbjét megbízható az új alkalmazás tartományban."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Az alkalmazás a tartomány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       – vagy – a <xref:System.AppDomainSetup.ApplicationBase*>tulajdonság nincs beállítva a <xref href=&quot;System.AppDomainSetup&quot;> </xref> objektum, amely a megadott <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott névvel, bizonyító adatok, alap elérési útja, keresési relatív elérési utat és egy paraméter, amely megadja, hogy egy szerelvény árnyékmásolatát kell betölteni az alkalmazástartomány használatával."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve. Ez a név olvasható felhasználói felületek tartományának azonosításához. További információkért lásd: <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Arra vonatkozóan, hogy létrehozza a kódot, amely futtatja az alkalmazás identitását. Adjon át <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az aktuális alkalmazás tartomány tanúsítás használata."
    - id: appBasePath
      type: System.String
      description: "A alapkönyvtárának, amelyeket a szerelvény feloldó szerelvények mintavételi használ. További információkért lásd: <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Az elérési útját, ahol kell mintavételi a szerelvény feloldó titkos szerelvények alapkönyvtárának viszonyítva. További információkért lásd: <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Ha <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, az alkalmazástartomány-bA betöltött szerelvény árnyékmásolatának elkészítésére."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Új tartományt hoz létre alkalmazást a megadott névvel, bizonyító adatok, alap elérési útja, keresési relatív elérési utat és egy paraméter, amely megadja, hogy egy szerelvény árnyékmásolatát kell betölteni az alkalmazástartomány használatával. A visszahívási metódus az alkalmazástartomány inicializálása hív meg, és a karakterlánc argumentumokat visszahívási metódus tömbjét adja meg."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "A tartomány rövid neve. Ez a név olvasható felhasználói felületek tartományának azonosításához. További információkért lásd: <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Arra vonatkozóan, hogy létrehozza a kódot, amely futtatja az alkalmazás identitását. Adjon át <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> az aktuális alkalmazás tartomány tanúsítás használata."
    - id: appBasePath
      type: System.String
      description: "A alapkönyvtárának, amelyeket a szerelvény feloldó szerelvények mintavételi használ. További információkért lásd: <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Az elérési útját, ahol kell mintavételi a szerelvény feloldó titkos szerelvények alapkönyvtárának viszonyítva. További információkért lásd: <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>egy szerelvény árnyékmásolatát betölthető az alkalmazástartományt."
    - id: adInit
      type: System.AppDomainInitializer
      description: "Egy <xref href=&quot;System.AppDomainInitializer&quot;> </xref> egy visszahívási metódus meghívásához mikor jelölő delegált az új <xref href=&quot;System.AppDomain&quot;> </xref> objektum inicializálása."
    - id: adInitArgs
      type: System.String[]
      description: "A karakterlánc argumentumok a visszahívás által képviselt átadandó tömbjét `adInit`, ha az új <xref href=&quot;System.AppDomain&quot;> </xref> objektum inicializálása."
    return:
      type: System.AppDomain
      description: "Az újonnan létrehozott alkalmazástartományt."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvényben definiált."
  remarks: "Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName>       CreateInstance hívni a célként megadott alkalmazástartományt, amely nincs az aktuális alkalmazás tartomány kísérlet a szerelvény a célként megadott alkalmazástartományt a sikeres terhelést eredményez. Mivel egy <xref:System.Reflection.Assembly>nem <xref:System.MarshalByRefObject>, amikor ez a módszer próbálja elküldeni a <xref:System.Reflection.Assembly>a betöltött szerelvény az aktuális alkalmazás tartományhoz, a közös nyelvi futtatókörnyezet megkísérli a szerelvény betöltése az aktuális alkalmazástartományt, és a betöltés sikertelen lehet.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Az aktuális alkalmazástartomány-bA betöltött szerelvény, amely először betöltődött, ha a két alkalmazás tartományok az elérési út beállításai eltérnek a szerelvényből eltérő lehet."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvényben definiált. A paraméter aktiválási attribútumok tömbjét adja meg."
  remarks: "Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName>       Hívására tett kísérlet <xref:System.AppDomain.CreateInstance%2A>egy cél, amely nincs az aktuális alkalmazás tartomány alkalmazástartomány eredményez a szerelvény a célként megadott alkalmazástartományt a sikeres betöltése.</xref:System.AppDomain.CreateInstance%2A> Mivel egy <xref:System.Reflection.Assembly>nem <xref:System.MarshalByRefObject>, amikor ez a módszer próbálja elküldeni a <xref:System.Reflection.Assembly>a betöltött szerelvény az aktuális alkalmazás tartományhoz, a közös nyelvi futtatókörnyezet megkísérli a szerelvény betöltése az aktuális alkalmazástartományt, és a betöltés sikertelen lehet.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Az aktuális alkalmazástartomány-bA betöltött szerelvény, amely először betöltődött, ha a két alkalmazás tartományok az elérési út beállításai eltérnek a szerelvényből eltérő lehet."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvényben definiált. Paraméterek adja meg a binder, kötési jelzők, konstruktorargumentumokat argumentumoknak és az opcionális aktiválási attribútumok értelmezésére szolgálnak kultúra-specifikus adatait."
  remarks: "Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName>       Hívására tett kísérlet <xref:System.AppDomain.CreateInstance%2A>egy cél, amely nincs az aktuális alkalmazás tartomány alkalmazástartomány eredményez a szerelvény a célként megadott alkalmazástartományt a sikeres betöltése.</xref:System.AppDomain.CreateInstance%2A> Mivel egy <xref:System.Reflection.Assembly>nem <xref:System.MarshalByRefObject>, amikor ez a módszer próbálja elküldeni a <xref:System.Reflection.Assembly>a betöltött szerelvény az aktuális alkalmazás tartományhoz, a közös nyelvi futtatókörnyezet megkísérli a szerelvény betöltése az aktuális alkalmazástartományt, és a betöltés sikertelen lehet.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Az aktuális alkalmazástartomány-bA betöltött szerelvény, amely először betöltődött, ha a két alkalmazás tartományok az elérési út beállításai eltérnek a szerelvényből eltérő lehet."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumokat a következőt reflexió használatával.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – <code>assemblyName</code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs a feltételeknek megfelelő konstruktor található."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvényben definiált. Paraméterek adja meg a binder, kötési jelzők, konstruktorargumentumokat argumentumok, aktiválási attribútumok és a típus létrehozásához engedélyezési értelmezésére szolgálnak kulturális környezet-specifikus adatait."
  remarks: "Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName>       Hívására tett kísérlet <xref:System.AppDomain.CreateInstance%2A>egy cél, amely nincs az aktuális alkalmazás tartomány alkalmazástartomány eredményez a szerelvény a célként megadott alkalmazástartományt a sikeres betöltése.</xref:System.AppDomain.CreateInstance%2A> Mivel egy <xref:System.Reflection.Assembly>nem <xref:System.MarshalByRefObject>, amikor ez a módszer próbálja elküldeni a <xref:System.Reflection.Assembly>a betöltött szerelvény az aktuális alkalmazás tartományhoz, a közös nyelvi futtatókörnyezet megkísérli a szerelvény betöltése az aktuális alkalmazástartományt, és a betöltés sikertelen lehet.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Az aktuális alkalmazástartomány-bA betöltött szerelvény, amely először betöltődött, ha a két alkalmazás tartományok az elérési út beállításai eltérnek a szerelvényből eltérő lehet."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumokat a következőt reflexió használatával.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Létrehozásának engedélyezéséhez használt információkat `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány által megadott <code> typeName </code>. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs a feltételeknek megfelelő konstruktor található."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code> securityAttributes </code> kell lennie<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú. A paraméterek meg a szerelvényt, ahol a típus definiálva van, és a típus neve."
  remarks: "Ez a <xref:System.AppDomain.CreateInstance%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> kombináló kényelmi módszer Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName> Tekintse meg a <xref:System.Type.FullName%2A?displayProperty=fullName>formátumát tulajdonság `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Ha elvégezte a metódus egy korai kötésű hívása `M` típusú objektum `T1` CreateInstanceAndUnwrap, amelyek adott vissza, és ez a módszer lehetővé teszi egy korai kötésű hívás típusú objektum módszerre `T2` szerelvényben `C` eltérő az aktuális szerelvény vagy tartalmazó szerelvény `T1`, szerelvény `C` be töltve az aktuális alkalmazás tartományába. Ez betöltésekor következik be, akkor is, ha a korai kötésű hívása `T1.M()` törzsében történt egy <xref:System.Reflection.Emit.DynamicMethod>, vagy más dinamikusan generált kódot.</xref:System.Reflection.Emit.DynamicMethod> Ha az aktuális tartomány nem az alapértelmezett tartomány, a szerelvény `C` nem távolítható el a memóriából, amíg a folyamat befejeződik. Ha az aktuális tartomány később próbálja meg szerelvény betöltése `C`, a betöltés sikertelen lehet."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    return:
      type: System.Object
      description: "A megadott objektum egy példányát <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú. A paraméterek meg a szerelvényt, ahol a típus meg van adva, a típus neve és aktiválási attribútumok tömbjét."
  remarks: "Ez a <xref:System.AppDomain.CreateInstance%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> kombináló kényelmi módszer Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName> Tekintse meg a <xref:System.Type.FullName%2A?displayProperty=fullName>formátumát tulajdonság `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Ha elvégezte a metódus egy korai kötésű hívása `M` típusú objektum `T1` adott vissza, amely <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, ezért úgy tűnik, hogy metódus egy korai kötésű hívás típusú objektum módszerre `T2` szerelvényben `C` eltérő az aktuális szerelvény vagy tartalmazó szerelvény `T1`, szerelvény `C` be töltve az aktuális alkalmazás tartományába.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ez betöltésekor következik be, akkor is, ha a korai kötésű hívása `T1.M()` törzsében történt egy <xref:System.Reflection.Emit.DynamicMethod>, vagy más dinamikusan generált kódot.</xref:System.Reflection.Emit.DynamicMethod> Ha az aktuális tartomány nem az alapértelmezett tartomány, a szerelvény `C` nem távolítható el a memóriából, amíg a folyamat befejeződik. Ha az aktuális tartomány később próbálja meg szerelvény betöltése `C`, a betöltés sikertelen lehet."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Object
      description: "A megadott objektum egy példányát <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típus megadása, hogy a rendszer figyelmen kívül hagyja a kis-és a típusnév; a megadott szerelvényben definiált a kötelező attribútumok és a binder, amely segítségével válassza ki a létrehozandó; a konstruktor; argumentumok a kulturális környezet; és az aktiválási attribútumok."
  remarks: "Ez a <xref:System.AppDomain.CreateInstance%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> kombináló kényelmi módszer       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName> Tekintse meg a <xref:System.Type.FullName%2A?displayProperty=fullName>formátumát tulajdonság `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Ha elvégezte a metódus egy korai kötésű hívása `M` típusú objektum `T1` adott vissza, amely <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, ezért úgy tűnik, hogy metódus egy korai kötésű hívás típusú objektum módszerre `T2` szerelvényben `C` eltérő az aktuális szerelvény vagy tartalmazó szerelvény `T1`, szerelvény `C` be töltve az aktuális alkalmazás tartományába.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ez betöltésekor következik be, akkor is, ha a korai kötésű hívása `T1.M()` törzsében történt egy <xref:System.Reflection.Emit.DynamicMethod>, vagy más dinamikusan generált kódot.</xref:System.Reflection.Emit.DynamicMethod> Ha az aktuális tartomány nem az alapértelmezett tartomány, a szerelvény `C` nem távolítható el a memóriából, amíg a folyamat befejeződik. Ha az aktuális tartomány később próbálja meg szerelvény betöltése `C`, a betöltés sikertelen lehet."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumokat a következőt reflexió használatával.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "A annak a szabályozására, a kényszerítési típusú használt kulturális környezet-specifikus objektum. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> az aktuális szál használja a rendszer."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum. amely megadja, hogy az URL-cím szükséges ahhoz, hogy a távoli objektumok aktiválása.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Object
      description: "A megadott objektum egy példányát <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs a feltételeknek megfelelő konstruktor található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – <code>assemblyName</code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú. Paraméterek adja meg a típusát, és hogyan van található, és létre nevét."
  remarks: "Ez a <xref:System.AppDomain.CreateInstance%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> kombináló kényelmi módszer       Lásd: <xref:System.Reflection.AssemblyName>formátumát `assemblyName`.</xref:System.Reflection.AssemblyName> Tekintse meg a <xref:System.Type.FullName%2A?displayProperty=fullName>formátumát tulajdonság `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Ha elvégezte a metódus egy korai kötésű hívása `M` típusú objektum `T1` adott vissza, amely <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, ezért úgy tűnik, hogy metódus egy korai kötésű hívás típusú objektum módszerre `T2` szerelvényben `C` eltérő az aktuális szerelvény vagy tartalmazó szerelvény `T1`, szerelvény `C` be töltve az aktuális alkalmazás tartományába.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ez betöltésekor következik be, akkor is, ha a korai kötésű hívása `T1.M()` törzsében történt egy <xref:System.Reflection.Emit.DynamicMethod>, vagy más dinamikusan generált kódot.</xref:System.Reflection.Emit.DynamicMethod> Ha az aktuális tartomány nem az alapértelmezett tartomány, a szerelvény `C` nem távolítható el a memóriából, amíg a folyamat befejeződik. Ha az aktuális tartomány később próbálja meg szerelvény betöltése `C`, a betöltés sikertelen lehet."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumokat a következőt reflexió használatával.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "A annak a szabályozására, a kényszerítési típusú használt kulturális környezet-specifikus objektum. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> az aktuális szál használja a rendszer."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Létrehozásának engedélyezéséhez használt információkat `typeName`."
    return:
      type: System.Object
      description: "A megadott objektum egy példányát <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs a feltételeknek megfelelő konstruktor található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>nem található a <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívónak nincs engedélye a hívja meg ezt a konstruktort."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Az alapértelmezett konstruktor `typeName` hívják.       További információkért lásd: a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       A CreateInstanceFrom metódus használatával hozzon létre egy példányt a cél alkalmazás eltérő tartományban van, alkalmazás, amelyből a rendszer telefonhívást indít, amikor a szerelvény be töltve a célként megadott alkalmazástartományt. Azonban ha a példány burkolatlan a hívó alkalmazás tartományban, a burkolatlan bizonyos módokon példánnyal okozhat a szerelvény betöltése a hívó alkalmazás tartományába. Például a példány burkolatlan, miután a típus adatainak kérheti, ahhoz, hogy a metódushívások késői kötésű. A szerelvény be töltve a hívó alkalmazás tartományba, ha kivétel fordulhat elő.      -Ha ugyanaz a szerelvény egy másik verziója korábban betöltött a hívó alkalmazás tartományba, vagy ha a hívó alkalmazástartomány betöltési elérési útját, mint a célként megadott alkalmazástartományt, kivételek eltérő <xref:System.MissingMethodException>akkor fordulhat elő.</xref:System.MissingMethodException>      -Ha a hívó alkalmazás tartomány lehetővé teszi a korai kötésű hívások sablonpéldány típusúvá <xref:System.InvalidCastException>is okozhat, ha kísérlet történik a példányt.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A név, beleértve a, a fájl elérési útját, amely tartalmazza a szerelvényt, amely meghatározza a kért típusra. A szerelvény be van töltve, használja a <xref:System.Reflection.Assembly.LoadFrom*>metódus.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs paraméter nélküli nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Az alapértelmezett konstruktor `typeName` hívják.       Ezzel a módszerrel kapcsolatos további információkért tekintse meg a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Ha a <xref:System.AppDomain.CreateInstanceFrom%2A>metódus használatával hozzon létre egy példányt a cél alkalmazás eltérő tartományban van, alkalmazás, amelyből a rendszer telefonhívást indít, a célként megadott alkalmazástartományt szerelvény be töltve.</xref:System.AppDomain.CreateInstanceFrom%2A> Azonban ha a példány burkolatlan a hívó alkalmazás tartományban, a burkolatlan bizonyos módokon példánnyal okozhat a szerelvény betöltése a hívó alkalmazás tartományába. Például a példány burkolatlan, miután a típus adatainak kérheti, ahhoz, hogy a metódushívások késői kötésű. A szerelvény be töltve a hívó alkalmazás tartományba, ha kivétel fordulhat elő.      -Ha ugyanaz a szerelvény egy másik verziója korábban betöltött a hívó alkalmazás tartományba, vagy ha a hívó alkalmazástartomány betöltési elérési útját, mint a célként megadott alkalmazástartományt, kivételek eltérő <xref:System.MissingMethodException>akkor fordulhat elő.</xref:System.MissingMethodException>      -Ha a hívó alkalmazás tartomány lehetővé teszi a korai kötésű hívások sablonpéldány típusúvá <xref:System.InvalidCastException>is okozhat, ha kísérlet történik a példányt.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A név, beleértve a, a fájl elérési útját, amely tartalmazza a szerelvényt, amely meghatározza a kért típusra. A szerelvény be van töltve, használja a <xref:System.Reflection.Assembly.LoadFrom*>metódus.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "További információkért lásd: a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Ha a <xref:System.AppDomain.CreateInstanceFrom%2A>metódus használatával hozzon létre egy példányt a cél alkalmazás eltérő tartományban van, alkalmazás, amelyből a rendszer telefonhívást indít, a célként megadott alkalmazástartományt szerelvény be töltve.</xref:System.AppDomain.CreateInstanceFrom%2A> Azonban ha a példány burkolatlan a hívó alkalmazás tartományban, a burkolatlan bizonyos módokon példánnyal okozhat a szerelvény betöltése a hívó alkalmazás tartományába. Például a példány burkolatlan, miután a típus adatainak kérheti, ahhoz, hogy a metódushívások késői kötésű. A szerelvény be töltve a hívó alkalmazás tartományba, ha kivétel fordulhat elő.      -Ha ugyanaz a szerelvény egy másik verziója korábban betöltött a hívó alkalmazás tartományba, vagy ha a hívó alkalmazástartomány betöltési elérési útját, mint a célként megadott alkalmazástartományt, kivételek eltérő <xref:System.MissingMethodException>akkor fordulhat elő.</xref:System.MissingMethodException>      -Ha a hívó alkalmazás tartomány lehetővé teszi a korai kötésű hívások sablonpéldány típusúvá <xref:System.InvalidCastException>is okozhat, ha kísérlet történik a példányt.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A név, beleértve a, a fájl elérési útját, amely tartalmazza a szerelvényt, amely meghatározza a kért típusra. A szerelvény be van töltve, használja a <xref:System.Reflection.Assembly.LoadFrom*>metódus.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumok reflexió.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – <code>assemblyFile</code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Ezzel a módszerrel kapcsolatos további információkért tekintse meg a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Ha a <xref:System.AppDomain.CreateInstanceFrom%2A>metódus használatával hozzon létre egy példányt a cél alkalmazás eltérő tartományban van, alkalmazás, amelyből a rendszer telefonhívást indít, a célként megadott alkalmazástartományt szerelvény be töltve.</xref:System.AppDomain.CreateInstanceFrom%2A> Azonban ha a példány burkolatlan a hívó alkalmazás tartományban, a burkolatlan bizonyos módokon példánnyal okozhat a szerelvény betöltése a hívó alkalmazás tartományába. Például a példány burkolatlan, miután a típus adatainak kérheti, ahhoz, hogy a metódushívások késői kötésű. A szerelvény be töltve a hívó alkalmazás tartományba, ha kivétel fordulhat elő.      -Ha ugyanaz a szerelvény egy másik verziója korábban betöltött a hívó alkalmazás tartományba, vagy ha a hívó alkalmazástartomány betöltési elérési útját, mint a célként megadott alkalmazástartományt, kivételek eltérő <xref:System.MissingMethodException>akkor fordulhat elő.</xref:System.MissingMethodException>      -Ha a hívó alkalmazás tartomány lehetővé teszi a korai kötésű hívások sablonpéldány típusúvá <xref:System.InvalidCastException>is okozhat, ha kísérlet történik a példányt.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A név, beleértve a, a fájl elérési útját, amely tartalmazza a szerelvényt, amely meghatározza a kért típusra. A szerelvény be van töltve, használja a <xref:System.Reflection.Assembly.LoadFrom*>metódus.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumok reflexió.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Létrehozásának engedélyezéséhez használt információkat `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Olyan objektumot, amely egy burkolót az új példány vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található. Az eredményül kapott értéket kell lennie a burkolatlan valódi objektum elérésére."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code> securityAttributes </code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Ez a példány <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Ez a <xref:System.AppDomain.CreateInstanceFrom%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> kombináló kényelmi módszer Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       További információkért lásd: a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A fájl neve és elérési útja a szerelvény, amely meghatározza a kért típusra."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    return:
      type: System.Object
      description: "A kért objektum vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs paraméter nélküli nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Ez a <xref:System.AppDomain.CreateInstanceFrom%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> kombináló kényelmi módszer Ez a módszer az alapértelmezett konstruktor meghívja `typeName`.       Ezzel a módszerrel kapcsolatos további információkért tekintse meg a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A fájl neve és elérési útja a szerelvény, amely meghatározza a kért típusra."
    - id: typeName
      type: System.String
      description: "A kért típusú, beleértve a névtér, de a szerelvény nem teljesen minősített neve (lásd a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság)."
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Object
      description: "A kért objektum vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs paraméter nélküli nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típus a megadott szerelvény fájlban meghatározott megadása, hogy a rendszer figyelmen kívül hagyja a kis-és a típusnév; a kötelező attribútumok és a binder, amely segítségével válassza ki a létrehozandó; a konstruktor; argumentumok a kulturális környezet; és az aktiválási attribútumok."
  remarks: "Ez a <xref:System.AppDomain.CreateInstanceFrom%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> kombináló kényelmi módszer       Ezzel a módszerrel kapcsolatos további információkért tekintse meg a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A fájl neve és elérési útja a szerelvény, amely meghatározza a kért típusra."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumok reflexió.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    return:
      type: System.Object
      description: "A kért objektum vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – <code>assemblyName</code> a közös nyelvi futtatókörnyezet egy későbbi verziójával fordítottak le, hogy a verzió, amely jelenleg betöltött."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehoz egy új példányt a megadott típusú, a megadott szerelvény fájljában definiált."
  remarks: "Ez a <xref:System.AppDomain.CreateInstanceFrom%2A>és <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> kombináló kényelmi módszer       Ezzel a módszerrel kapcsolatos további információkért tekintse meg a <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metódus.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A fájl neve és elérési útja a szerelvény, amely meghatározza a kért típusra."
    - id: typeName
      type: System.String
      description: "A teljes nevet a kért típusú, többek között a névtér, de nem a szerelvény, amelyet a &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; tulajdonság."
    - id: ignoreCase
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy kell-e a kis-és nagybetűket keresést, vagy nem."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A nulla vagy több, amelyek hatással vannak a keresése bit jelzők kombinációja a `typeName` konstruktor. Ha `bindingAttr` nulla, a kis-és nagybetűket keresési van a nyilvános konstruktor végzik."
    - id: binder
      type: System.Reflection.Binder
      description: "Olyan objektum, amely lehetővé teszi, hogy a kötés argumentum adhatók meg kell adnia, meghívási tagok, és lekérése <xref:System.Reflection.MemberInfo>objektumok reflexió.</xref:System.Reflection.MemberInfo> Ha `binder` értéke null, az alapértelmezett kötő szolgál."
    - id: args
      type: System.Object[]
      description: "Argumentumokat a konstruktor. Az argumentumok a tömb kell felel meg a számot, ahhoz, és írja be a meghívni a konstruktort paramétereit. Ha az alapértelmezett konstruktor részesíti előnyben, `args` egy NULL értékű vagy üres tömbnek kell lennie."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kulturális környezet adatait, amely szabályozza a kényszerítése `args` deklarált formális típusainak a `typeName` konstruktor. Ha `culture` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>az aktuális szál használja a rendszer.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Egy vagy több olyan attribútum, amely részt vehetnek-aktiválási tömbjét. Általában egyetlen tartalmazó tömb <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objektum, amely meghatározza a URL-címet, amely a távoli objektumok aktiválásához szükséges.       Ez a paraméter ügyfél által aktivált objektumok kapcsolódik. Ügyfél aktiválása egy örökölt technológia, amely a visszamenőleges kompatibilitás érdekében megmarad, de nem ajánlott az új fejlesztési. Elosztott alkalmazások Ehelyett használjon Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Létrehozásának engedélyezéséhez használt információkat `typeName`."
    return:
      type: System.Object
      description: "A kért objektum vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha <code> typeName </code> nem található."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A hívó nem adhatók meg aktiválási attribútumok egy objektum, amely nem örököl a <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>nem található."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>nem található a <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nincs megfelelő nyilvános konstruktor található."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "A hívó nem rendelkezik megfelelő engedéllyel a konstruktor hívása."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyName</code> egy későbbi verziójával fordítottak le."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Az aktuális alkalmazás tartomány lekérdezi az aktuális <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "Az aktuális alkalmazás tartományban."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg, a megadott neve vagy a hozzáférési mód dinamikus szerelvényben."
  remarks: "Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A dinamikus szerelvény elérési mód."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott nevet és hozzáférési módban dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési móddal és az egyéni attribútumok dinamikus szerelvényben."
  remarks: "Ez a módszer túlterhelés segítségével attribútumokat, amelyek nem működnek megfelelően, kivéve, ha a rendszer alkalmazza azokat dinamikus szerelvényben létrehozásakor adja meg. Például biztonsági attribútumok, például a <xref:System.Security.SecurityTransparentAttribute>és <xref:System.Security.SecurityCriticalAttribute>nem működnek megfelelően, ha egy dinamikus szerelvény létrehozása után kerül.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Ez a módszer használatával csak dinamikus szerelvény az aktuális alkalmazás tartomány ad meg. Ez a korlátozás kapcsolatos további információkért tekintse meg a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Ez a megjelent a [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A dinamikus szerelvény elérési mód."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "A szerelvény alkalmazandó attribútumok egy enumerálható listája vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nincs attribútum esetén."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési móddal és a tanúsítás használata dinamikus szerelvényben."
  remarks: "Csak a teljesen megbízható hívókat megadhatja a `evidence` <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus meghatározásakor A futtatókörnyezet felelteti meg a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat adjon meg egy null `evidence`. Ha `evidence` van `null`, a futtatókörnyezet másolja át a engedélycsoportok, ez azt jelenti, hogy az aktuális adja meg, és a megtagadási beállítása, a hívó <xref:System.Reflection.Assembly>a dinamikus <xref:System.Reflection.Assembly>múltbeli és jelöli meg a házirend megoldottként.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha a dinamikus <xref:System.Reflection.Assembly>rendszer lemezre menti, későbbi terhelések kap a hely által hozzárendelt házirend alapján biztosít ahol a <xref:System.Reflection.Assembly>lett mentve.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megadott dinamikus szerelvény bizonyító adatok. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód és a tároló könyvtár használatával dinamikus szerelvényben."
  remarks: "Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a könyvtár alapértelmezett értékei az aktuális könyvtárat."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési móddal és az egyéni attribútumok dinamikus szerelvényben, és használja a megadott forrás biztonsági környezetét."
  remarks: "Ez a módszer túlterhelés segítségével attribútumokat, amelyek nem működnek megfelelően, kivéve, ha a rendszer alkalmazza azokat dinamikus szerelvényben létrehozásakor adja meg. Például biztonsági attribútumok, például a <xref:System.Security.SecurityTransparentAttribute>és <xref:System.Security.SecurityCriticalAttribute>nem működnek megfelelően, ha egy dinamikus szerelvény létrehozása után kerül.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Ez a módszer használatával csak dinamikus szerelvény az aktuális alkalmazás tartomány ad meg. Ez a korlátozás kapcsolatos további információkért tekintse meg a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A dinamikus szerelvény elérési mód."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "A szerelvény alkalmazandó attribútumok egy enumerálható listája vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nincs attribútum esetén."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "A biztonsági környezet forrását."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Értékének <code> securityContextSource </code> számbavételi érték érvénytelen."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, a tároló könyvtár és a tanúsítás használata dinamikus szerelvényben."
  remarks: "Csak a teljesen megbízható hívókat megadhatja a `evidence` <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus meghatározásakor A futtatókörnyezet felelteti meg a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat adjon meg egy null `evidence`. Ha `evidence` van `null`, a futtatókörnyezet másolja át a engedélycsoportok, ez azt jelenti, hogy az aktuális adja meg, és a megtagadási beállítása, a hívó <xref:System.Reflection.Assembly>a dinamikus <xref:System.Reflection.Assembly>múltbeli és jelöli meg a házirend megoldottként.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha a dinamikus <xref:System.Reflection.Assembly>rendszer lemezre menti, későbbi terhelések kap a hely által hozzárendelt házirend alapján biztosít ahol a <xref:System.Reflection.Assembly>lett mentve.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a könyvtár alapértelmezett értékei az aktuális könyvtárat."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megadott dinamikus szerelvény bizonyító adatok. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód és az engedélyekre vonatkozó kérései dinamikus szerelvényben."
  remarks: "A megadott engedélykéréseket `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` nem használnak, kivéve, ha a dinamikus szerelvény mentett és a módosítás a memóriába. Engedélyekre vonatkozó kérései megadása tranziens szerelvényben, a program nem menti a lemez egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>metódus, amely bizonyító adatok is a kért engedélyeket, és adjon meg egy <xref:System.Security.Policy.Evidence>objektum.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, a tároló könyvtár és a szinkronizálási beállítás kérése használatával dinamikus szerelvényben."
  remarks: "Ez a módszer túlterhelés segítségével attribútumokat, amelyek nem működnek megfelelően, kivéve, ha a rendszer alkalmazza azokat dinamikus szerelvényben létrehozásakor adja meg. Például biztonsági attribútumok, például a <xref:System.Security.SecurityTransparentAttribute>és <xref:System.Security.SecurityCriticalAttribute>nem működnek megfelelően, ha egy dinamikus szerelvény létrehozása után kerül.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Ha `isSynchronized` van `true`, a következő módszerek egyikét a létrejövő <xref:System.Reflection.Emit.AssemblyBuilder>szinkronizálja: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, és <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Ha ezek a módszerek közül kettő a különböző szálakon nevezik, egy letiltja a másik befejeződéséig."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A dinamikus szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, az aktuális könyvtárat használja."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a modulok, típusok és a dinamikus szerelvényben; tagok létrehozását szinkronizálása Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "A szerelvény alkalmazandó attribútumok egy enumerálható listája vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nincs attribútum esetén."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, a tanúsítás és az engedélyekre vonatkozó kérései dinamikus szerelvényben."
  remarks: "A megadott engedélykéréseket `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` használata csak akkor, ha `evidence` is rendelkezik, vagy ha a dinamikus szerelvény mentése és a módosítás a memóriába.      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>       Csak a teljesen megbízható hívókat megadhatja a `evidence` <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus meghatározásakor A futtatókörnyezet felelteti meg a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat adjon meg egy null `evidence`. Ha `evidence` van `null`, a futtatókörnyezet másolja át a engedélycsoportok, ez azt jelenti, hogy az aktuális adja meg, és a megtagadási beállítása, a hívó <xref:System.Reflection.Assembly>a dinamikus <xref:System.Reflection.Assembly>múltbeli és jelöli meg a házirend megoldottként.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha a dinamikus <xref:System.Reflection.Assembly>rendszer lemezre menti, későbbi terhelések kap a hely által hozzárendelt házirend alapján biztosít ahol a <xref:System.Reflection.Assembly>lett mentve.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megadott dinamikus szerelvény bizonyító adatok. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, a tároló könyvtár és az engedélyekre vonatkozó kérései dinamikus szerelvényben."
  remarks: "A megadott engedélykéréseket `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` nem használnak, kivéve, ha a dinamikus szerelvény mentett és a módosítás a memóriába. Engedélyekre vonatkozó kérései megadása tranziens szerelvényben, a program nem menti a lemez egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>metódus, amely bizonyító adatok is a kért engedélyeket, és adjon meg egy <xref:System.Security.Policy.Evidence>objektum.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy egy túlterhelése sem használja a <xref:System.AppDomain.DefineDynamicAssembly%2A>módszer, amelynek a tanúsítás és engedélyeket, adja meg a kívánt rendelkezik, és a dinamikus szerelvény igazolnia <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a könyvtár alapértelmezett értékei az aktuális könyvtárat."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, a tároló könyvtár, a bizonyító adatok és az engedélyekre vonatkozó kérései dinamikus szerelvényben."
  remarks: "A megadott engedélykéréseket `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` használata csak akkor, ha `evidence` is rendelkezik, vagy ha a dinamikus szerelvény mentése és a módosítás a memóriába.      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>       Csak a teljesen megbízható hívókat megadhatja a `evidence` <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus meghatározásakor A futtatókörnyezet felelteti meg a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat adjon meg egy null `evidence`. Ha `evidence` van `null`, a futtatókörnyezet másolja át a engedélycsoportok, ez azt jelenti, hogy az aktuális adja meg, és a megtagadási beállítása, a hívó <xref:System.Reflection.Assembly>a dinamikus <xref:System.Reflection.Assembly>múltbeli és jelöli meg a házirend megoldottként.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha a dinamikus <xref:System.Reflection.Assembly>rendszer lemezre menti, későbbi terhelések kap a hely által hozzárendelt házirend alapján biztosít ahol a <xref:System.Reflection.Assembly>lett mentve.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ez a módszer csak dinamikus szerelvény meghatározásához az aktuális alkalmazás tartomány használandó. További információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a könyvtár alapértelmezett értékei az aktuális könyvtárat."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megadott dinamikus szerelvény bizonyító adatok. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott név, a hozzáférési mód, tároló könyvtár, bizonyító adatok, engedélykéréseket és szinkronizálási beállítás kérése dinamikus szerelvényben."
  remarks: "A megadott engedélykéréseket `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` használata csak akkor, ha `evidence` is rendelkezik, vagy ha a dinamikus szerelvény mentése és a módosítás a memóriába.      > [!NOTE] > Kód, amely dinamikus szerelvényekben bocsát ki a fejlesztés során javasoljuk, hogy <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>a `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Beleértve <xref:System.Security.Permissions.SecurityPermissionFlag>a a `refusedPermissions` paraméter biztosítja, hogy a rendszer ellenőrzi a MSIL.</xref:System.Security.Permissions.SecurityPermissionFlag> Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való által igényelt teljesen megbízható kód használata esetén okozhat.</xref:System.Security.SecurityException>       Csak teljesen megbízható hívókat megadhatja a tanúsítás <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus meghatározásakor A futtatókörnyezet felelteti meg a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat kell adnia a `null` a a `evidence` paraméter. Ha `evidence` van `null`, a futtatókörnyezet másolja át a engedélycsoportok, ez azt jelenti, hogy az aktuális adja meg, és a megtagadási beállítása, a hívó <xref:System.Reflection.Assembly>a dinamikus <xref:System.Reflection.Assembly>múltbeli és jelöli meg a házirend megoldottként.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha a dinamikus <xref:System.Reflection.Assembly>rendszer lemezre menti, későbbi terhelések kap a hely által hozzárendelt házirend alapján biztosít ahol a <xref:System.Reflection.Assembly>lett mentve.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Ha `isSynchronized` van `true`, a következő módszerek egyikét a létrejövő <xref:System.Reflection.Emit.AssemblyBuilder>szinkronizálja: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, és <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Ha ezek a módszerek közül kettő nevezzük, a különböző szálakon, egy blokkolja a csak a másik befejeződése után."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A dinamikus szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a könyvtár alapértelmezett értékei az aktuális könyvtárat."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megadott dinamikus szerelvény bizonyító adatok. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a modulok, típusok és a dinamikus szerelvényben; tagok létrehozását szinkronizálása Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Határozza meg a megadott névvel, a hozzáférési mód, tároló könyvtár, bizonyító adatok, engedélyekre vonatkozó kéréseit, szinkronizálási beállítás kérése és egyéni attribútumok dinamikus szerelvényben."
  remarks: "Ez a módszer túlterhelés segítségével attribútumokat, amelyek nem működnek megfelelően, kivéve, ha a rendszer alkalmazza azokat dinamikus szerelvényben létrehozásakor adja meg. Például biztonsági attribútumok, például a <xref:System.Security.SecurityTransparentAttribute>és <xref:System.Security.SecurityCriticalAttribute>nem működnek megfelelően, ha egy dinamikus szerelvény létrehozása után kerül.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       A megadott engedélykéréseket a `requiredPermissions`, `optionalPermissions`, és `refusedPermissions` paramétert kell használni, ha csak a `evidence` paramétert is meg van adva, vagy ha a dinamikus szerelvény mentése és a módosítás a memóriába.      > [!NOTE] > Kódot, amely bocsát ki a dinamikus szerelvényekben fejlesztésekor azt javasoljuk, hogy a <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>megjelölésre kerülnek a `refusedPermissions` paraméter.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Ez a jelző felvételét biztosítja, hogy a köztes nyelv (MSIL) a rendszer ellenőrzi a Microsoft. Ezzel a technikával észlelni fogja a következő ellenőrizhetetlen kódot, amelyek egyébként nagyon nehéz észleléséhez szándékos generációját. Ez a módszer egy korlátozás, hogy is felvet <xref:System.Security.SecurityException>való jelezni, amikor a rendszer által igényelt teljesen megbízható kód.</xref:System.Security.SecurityException>       Csak teljesen megbízható hívókat <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> dinamikus definiálásakor is igazolnia A futtatókörnyezet leképezi a <xref:System.Security.Policy.Evidence>keresztül határozza meg az engedélyeket a biztonsági házirend.</xref:System.Security.Policy.Evidence> Részlegesen megbízható hívókat kell adnia a `null` a a `evidence` paraméter. Ha `evidence` van `null`, a futtatókörnyezet a engedélycsoportok (amelyek, az aktuális grant, és a megtagadási beállítása) átmásolja a hívó szerelvény a dinamikus szerelvény, amely meghatározza a, és megoldottként, jelöli meg a házirend.       Ha a dinamikus szerelvény lemezre, későbbi menti terhelések biztosít a dinamikus szerelvény mentéséhez használt helyet társított házirendek alapján kap.       Ha `isSynchronized` van `true`, a következő módszerek egyikét a létrejövő <xref:System.Reflection.Emit.AssemblyBuilder>szinkronizálja: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, és <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Ha ezek a módszerek közül kettő a különböző szálakon nevezik, egy letiltja a másik befejeződéséig.       Ez a megjelent a [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A dinamikus szerelvény egyedi azonosítója."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "A módot, amelyben dinamikus szerelvény érhető el."
    - id: dir
      type: System.String
      description: "A dinamikus szerelvény szeretné menteni a könyvtár nevét. Ha `dir` van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, az aktuális könyvtárat használja."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A megbizonyosodhat róla, hogy a dinamikus szerelvény van megadva. A bizonyító adatok alapján történik, mint a házirend feloldásához használt bizonyíték a végső készletének változatlan."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "A szükséges engedélyekkel a kérelmet."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "A választható engedélyeket kérhet."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "A visszautasított engedélyeket kérhet."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a modulok, típusok és a dinamikus szerelvényben; tagok létrehozását szinkronizálása Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "A szerelvény alkalmazandó attribútumok egy enumerálható listája vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nincs attribútum esetén."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "A megadott névvel és a szolgáltatások dinamikus szerelvényben."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonsága <code> name </code> szóköz kezdődik, vagy előre vagy hátra perjelet tartalmaz."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A kód végrehajtja a megadott delegált által azonosított egy másik alkalmazás tartományban."
  remarks: '`callBackDelegate`érték adható meg végrehajtásra-által-, <xref:System.MarshalByRefObject>, vagy <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Ez a delegált hívni egy metódust."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a tartomány manager a gazdagép által megadott alkalmazástartományt inicializálásakor."
  remarks: "A közös nyelvi futtatókörnyezet (CLR) egy nem felügyelt gazdagép biztosíthat egy tartomány-kezelőt. A kezelő részt az új alkalmazástartomány inicializálása, és adja meg, mint más vezetőknek egy <xref:System.Security.HostSecurityManager>, a műveletek az alkalmazástartomány részt, amely.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "A tartomány kezelő, a gazdagép által biztosított, ha az alkalmazástartomány lett inicializálva, képviselő objektumot vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha a kezelő nem lett megadva."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor egy <xref href=&quot;System.AppDomain&quot;> </xref> arra készül, hogy távolítható el a memóriából."
  remarks: "A <xref:System.EventHandler>delegálni, az ezt az eseményt hajthat végre lezárást tevékenységeket, mielőtt az alkalmazástartomány eltávolítva.</xref:System.EventHandler>       Minden alkalmazástartomány memóriából esetén feldolgozás elvégzéséhez szüksége van az eseményhez eseménykezelő kell regisztrálni. A megosztott eseménykezelő nem használható, mert a <xref:System.EventHandler>delegált nem határozza meg a tartományt, amelyikhez eltávolítása folyamatban van.</xref:System.EventHandler>      > [!NOTE] > Ezt az eseményt soha nem jelenik meg, az alapértelmezett alkalmazás tartományban.       Ne tegye az esemény akkor következik be, a szál feltételezéseket. Az esemény egy másik szálon eltérő nevű emelhető a <xref:System.AppDomain.Unload%2A>metódus.</xref:System.AppDomain.Unload%2A>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a szerelvény feloldó segítségével dinamikusan létrehozott szerelvények mintavételi könyvtárban."
  remarks: "Beállítani a dinamikus könyvtárát, rendelje hozzá egy alapkönyvtárának elérési útja a <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>tulajdonsága a <xref:System.AppDomainSetup>az alkalmazás új tartomány létrehozásához használt objektum.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> A rendel a tulajdonság alapkönyvtárának elérési útja módosul az egyik alkönyvtár, amelynek egyszerű neve megegyezik a hozzárendelt karakterlánc kivonatkódját hozzáadásával a <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>tulajdonság, ezért a alapkönyvtárának formátuma *eredeti elérési útjának*\\\\*kivonat-kód*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> A dinamikus könyvtár a alapkönyvtárának alkönyvtára. Egyszerű felhasználónevében értéke a <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>tulajdonság, ezért annak formátuma *eredeti elérési útjának*\\\\*kivonatoló kódot*\\\\*alkalmazásnév*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "A szerelvény feloldó segítségével dinamikusan létrehozott szerelvények mintavételi könyvtárban."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> társított az alkalmazástartományt."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "Az alkalmazástartomány társított bizonyító adatok."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a megadott fájlban található a szerelvényben."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Létrehozásához a <xref:System.AppDomain>betöltéskor és végrehajtáskor, használja a <xref:System.AppDomain.CreateDomain%2A>metódus.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A szerelvény a megadott fájlban található a megadott bizonyító adatok használatával hajtja végre."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       A <xref:System.AppDomain.ExecuteAssembly%2A>metódus nem hoz létre egy új folyamat vagy alkalmazástartomány, és azt nem hajtható végre: a belépési pont módszer új szálban.</xref:System.AppDomain.ExecuteAssembly%2A>       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a szerelvény a megadott fájlban található a megadott argumentumokkal."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    - id: args
      type: System.String[]
      description: "A belépési pont a szerelvény argumentumokat."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – <code>assemblyFile</code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A szerelvény a megadott fájlban található a megadott bizonyító adatok és az argumentumok használatával hajtja végre."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A megadott bizonyíték a szerelvényhez."
    - id: args
      type: System.String[]
      description: "A belépési pont a szerelvény argumentumokat."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code>assemblySecurity</code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A szerelvény a megadott fájlban található a megadott argumentumok, a kivonat értéke és a kivonatoló algoritmus használatával hajtja végre."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    - id: args
      type: System.String[]
      description: "A belépési pont a szerelvény argumentumokat."
    - id: hashValue
      type: System.Byte[]
      description: "A számított kivonat kód értékét jelöli."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "A szerelvény jegyzékének által használt kivonatoló algoritmus jelöli."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – <code>assemblyFile</code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A szerelvény a megadott fájlban található a megadott bizonyító adatok, az argumentumok, a kivonat értéke és a kivonatoló algoritmus használatával hajtja végre."
  remarks: "A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Ezt a módszert használó szerelvények betölti a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> Szerelvények használata is végrehajthat a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus, amely betölti a szerelvények használata a <xref:System.Reflection.Assembly.Load%2A>metódus.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "A szerelvény végrehajtásához tartalmazó fájl neve."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A megadott bizonyíték a szerelvényhez."
    - id: args
      type: System.String[]
      description: "A belépési pont a szerelvény argumentumokat."
    - id: hashValue
      type: System.Byte[]
      description: "A számított kivonat kód értékét jelöli."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "A szerelvény jegyzékének által használt kivonatoló algoritmus jelöli."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyFile</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code>assemblySecurity</code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a egy szerelvényt a megjelenített név."
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.       Létrehozásához a <xref:System.AppDomain>betöltéskor és végrehajtáskor, használja a <xref:System.AppDomain.CreateDomain%2A>metódus.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code> assemblyName </code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott szerelvény hajt végre egy <xref:System.Reflection.AssemblyName>, a megadott argumentumokkal.</xref:System.Reflection.AssemblyName>"
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Egy <xref:System.Reflection.AssemblyName>a szerelvény nevét képviselő objektum.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Parancssori argumentumokat a folyamat indításakor."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – <code> assemblyName </code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy szerelvényt a megjelenített név, a megadott bizonyító adatok használatával hajtja végre."
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus nem hoz létre egy új folyamat vagy alkalmazástartomány, és azt nem hajtható végre: a belépési pont módszer új szálban.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Használata esetén a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódust egy <xref:System.Security.Policy.Evidence>paraméter, kódrészletek bizonyító adatok egyesítésekor.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Az argumentumként átadott igazoló adatra a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus felülbírálják a betöltő által átadott igazoló adatra.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code> assemblyName </code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a szerelvényt a megjelenített név, a megadott argumentumokkal."
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Parancssori argumentumokat a folyamat indításakor."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – <code> assemblyName </code> a közös nyelvi futtatókörnyezet verziójú, mint az aktuálisan betöltött későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a megadott szerelvény egy <xref:System.Reflection.AssemblyName>, a megadott tanúsítás és argumentumokkal.</xref:System.Reflection.AssemblyName>"
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.      > [!NOTE] > Használata esetén a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódust egy <xref:System.Security.Policy.Evidence>paraméter, kódrészletek bizonyító adatok egyesítésekor.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Az argumentumként átadott igazoló adatra a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus felülbírálják a betöltő által átadott igazoló adatra.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Egy <xref:System.Reflection.AssemblyName>a szerelvény nevét képviselő objektum.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    - id: args
      type: System.String[]
      description: "Parancssori argumentumokat a folyamat indításakor."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code> assemblyName </code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code>assemblySecurity</code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Végrehajtja a szerelvényt a megjelenített név a megadott tanúsítás és argumentumokkal."
  remarks: "A <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus olyan hasonló funkciókat biztosít a <xref:System.AppDomain.ExecuteAssembly%2A>metódust, de meghatározza a szerelvény megjelenített név alapján vagy <xref:System.Reflection.AssemblyName>, nem pedig fájl helye alapján.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Ezért <xref:System.AppDomain.ExecuteAssemblyByName%2A>összeállításokba betölti a <xref:System.Reflection.Assembly.Load%2A>metódus, nem pedig az a <xref:System.Reflection.Assembly.LoadFile%2A>metódus.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A szerelvény kezdődik végrehajtása a .NET-keretrendszer fejlécben megadott belépési ponton.       Ez a módszer nem hoz létre egy új folyamat vagy egy alkalmazás tartományban, és azt nem hajtható végre: a belépési pont módszer új szálban.      > [!NOTE] > Használata esetén a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódust egy <xref:System.Security.Policy.Evidence>paraméter, kódrészletek bizonyító adatok egyesítésekor.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Az argumentumként átadott igazoló adatra a <xref:System.AppDomain.ExecuteAssemblyByName%2A>metódus felülbírálják a betöltő által átadott igazoló adatra.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    - id: args
      type: System.String[]
      description: "Parancssori argumentumokat a folyamat indításakor."
    return:
      type: System.Int32
      description: "A szerelvény a belépési pont által visszaadott érték."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott szerelvény <code> assemblyName </code> nem található."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A megadott szerelvény <code> assemblyName </code> található, de nem sikerült betölteni."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A megadott szerelvény <code> assemblyName </code> nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code> assemblyName </code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code>assemblySecurity</code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A megadott szerelvény belépési pont sem rendelkezik."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, ha kivétel történik a felügyelt kódban, mielőtt a futtatókörnyezet keres egy kivételkezelőbe hívásverme alkalmazás."
  remarks: "Ez az esemény az csak egy értesítést. Ez az esemény kezelése nem kezelte a kivételt vagy későbbi kivételkezelő valamilyen módon befolyásolják. Miután a rendszer kiváltott esemény, és eseménykezelők meghívták, a közös nyelvi futtatókörnyezet (CLR) fel a kivételt kezelő keresésének megkezdése. FirstChanceException biztosít a felügyelt kivételen megvizsgálni első alkalommal az alkalmazástartományt.       Az esemény alkalmazás tartományonként lehet kezelni. Ha a szál áthalad több alkalmazástartományok hívás végrehajtása közben, az esemény jelenik meg, eseménykezelő, regisztrálva van a közös nyelvi Futtatókörnyezet megkezdése az adott alkalmazás tartományban a megfelelő kivételkezelő keresése előtt minden alkalmazás tartományban. Után az esemény kezelése, a Keresés az adott alkalmazás tartományban a megfelelő kivételkezelő történik. Ha egyik sem található, az esemény jelenik meg, a következő alkalmazás tartományban.       Minden kivétel kezelő FirstChanceException eseménynél az esemény előforduló kell kezelni. Ellenkező esetben a FirstChanceException emelt rekurzív módon. Emiatt a veremtúlcsordulás és az alkalmazás bezárásakor. Azt javasoljuk, hogy megvalósítása eseménykezelők ezt az eseményt a korlátozott végrehajtási régiók (CERs), mint például a kevés memória vagy a verem túlcsordulás infrastruktúrával kapcsolatos kivételeket tartani a virtuális gép befolyásolják a kivétel értesítés feldolgozása közben.       Ez az esemény nem következik kivételekhez, amelyek jelzik a folyamat állapotának hozzáférés megsértése, például sérülés, kivéve, ha az eseménykezelő biztonsági szempontból kritikus fontosságú, és a <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attribútum.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       A közös nyelvi futtatókörnyezet felfüggeszti a szál megszakításainak, amíg az értesítési esemény kezeli."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az alkalmazástartomány rövid nevét."
  remarks: "Az alapértelmezett alkalmazástartomány felhasználóbarát neve a folyamat végrehajtható fájl nevét. Például, ha a végrehajtható fájl a folyamat elindításához használt van `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, a rövid név az alapértelmezett alkalmazástartomány `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "Az alkalmazástartomány rövid neve."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a szerelvényeket, amelyek a végrehajtási környezet az alkalmazástartomány lett betöltve."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Az alkalmazástartomány szerelvényeket tömbjét."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az aktuális szál azonosítója."
  remarks: "Használja a <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>tulajdonság, amely stabil még ha a .NET-keretrendszer által működtetett olyan környezetet, amely támogatja a szálak (Ez azt jelenti, hogy könnyű szál).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "Egy 32 bites előjeles egész szám, amely az aktuális szál azonosítója."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az aktuális alkalmazás tartományban a megadott névhez tárolt érték."
  remarks: "Ezt a módszert használja egy név-adatokat tartalmazó leíró <xref:System.AppDomain>.</xref:System.AppDomain> ezen példánya tulajdonságainak, belső gyorsítótár bejegyzésének értékének beolvasása Vegye figyelembe, hogy a összehasonlítása `name` nevű kulcs-érték párok, a kis-és nagybetűket.       A gyorsítótár automatikusan tartalmazza az előre definiált rendszer bejegyzéseit, amelyek a szúrja be az alkalmazástartomány létrehozása. Az értékek a GetData metódussal, vagy az ezzel egyenértékű csoport vizsgálhatja <xref:System.AppDomainSetup>Tulajdonságok.</xref:System.AppDomainSetup>       Helyezze be, vagy módosítsa a saját felhasználó által definiált név-adatok párokat az a <xref:System.AppDomain.SetData%2A>metódust, és vizsgálja meg az értékeket a GetData metódussal.</xref:System.AppDomain.SetData%2A>       A következő táblázat ismerteti a `name` egyes előre definiált rendszer bejegyzést, és a megfelelő <xref:System.AppDomainSetup>tulajdonság.</xref:System.AppDomainSetup>      | &quot;Name&quot; értékének |} Tulajdonság |}   |---------------------|--------------|   |&quot; ALKALMAZÁS GYÖKÉRKÖNYVTÁRÁN &quot;|} <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;|} <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;|} (nincs tulajdonság)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; jelenti. a felhasználó, mielőtt semmilyen átirányítást eredetileg kért URL-CÍMÉT. Érhető el csak akkor, ha az alkalmazás elindult, például az Internet Explorer böngészőben. Nem minden böngésző ezt az értéket adja meg. |}   |&quot; ALKALMAZÁS_NEVE &quot;|} <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;|} <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;|} <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;|} <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;|} (nincs tulajdonság) |}   |&quot; DISALLOW_APP &quot;|} <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;|} <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;|} <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;|} <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;|} <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;, vagy az alkalmazás-specifikus karakterlánc |} <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;|} <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;|} (nincs tulajdonság) |}   |&quot; PRIVATE_BINPATH &quot;|} <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;|} <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; bejegyzés nem a rendszer, és az értékét a <xref:System.AppDomain.SetData%2A>metódus meghívásával állítható be. |}   |&quot; SHADOW_COPY_DIRS &quot;|} <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "Egy előre meghatározott alkalmazások domain tulajdonság nevét, vagy egy alkalmazás tartomány tulajdonság definiált neve."
    return:
      type: System.Object
      description: "Értékét a <code> name </code> tulajdonság, vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha a tulajdonság nem létezik."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az aktuális példány típusú."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "Az aktuális példány típusa."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az egész szám, amely egyedileg azonosítja a folyamaton belül alkalmazástartományt."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Egész szám, amely azonosítja az alkalmazástartományt."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Biztosítja a <xref href=&quot;System.AppDomain&quot;> </xref> jöjjön létre a címbérlet letiltásával végtelen élettartammal."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a nullázható logikai érték, amely jelzi, hogy megfelelőek-e olyan kompatibilitási kapcsolót, és ha igen, hogy a megadott kompatibilitási kapcsoló meg van adva."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "A kompatibilitási kapcsolóval tesztelheti."
    return:
      type: System.Nullable{System.Boolean}
      description: "Null hivatkozás. (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) Ha nincs kompatibilitási kapcsolók; ellenkező esetben egy logikai érték, amely azt jelzi, hogy a kompatibilitási kapcsoló, amely megadja <code> value </code> van beállítva."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy érték, amely azt jelzi, hogy az alkalmazástartomány az alapértelmezett alkalmazástartomány folyamat adja vissza."
  remarks: "Minden felügyelt folyamat rendelkezik egy alapértelmezett alkalmazástartomány. Az alapértelmezett tartomány végrehajtása kezdődik."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az aktuális <xref href=&quot;System.AppDomain&quot;> </xref> objektum jelöli az alapértelmezett alkalmazástartomány, a folyamat; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Azt jelzi, hogy az alkalmazástartomány memóriából való eltávolítása, és a benne lévő objektumokat a rendszer véglegesítés a közös nyelvi futtatókörnyezet által."
  remarks: "A véglegesítési metódus az objektum minden szükséges törlési műveletek végrehajtásához, az objektumot csak szemétgyűjtő lehetőséget biztosít. Véglegesítés, miután az objektum, elérhető, de érvénytelen állapotú, és ezért nem használható. Végül szemétgyűjtés befejeződik, és úgy szabadít fel a objektum.       Az objektum véglegesítés módszer neve a következő esetekben: során szemétgyűjtés, ha a közös nyelvi futtatókörnyezet a Leállítás fázisában van, vagy ha az alkalmazástartomány, amely tartalmazza az objektum nem található. A IsFinalizingForUnload metódus visszaadja `true` csak az utolsó esetben; visszatérési értéke nem `true` Ha véglegesítés rutin szemétgyűjtés vagy CLR leállítás.      > [!NOTE] > Határozhatja meg, hogy véglegesítés okozza-e CLR leállítás, a <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>tulajdonság.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Azt adja vissza `true` véglegesítés egy alkalmazástartomány eltávolítása folyamatban vagy a közös nyelvi Futtatókörnyezet leállítása esetén.       Végrehajtásakor a véglegesítés metódusban tartomány memóriából való eltávolítása során, érdemes egy másik objektum, amely egy statikus mező által hivatkozott, és egy véglegesítési mód nem érhető el. Azonban Ön nem megbízható megtenni, mert előfordulhat, hogy már már véglegesített a használt objektum.      > [!NOTE] > E szabály alól kivételt a <xref:System.Console>osztályt, amely a statikus mezők adatfolyam objektumok hivatkozó tartalmaz, de van megvalósítva, kifejezetten, így mindig írhat a rendszer konzolt, még a tartomány memóriából való eltávolítása vagy a rendszer leállítás során.</xref:System.Console>       Ezt a módszert egy objektum véglegesítés metódusban annak meghatározásához, hogy az objektumot tartalmazó alkalmazástartományt eltávolítja a memóriából. Ha ez a helyzet, megbízhatóan nem érhetők el véglegesítés metódust tartalmaz, és a statikus mező által hivatkozott objektum."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az alkalmazástartomány memóriából való eltávolítása és a közös nyelvi futtatókörnyezet megkezdődött a befejező; meghívása Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi egy érték, amely azt jelzi, hogy az aktuális alkalmazás tartomány betöltött szerelvények hajtható végre a teljesen megbízható."
  remarks: "Ez a metódus mindig adja vissza `true` az alapértelmezett alkalmazástartomány az asztalon futó alkalmazás számára. Adja vissza, `false` a egy elkülönített alkalmazástartományt, amelyek használatával lett létrehozva a [AppDomain.CreateDomain (String, a tanúsítás, a AppDomainSetup értéknek, a PermissionSet, a StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) metódus túlterhelés, kivéve, ha az alkalmazás tartományhoz biztosított engedélyeket egyenértékűek teljesen megbízható."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az aktuális alkalmazás tartomány betöltött szerelvények végrehajtása során a teljesen megbízható; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy érték, amely azt jelzi, hogy az aktuális alkalmazás tartomány engedélyek egy készletét, amely az összes szerelvényben betöltött, alkalmazástartományt engedélyezett lekérdezi."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az aktuális alkalmazás tartományban homogén engedélykészletüket; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A <xref:System.Reflection.Assembly>közös objektum fájl formátuma (COFF) alapú képének kibocsátott <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> tartalmazó</xref:System.Reflection.Assembly>"
  remarks: "Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], ezzel a módszerrel által betöltött szerelvényt megbízhatósági szintje nem ugyanaz, mint a megbízhatósági szint az alkalmazástartományt.       Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Típusú tömb <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> , amely a COFF-alapú lemezkép tartalmazó kibocsátott szerelvényt."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>rawAssembly</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy <xref:System.Reflection.Assembly>megadott annak <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly> betöltése"
  remarks: "Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ha egy a kért szerelvény verziója már be van töltve, ez a módszer a akkor is, ha egy másik verzió van szükség a betöltött szerelvény adja vissza.       A parancskimenetnél részleges szerelvény nevét `assemblyRef` nem ajánlott. (Egy részleges név kihagyja a kulturális környezet, verziójának vagy nyilvánoskulcs-kivonatnak közül. Addsortproperty() ahelyett, hogy a karakterlánc a egy <xref:System.Reflection.AssemblyName>objektum, &quot;Szerelveny, verzió =&1;.0.0.0&quot; egy példa egy részleges név és &quot;Szerelveny, verzió:&1;.0.0.0, Culture = neutral, PublicKeyToken = =&18;ab3442da84b47&quot; példa a teljes nevet.)</xref:System.Reflection.AssemblyName> Részleges nevekkel egy negatív hatással van a teljesítményre. Emellett egy részleges szerelvénynév is fordított szerelvény betöltésének a globális szerelvény-gyorsítótárból csak, ha a szerelvény az alkalmazás alapkönyvtárának a pontos másolatát (<xref:System.AppDomain.BaseDirectory%2A> vagy <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Ha az aktuális <xref:System.AppDomain>objektum által jelképezett alkalmazástartomány `A`, és a <xref:System.AppDomain.Load%2A>alkalmazástartomány meghívott metódus `B`, a szerelvény be töltve mindkét alkalmazástartományok.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Például a következő kódot terhelések `MyAssembly` az új alkalmazás tartományába `ChildDomain` és is az alkalmazástartományt, ahol a kód végrehajtása: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] mindkét tartomány-bA betöltött szerelvény, mert <xref:System.Reflection.Assembly>nem származik <xref:System.MarshalByRefObject>, és ezért a visszatérési értéke a <xref:System.AppDomain.Load%2A>metódus nem készíthető elő átadásra.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     Ehelyett a közös nyelvi futtatókörnyezet megkísérli a szerelvény betöltése a hívó alkalmazás tartományába. Lehet, hogy a két alkalmazás tartományokat betöltött szerelvények eltérő, ha a két alkalmazás tartományok az elérési út beállításai eltérnek.      > [!NOTE] > Ha mindkét a <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>tulajdonság és a <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>tulajdonság vannak beállítva, az első kísérlet a szerelvény betöltése a megjelenített nevet használ (beleértve a verzió, kulturális környezet, és egyéb, amelyet a <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>tulajdonság).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Ha a fájl nem található, a <xref:System.Reflection.AssemblyName.CodeBase%2A>tulajdonság használatával keresse meg a szerelvényt.</xref:System.Reflection.AssemblyName.CodeBase%2A> Ha a szerelvény található használatával <xref:System.Reflection.AssemblyName.CodeBase%2A>, megjelenített neve egyezik a szerelvény ellen.</xref:System.Reflection.AssemblyName.CodeBase%2A> Az egyeztetés sikertelen, ha egy <xref:System.IO.FileLoadException>vált ki.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Egy objektum, amely leírja a szerelvény betöltése."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyRef</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Terhelések egy <xref:System.Reflection.Assembly>a megjelenítendő nevet kapnak.</xref:System.Reflection.Assembly>"
  remarks: "Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>van<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyString</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A <xref:System.Reflection.Assembly>közös objektum fájl formátuma (COFF) alapú képének kibocsátott <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> tartalmazó</xref:System.Reflection.Assembly> A nyers bájt szimbólumát képviselő a <xref:System.Reflection.Assembly>is betöltve.</xref:System.Reflection.Assembly>"
  remarks: "Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], ezzel a módszerrel által betöltött szerelvényt megbízhatósági szintje nem ugyanaz, mint a megbízhatósági szint az alkalmazástartományt.       Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Típusú tömb <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> , amely a COFF-alapú lemezkép tartalmazó kibocsátott szerelvényt."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Típusú tömb <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> tartalmazó a szerelvénynek a szimbólumok képviselő nyers bájt."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>rawAssembly</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy <xref:System.Reflection.Assembly>megadott annak <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly> betöltése"
  remarks: "Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Egy objektum, amely leírja a szerelvény betöltése."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>van<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyRef</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Terhelések egy <xref:System.Reflection.Assembly>a megjelenítendő nevet kapnak.</xref:System.Reflection.Assembly>"
  remarks: "Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "A szerelvény megjelenítendő nevét. Lásd: &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>van<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>nem található."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>assemblyString</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A <xref:System.Reflection.Assembly>közös objektum fájl formátuma (COFF) alapú képének kibocsátott <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> tartalmazó</xref:System.Reflection.Assembly> A nyers bájt szimbólumát képviselő a <xref:System.Reflection.Assembly>is betöltve.</xref:System.Reflection.Assembly>"
  remarks: "Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], ezzel a módszerrel által betöltött szerelvényt megbízhatósági szintje nem ugyanaz, mint a megbízhatósági szint az alkalmazástartományt.       Ez a módszer használatával csak egy szerelvény betöltése az aktuális alkalmazástartományt. Ezt a módszert a kényelem előírt együttműködési hívóknak, akik nem hívható meg a statikus <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metódus.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Használja például <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> metódus betöltése szerelvények az alkalmazás tartományához,       Ez a módszer minden túlterhelések közös információkért lásd: a <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metódus túlterhelési.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Típusú tömb <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> , amely a COFF-alapú lemezkép tartalmazó kibocsátott szerelvényt."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Típusú tömb <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> tartalmazó a szerelvénynek a szimbólumok képviselő nyers bájt."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "A szerelvény betöltése a tanúsítás."
    return:
      type: System.Reflection.Assembly
      description: "A betöltött szerelvény."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nincs érvényes szerelvény.       – vagy – 2.0-s vagy újabb, a közös nyelvi futtatókörnyezet verziója jelenleg be van töltve, és <code>rawAssembly</code> egy későbbi verziójával fordítottak le."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Egy szerelvény vagy modul lett betöltve kétszer két különböző esetében."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Ha nincs engedélyezve a hagyományos Kódműködési biztonsági szabályzatot, <code>securityEvidence</code> kell <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi a CPU és memória figyelését alkalmazástartományok engedélyezve van-e az aktuális folyamat számára. Figyelés engedélyezése után a folyamatot nem lehet letiltani."
  remarks: "Ez `static` tulajdonság (`Shared` tulajdonság a Visual Basic nyelvben) szabályozza a CPU és memória az alkalmazás lévő összes tartományban a folyamat megfigyelését.       Ha megpróbál beállítani ezt a tulajdonságot `false`, egy <xref:System.ArgumentException>kivétel történt, még akkor is, ha a tulajdonság aktuális értéke `false`.</xref:System.ArgumentException>       Figyelés engedélyezése után is használhatja a <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, és <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>példány tulajdonságok figyelése egyéni alkalmazás tartományokban CPU és memória használatát.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a figyelés engedélyezett; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Az aktuális folyamat megpróbált érték társítása <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> erre a tulajdonságra."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi, hogy a gyűjtemény utolsó megélték és, hogy ismert, hogy az aktuális alkalmazás tartomány hivatkozhat bájtok száma."
  remarks: "Az egyes szemétgyűjtés frissíti a statisztikáit. Azonban ezek garantáltan pontos csak a teljes, blokkolja a gyűjtemény; után Ez azt jelenti, hogy egy gyűjtemény összes generációt tartalmaz, amely és, hogy leállítja az alkalmazást, miközben gyűjtemény következik be. Például a <xref:System.GC.Collect?displayProperty=fullName>metódus túlterhelési hajt végre teljes, blokkolja a gyűjteményben.</xref:System.GC.Collect?displayProperty=fullName> (Egyidejű gyűjtemény a háttérben történik, és nem blokkolja az alkalmazást.)"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "A fennmaradó bájtok száma."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) <xref:System.AppDomain.MonitoringIsEnabled*>tulajdonsága <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Az összes bájt, amely megélték lekérdezi az összes alkalmazás tartományban, a folyamat utolsó gyűjteményéből."
  remarks: "Egy teljes, blokkoló gyűjtemény után a szám azt jelzi bájtban fenntartott az élő felügyelt halommemória. Hamarosan által jelentett száma meg kell a <xref:System.GC.GetTotalMemory%2A>metódus.</xref:System.GC.GetTotalMemory%2A> Után egy rövid élettartamú gyűjteményt a szám azt jelzi bájtban fenntartott élő a rövid élettartamú generációt."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "A folyamat fennmaradó bájtok száma."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) <xref:System.AppDomain.MonitoringIsEnabled*>tulajdonsága <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a teljes mérete bájtban céladatbázison a létrehozást, nélkül gyűjtött memória az alkalmazás tartomány által végrehajtott összes memória-hozzárendelések."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "Az összes memória kiosztásokat teljes mérete."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) <xref:System.AppDomain.MonitoringIsEnabled*>tulajdonsága <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a teljes processzoridő használt szálak által a folyamat elindítása óta az aktuális alkalmazás tartomány végrehajtása közben."
  remarks: "A fordított időt jelentett egy alkalmazástartomány a feldolgozási idő a folyamat egyes végrehajtási szálai végrehajtása az adott alkalmazás tartományban tartalmaz.       A szál nem felügyelt kódba behívó továbbra is társítva van egy alkalmazástartomány, és a processzoridő töltött a nem felügyelt kód jelent a alkalmazás tartomány, ahol a hívás végrehajtása.       Ha a szál le van tiltva, vagy alvó, akkor ez nem használja a processzor kihasználtsága."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Teljes processzoridő az aktuális alkalmazás tartományhoz."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) <xref:System.AppDomain.MonitoringIsEnabled*>tulajdonsága <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az engedélycsoport az elkülönített alkalmazástartományt."
  remarks: "Elkülönített alkalmazástartományok használatával létrehozott a [AppDomain.CreateDomain (String, a tanúsítás, a AppDomainSetup értéknek, a PermissionSet, a StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) metódus túlterhelési homogén engedélykészletüket rendelkezik; Ez azt jelenti, hogy ugyanazokat az engedélyeket az alkalmazástartomány betöltött összes részlegesen megbízható szerelvényben számára engedélyezett. Egy elkülönített alkalmazástartományt opcionálisan rendelkezik, amelyek mentesülnek ezzel az engedéllyel, állítsa be, és futtathatja a teljesen megbízható szerelvények erős névvel ellátott listáját."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "Elkülönített alkalmazástartományt engedélycsoport."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor az alapértelmezett alkalmazástartomány szülő-folyamat kilép."
  remarks: "A <xref:System.EventHandler>számára ez az esemény hajthat végre a megszakítási tevékenységek, például bezárásával, felszabadítása tárolási és így tovább, a folyamat lejárta előtt.</xref:System.EventHandler>       Verziótól kezdve a .NET-keretrendszer 2.0-s verziója, ez egy esemény jelenik meg minden alkalmazás tartomány regisztrál egy eseménykezelő.      > [!NOTE] > Teljes végrehajtási idejét összes ProcessExit eseménykezelők korlátozódik, ugyanúgy, mint a teljes végrehajtási idejét összes befejező korlátozódik, a folyamat leállítása. Az alapértelmezett érték a két másodperc. Egy nem felügyelt gazdagép meghívásával módosíthatja a végrehajtás ideje a [ICLRPolicyManager::SetTimeout](~/add/includes/ajax-current-ext-md.md) metódust a [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) számbavételi érték.       A .NET-keretrendszer verzióiban 1.0 és 1.1 Ez az esemény csak az alapértelmezett alkalmazástartomány keletkezés, de csak akkor, ha az alapértelmezett alkalmazástartomány eseménykezelő regisztrálva van.       Ez az esemény eseménykezelő regisztrálásához rendelkeznie kell a szükséges engedélyekkel, vagy egy <xref:System.Security.SecurityException>vált ki.</xref:System.Security.SecurityException>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor egy szerelvény feloldása sikertelen csak reflexiós környezetben."
  remarks: "Csak reflexiós környezetben függőségek pedig nem oldja fel automatikusan. Ezek előre feltölti vagy a kezelő az esemény által visszaadott kell. Ez az esemény jelenik meg, ha egy szerelvény már nincs betöltve ebbe a csak reflexiós környezetben függőséggel rendelkezik. Megadja a hiányzó függőség a <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>tulajdonság.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> A <xref:System.ResolveEventHandler>az ezt az eseményt kell visszaadnia, amely eleget tesz a függőség szerelvényt.</xref:System.ResolveEventHandler> A megtalált szerelvény betöltve ebbe a csak reflexiós környezetben kell lennie.      > [!IMPORTANT] > Ez az esemény jelenik meg, csak a Hiányzó függőségek szerelvény tölt be a csak reflexiós környezetben (például használatával a <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>metódus).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Nem jelenik meg, ha tölt szerelvény nem található.       Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>tulajdonság adja vissza, amely nem oldható fel a szerelvény betöltése a kért szerelvény.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> A kérelmező szerelvény identitása ismerete hasznosak lehetnek, a függőség megfelelő verziójának azonosítása, ha egynél több verziója érhető el. További információkért lásd: <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Ezt az eseményt a <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>tulajdonság a szerelvény nevét adja vissza, a házirend alkalmazása előtt.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Visszaadja a szerelvényeket, amelyek az alkalmazástartomány csak reflexiós környezetben lett betöltve."
  remarks: "Ez a módszer a szerelvényt, amely egy csak reflexiós összefüggésben lett betöltve adja vissza. A betöltött szerelvények végrehajtásra, amelyet a <xref:System.AppDomain.GetAssemblies%2A>metódus.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "A tömb <xref:System.Reflection.Assembly>objektumok, amelyek megfelelnek a szerelvényeket betölteni az alkalmazástartomány csak reflexiós környezetben.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Egy művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a alap könyvtárban, ahol a szerelvény feloldó mintavétel kell-e az elérési út titkos szerelvények."
  remarks: "Személyes szerelvények az alkalmazás ugyanazon könyvtárszerkezet lettek telepítve. Ha a RelativeSearchPath tulajdonság által megadott elérési út nem a <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, akkor figyelmen kívül hagyja.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Ez a tulajdonság beállítása <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName> használatával értékét adja vissza."
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "A kiinduló könyvtárban, ahol kell mintavételi a szerelvény feloldó titkos szerelvények elérési útja."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, amikor egy erőforrást a feloldás sikertelen lesz, mivel az erőforrás paraméter nem egy érvényes csatolt vagy beágyazott erőforrás, szerelvény."
  remarks: "<xref:System.ResolveEventHandler>Az eseményhez megpróbálhatja keresse meg az erőforrás tartalmazó szerelvény és vissza azt.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Ez az esemény nem jelenik meg, ha feloldása sikertelen, mert a fájl nem található érvényes csatolt erőforrás. Akkor következik be, ha jegyzékerőforrás adatfolyam nem található, de nem generál, ha egy egyéni erőforrás kulcsa nem található.       Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>tulajdonsága tartalmazza az erőforrás kért szerelvény.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> További információkért lásd: <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Ez az esemény eseménykezelő regisztrálásához rendelkeznie kell a szükséges engedélyekkel, vagy egy <xref:System.Security.SecurityException>vált ki.</xref:System.Security.SecurityException>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Létrehozza az alkalmazástartományt biztonsági házirend szintjét."
  remarks: "Ez a metódus hívása előtt egy szerelvény be töltve a <xref:System.AppDomain>ahhoz, hogy a biztonsági házirend használatához.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "A biztonsági házirend szintet."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "A biztonsági házirend szint már be van állítva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A hely hol a szerelvényeket az árnyékmásolat hoz létre a megadott könyvtár elérési útja."
  remarks: "A gyorsítótár elérési útját. Ha figyelmen kívül hagyja a <xref:System.AppDomainSetup.ApplicationName%2A>tulajdonság nincs beállítva.</xref:System.AppDomainSetup.ApplicationName%2A> Tekintse meg a <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>tulajdonság.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       További információ az árnyékmásolat: [árnyékmásolat másolása szerelvények](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "A teljes elérési útja az árnyékmásolat-példány helye."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott érték társítása a megadott alkalmazás domain tulajdonság."
  remarks: "Bejegyzése szúrható be ezt a módszert használja, vagy módosítsa egy név-adatokat tartalmazó leíró <xref:System.AppDomain>.</xref:System.AppDomain> ezen példánya tulajdonságainak, belső gyorsítótár bejegyzésének értékét       A gyorsítótár automatikusan tartalmazza az előre definiált rendszer bejegyzéseit, amelyek a szúrja be az alkalmazástartomány létrehozása. Nem lehet beszúrni, vagy módosítsa a rendszer bejegyzések ezzel a módszerrel. Módosítható a rendszer megkísérli metódushívások hatástalan; a metódus nem kivételt jelez. Vizsgálhatja meg a rendszer bejegyzések a <xref:System.AppDomain.GetData%2A>metódus, vagy <xref:System.AppDomainSetup>a <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> leírt tulajdonságok</xref:System.AppDomainSetup> egyenértékű</xref:System.AppDomain.GetData%2A> értékei       Hívása ezt a metódust, állítsa be a reguláris kifejezés minták értékeléséhez adjon meg &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; által az alapértelmezett időkorlát értékeként a `name` argumentum és egy <xref:System.TimeSpan>szám, amely az időkorlát értékeként a `data` argumentum.</xref:System.TimeSpan> Is beszúrása vagy módosíthatja a saját felhasználó által definiált név-adatok párok ezzel a módszerrel, és vizsgálja meg az értékeket a <xref:System.AppDomain.GetData%2A>metódus.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "Egy alkalmazás felhasználói domain tulajdonság létrehozására és megváltoztatására neve."
    - id: data
      type: System.Object
      description: "A tulajdonság értékét."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott érték társítása a megadott alkalmazás domain tulajdonság a megadott vonatkozó engedéllyel rendelkező igény szerint a hívó tulajdonság beolvasásakor."
  remarks: "Ezt a módszert szúrható be, illetve módosítsa a saját felhasználói bejegyzések az alkalmazástartomány tulajdonságait leíró neve/adatokat tartalmazó belső gyorsítótárba helyezése. Ha egy bejegyzést, t a rendszer lekéri a belépési engedély igény szerinti is megadhat. Ezenkívül hívása ezt a metódust, állítsa be a reguláris kifejezés minták értékeléséhez adjon meg &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; által az alapértelmezett időkorlát értékeként a `name` argumentum és egy <xref:System.TimeSpan>szám, amely az időkorlát értékeként a `data` argumentum.</xref:System.TimeSpan>       Ez a metódus igény szerinti biztonsági hozzárendelése egy rendszer által meghatározott tulajdonság karakterlánc nem használható.       A gyorsítótár automatikusan tartalmazza az előre definiált rendszer bejegyzéseit, amelyek a szúrja be az alkalmazástartomány létrehozása. Nem lehet beszúrni, vagy módosítsa a rendszer bejegyzések ezzel a módszerrel. Módosítható a rendszer megkísérli metódushívások hatástalan; a metódus nem kivételt jelez. Vizsgálhatja meg a rendszer bejegyzések az értékei a <xref:System.AppDomain.GetData%2A>metódust vagy az ezzel egyenértékű csoport <xref:System.AppDomainSetup>a Megjegyzés részben leírt tulajdonságokkal a <xref:System.AppDomain.GetData%2A>metódus.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "Egy alkalmazás felhasználói domain tulajdonság létrehozására és megváltoztatására neve."
    - id: data
      type: System.Object
      description: "A tulajdonság értékét."
    - id: permission
      type: System.Security.IPermission
      description: "Az engedély iránti igény miatt a hívó tulajdonság beolvasásakor."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Meghatározza azt a rendszer által meghatározott tulajdonság karakterláncot és <code>permission</code> nem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott könyvtár elérési útja létesít alkönyvtárak, ahol az dinamikusan előállított fájlokat tárolja, és elérhető az alap könyvtár."
  remarks: "Ez a módszer a <xref:System.AppDomainSetup.DynamicBase%2A>a belső tulajdonságának <xref:System.AppDomainSetup>ezen példányához tartozó.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "A teljes elérési útja, amely az alkönyvtárak alapkönyvtárának dinamikus szerelvényekben tárolására."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Itt adhatja meg, hogyan egyszerű és identitás objektumok kell csatlakoztatni egy szál a szál a alkalmazás tartomány végrehajtása közben kötést létrehozni egy egyszerű kísérlet után."
  remarks: "Ha az érték csak akkor érvényes, ha a megadott érték használata előtt a <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>tulajdonság.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Például, ha a beállított <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>számára egy megadott tag (például egy általános egyszerű), majd használja a SetPrincipalPolicy módszer beállítása a <xref:System.Security.Principal.PrincipalPolicy>való <xref:System.Security.Principal.PrincipalPolicy>, az aktuális rendszerbiztonsági tag lesz az általános rendszerbiztonsági tag.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Egy a <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> értékeket, amelyeket az elsődleges objektumot szálak csatlakoztatni kívánt típusát határozza meg."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Árnyékmásolat bekapcsolása."
  remarks: "Az árnyékmásolat további információkért lásd: [árnyékmásolat másolása szerelvények](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "A megadott könyvtár elérési útja létesít árnyékmásolatot szerelvények helyeként."
  remarks: "Alapértelmezés szerint árnyékmásolat keresztül probing található összes szerelvényeket tartalmazza. A SetShadowCopyPath metódus által megadott könyvtárak szerelvények korlátozza az árnyékmásolat `path`.       A SetShadowCopyPath metódus nem adja meg a keresendő szerelvények könyvtárakat. Már kell lennie az árnyékmásolat-másolt szerelvényeket kell elhelyezni, a keresési elérési út, például a <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> A SetShadowCopyPath módszer határozza meg, melyik keresési út jogosultak árnyékmásolat-másolása.       Ez a módszer a <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>a belső tulajdonságának <xref:System.AppDomainSetup>ezen példányához tartozó.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Az árnyékmásolat további információkért lásd: [árnyékmásolat másolása szerelvények](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Könyvtár nevét, ahol minden név pontosvesszővel elválasztva listáját."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Beállítja az alapértelmezett principal objektum csatolandó szálak számát, ha azok megkísérlik az ebben a tartományban alkalmazás végrehajtása során rendszerbiztonsági tag kötése."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "Az elsődleges objektumot szálak csatolni."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "A szál rendszerbiztonsági tag már be van állítva."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi a tartomány alkalmazáskonfigurációs adatok erre a példányra."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "Az alkalmazás tartomány inicializálási adatait."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekérdezi az arra utal, hogy, hogy az alkalmazás tartomány úgy van konfigurálva, a fájlok másolása a árnyékmásolat."
  remarks: "További információkért lásd: <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>és [árnyékmásolat másolása szerelvények](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az alkalmazás tartomány úgy van konfigurálva, az árnyék a fájlok másolása; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A művelet egy memóriából alkalmazástartomány kísérletet."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Nevek csoportja van leképezve a feladó azonosítók meg."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetIDsOfNames`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Jövőbeli használatra fenntartva. IID_NULL kell lennie."
    - id: rgszNames
      type: System.IntPtr
      description: "Az átadott a nevének tömbje le kell képezni."
    - id: cNames
      type: System.UInt32
      description: "Le kell képezni a nevek száma."
    - id: lcid
      type: System.UInt32
      description: "A területi beállítás a környezetben, amelyben a nevek értelmezni."
    - id: rgDispId
      type: System.IntPtr
      description: "Hívó lefoglalt tömbből, amely megkapja a nevének megfelelő azonosítók."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Az objektum, amelyek ezután felhasználhatók a típus adatainak illesztőfelület típusú adatainak beolvasása."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetTypeInfo`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "A típus adatainak való visszatéréshez."
    - id: lcid
      type: System.UInt32
      description: "A típus adatainak területibeállítás-azonosító."
    - id: ppTInfo
      type: System.IntPtr
      description: "A kért típusú információk objektum mutató kap."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lekéri a, hogy az objektum tartalmaz (0 vagy 1) típusú információk interfészek száma."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetTypeInfoCount`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Pontok olyan helyre, amely megkapja a objektum által megadott típus információ interfészek száma."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tulajdonságai és metódusai jelennek meg, ha egy objektum hozzáférést biztosít."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::Invoke`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "A tagot azonosítja."
    - id: riid
      type: System.Guid
      description: "Jövőbeli használatra fenntartva. IID_NULL kell lennie."
    - id: lcid
      type: System.UInt32
      description: "A területi beállítás a környezetben használandó argumentumok értelmezhetők."
    - id: wFlags
      type: System.Int16
      description: "A hívás keretében leíró jelzőket."
    - id: pDispParams
      type: System.IntPtr
      description: "Mutató tartalmazó tömb argumentumok argumentum DISPID-azonosítók elnevezett argumentum, és hány példányban a tömb elemeinek száma tömbje struktúrára."
    - id: pVarResult
      type: System.IntPtr
      description: "A helyet, ahol az eredmény tárolható mutat."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Mutatót, amely tartalmazza a kivételek adatai struktúrára."
    - id: puArgErr
      type: System.IntPtr
      description: "Az index az első argumentum, amely azonban hibát tartalmaz."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Beolvassa a karakterlánc-ábrázolása, amely tartalmazza az alkalmazástartomány és bármely Környezetházirendek rövid nevét."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "A literál karakterlánc összefűzésével formátumú karakterlánc &quot;név:&quot;, a rövid név alkalmazástartományt, valamint a helyi házirendek karakterlánc-ábrázolása, vagy a karakterlánc a &quot;Nincsenek környezetházirendek.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Az aktuális által képviselt alkalmazástartományt <xref href=&quot;System.AppDomain&quot;> </xref> lett távolítva a memóriából."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Akkor következik be, ha a típus feloldása sikertelen."
  remarks: "A közös nyelvi futtatókörnyezet nem tudja megállapítani, hogy a kért típusú hozhat létre a szerelvény a TypeResolve esemény következik be. Ez akkor fordulhat elő, ha a típus definiálva van a dinamikus szerelvényben, vagy a típus nincs definiálva a dinamikus szerelvényben, de a futtatókörnyezet nem tudja, melyik szerelvény, a típus definiálva van. Az utóbbi esetben fordulhat elő, amikor <xref:System.Type.GetType%2A?displayProperty=fullName>nevű típus nincs minősítve a szerelvény nevű nevezik.</xref:System.Type.GetType%2A?displayProperty=fullName>       A <xref:System.ResolveEventHandler>számára ez az esemény megpróbálhatja keresse meg és a típus létrehozásához.</xref:System.ResolveEventHandler>       Azonban a TypeResolve esemény nem fordulhat elő, ha a futtatókörnyezet tudja, nincs lehetőség egy típus található az egyes szerelvényben. Például ez az esemény nem fordulhat elő, ha a típus nem található statikus szerelvényben, mert a futtatókörnyezet tudja típusok nem adható hozzá dinamikusan statikus szerelvényeket.       Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>tulajdonsága tartalmazza a kért típus szerelvény.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> További információkért lásd: <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Ez az esemény eseménykezelő regisztrálásához rendelkeznie kell a szükséges engedélyekkel, vagy egy <xref:System.Security.SecurityException>vált ki.</xref:System.Security.SecurityException>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Egy kivétel nem következik be."
  remarks: "Ezt az eseményt a nem kezelt kivételek bejelentése biztosít. Információ a kivételről bejelentkezni, mielőtt a rendszer alapértelmezett kezelő a felhasználó kivételt jelent, és leállít egy alkalmazást az alkalmazás lehetővé teszi. Az alkalmazás állapota elegendő információ áll rendelkezésre, ha más műveleteket is végezhető – például a program újabb helyreállítási adatainak mentése. Célszerű járjon el, mert a program adatok is megsérülhet, amikor a kivételek kezelése nem.      > [!NOTE] > Verzióban a .NET-keretrendszer 1.0 és 1.1, alkalmazás megszüntetésére és a hibakeresési beállításait jelenti a felhasználók számára ez az esemény előtt, nem pedig után.       Ez az esemény, bármely alkalmazás lehet kezelni. Azonban a esemény nem feltétlenül jelenik meg, ahol a kivétel történt a kérelem a tartományban. Kivétel nem kezelt, csak ha a szál teljes verem el nem talált megfelelő kivételkezelő, így a szál származási helyének alkalmazás tartományban van, az első hely is kiváltott esemény.      > [!NOTE] > A .NET Framework 1.0 és 1.1-es verzió, ez az esemény akkor következik be, csak az alkalmazás indításakor a rendszer által létrehozott alapértelmezett alkalmazástartomány. Ha egy alkalmazás további alkalmazástartományok hoz létre, adja meg ezt az eseményt a delegált az alkalmazások tartományokban nincs hatása.       Az alapértelmezett alkalmazástartomány UnhandledException esemény kezelése, ha akkor jelenik meg, nincs bármely szálon, függetlenül attól, milyen alkalmazástartományt, a szál indítása a nem kezelt kivételek. Ha a szál indítása, amely rendelkezik egy eseménykezelő UnhandledException az alkalmazás-tartományban, az esemény jelenik meg, az adott alkalmazás tartományban. Ha adott alkalmazás tartomány nem az alapértelmezett alkalmazástartomány, és nincs is eseménykezelő az alapértelmezett alkalmazástartomány, az esemény jelenik meg, mindkét alkalmazás tartományban.       Például tegyük fel, hogy a szál indításakor alkalmazástartomány &quot;AD1&quot; metódus meghívja az alkalmazástartomány &quot;AD2&quot;, és ott egy metódusát hívja meg az alkalmazástartomány &quot;AD3&quot;, ahol kivételt jelez. Az első alkalmazástartományt, amelyben a UnhandledException esemény emelhető &quot;AD1&quot;. Ha adott alkalmazás tartomány nem az alapértelmezett alkalmazástartomány, az esemény is az alapértelmezett alkalmazás tartományban is generál.      > [!NOTE] > A közös nyelvi futtatókörnyezet felfüggeszti a szál megszakításainak, amíg a UnhandledException esemény eseménykezelőinek állnak végrehajtás alatt.       Az eseménykezelő-e a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>attribútum a megfelelő jelzőkkel, eseménykezelőjét, mintha egy korlátozott végrehajtási területet.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], ez az esemény nem jelenik meg, a kivételeket, amelyek a folyamat állapota sérült, például a verem túlcsordulások vagy nem érhető el megsértése, kivéve, ha az eseménykezelő biztonsági szempontból kritikus fontosságú, és a <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attribútum.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Verzióban a .NET-keretrendszer 1.0 és 1.1 nem kezelt kivételt, amely eltérő a fő alkalmazás szál szálban kiszűri a futtatókörnyezet, és ezért nem okoz az alkalmazás leáll. Így lehetőség az a UnhandledException eseményre az application megszakítása nélkül. A .NET-keretrendszer 2.0-s verziójának verziótól kezdődően ez a gyermek szálak kezeletlen kivételek backstop el lett távolítva, ilyen csendes hibák összesített hatásának teljesítménycsökkenés, sérült adatokat és leállása, amelyek debug nehezen volt része. További információ, beleértve az esetek, amelyben a futtatókörnyezet nem ér véget, listáját: [a szálak kezelt kivételek](~/add/includes/ajax-current-ext-md.md).       Ez az esemény eseménykezelő regisztrálásához rendelkeznie kell a szükséges engedélyekkel, vagy egy <xref:System.Security.SecurityException>vált ki.</xref:System.Security.SecurityException>       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md).      ## Az eseményeket a nem kezelt kivételek az egyes alkalmazás modellek, az esemény is foglalható le az eseményeket, ha a nem kezelt kivétel lép fel a fő alkalmazás szál UnhandledException.       A Windows Forms használó alkalmazásokhoz, nem kezelt kivételek a fő alkalmazás szál ok a <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>eseményre.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Ez az esemény történik, ha az alapértelmezett viselkedés, hogy a nem kezelt kivétel állítsa le az alkalmazást, bár az alkalmazás ismeretlen állapotban marad. Ebben az esetben a UnhandledException esemény nem jelenik meg. Ez a viselkedés módosíthatja az alkalmazás konfigurációs fájljában, vagy a <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>metódus módosítása a módot <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>előtt <xref:System.Windows.Forms.Application.ThreadException>eseménykezelő csatlakoztatva megtörtént.</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Ez csak a fő alkalmazás szál vonatkozik. A UnhandledException esemény jelenik meg, a nem kezelt kivételek más szálak száma.       Microsoft Visual Studio 2005 verziótól kezdődően a Visual Basic alkalmazási keretrendszer biztosít egy másik eseményt a fő alkalmazás szál kezeletlen kivételek. Tekintse meg a <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>esemény.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Ez az esemény esemény argumentumok objektum neve megegyezik az esemény argumentumok objektum UnhandledException használják, de más tulajdonságokkal rendelkezik. Különösen az esemény argumentumok objektumnak egy <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>tulajdonság, amely lehetővé teszi az alkalmazás továbbra is fut, a rendszer figyelmen kívül hagyja a nem kezelt kivétel (és az alkalmazás állapota ismeretlen elhagyása).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> Ebben az esetben a UnhandledException esemény nem jelenik meg."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Eltávolítja a megadott alkalmazástartományt."
  remarks: "A .NET-keretrendszer 2.0-s verziója nincs a szál dedikált az alkalmazástartományok memóriából való eltávolítása. Ez növeli a megbízhatóságot, különösen akkor, ha a .NET-keretrendszer van-e tárolva. Ha a szál hívások eltávolítani a memóriából a céltartomány meg van jelölve memóriából való eltávolítása. A dedikált szál megkísérli eltávolítani a memóriából a tartományhoz, és a tartomány összes lánc megszakad. Ha a szál nem abort, például mert a nem felügyelt kód fut, vagy mert azt egy `finally` letiltása, majd egy bizonyos idő eltelte után a <xref:System.CannotUnloadAppDomainException>vált ki, a szál eredetileg nevezett eltávolítani a memóriából.</xref:System.CannotUnloadAppDomainException> Végül fel nem zárni szál lejártát követően a céltartomány nincs eltávolítva. Ebből kifolyólag a .NET-keretrendszer 2.0-s verziójának `domain` nem biztos, hogy el, mert nem esetleg leáll a feldolgozás alatt álló szálak.      > [!NOTE] > Bizonyos esetekben egy azonnali Unload hívása hatására <xref:System.CannotUnloadAppDomainException>, például ha egy véglegesítőt nevezik.</xref:System.CannotUnloadAppDomainException>       A szálak `domain` használatával megszűnik a <xref:System.Threading.Thread.Abort%2A>metódus, amely jelez a <xref:System.Threading.ThreadAbortException>a szálban.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Bár a szál azonnal kell leáll, az továbbra is egy előre meghatározott ideig a végrehajtás alatt egy `finally` záradékban.      ## Verzió kompatibilitási a a .NET-keretrendszer 1.0-s és 1.1, ha a szál, amely behívja Unload fut `domain`, egy másik szál elindult az eltávolítási művelet végrehajtásához. Ha `domain` nem távolítható el a memóriából, a <xref:System.CannotUnloadAppDomainException>vált ki, az adott szálon nem szerepel az eredeti szál Unload nevezett.</xref:System.CannotUnloadAppDomainException> Azonban, hogy a szál hívó Unload fut-e kívül `domain`, hogy szál megkapja-e a kivétel."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Egy alkalmazástartomány eltávolítása."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>nem sikerült."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Hiba történt az eltávolítási folyamat során."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
