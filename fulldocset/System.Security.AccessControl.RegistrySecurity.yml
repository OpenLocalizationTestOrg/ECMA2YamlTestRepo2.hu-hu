### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.RegistrySecurity
  id: RegistrySecurity
  children:
  - System.Security.AccessControl.RegistrySecurity.#ctor
  - System.Security.AccessControl.RegistrySecurity.AccessRightType
  - System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.RegistrySecurity.AccessRuleType
  - System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleType
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  langs:
  - csharp
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
  type: Class
  summary: "A Windows hozzáférés-vezérléssel egy beállításkulcs jelöli. Ez az osztály nem örökölhető."
  remarks: "Egy RegistrySecurity objektum hozzáférési jogosultságokat a(z) egy beállításkulcs megadásával határozza meg, és is megadja, hogyan hozzáférések naplóz. Minden hozzáférési szabály által képviselt szabályaival egész hozzáférési jogosultsága ahhoz, hogy a beállításkulcs egy <xref:System.Security.AccessControl.RegistryAccessRule>objektum.</xref:System.Security.AccessControl.RegistryAccessRule> Minden egyes naplózási szabály által képviselt egy <xref:System.Security.AccessControl.RegistryAuditRule>objektum.</xref:System.Security.AccessControl.RegistryAuditRule>       Ez tükrözi, a Windows biztonsági rendszer, amelyben minden biztonságos objektumot rendelkezik legfeljebb egy tulajdonosi hozzáférés szabályozási listához (DACL), hogy szabályozza a hozzáférést a védett objektum, és legfeljebb egy rendszer hozzáférés-vezérlési lista (Rendszerszintű) határozza meg, melyik hozzáférések naplóz. A hozzáférés-vezérlési lista és a Rendszerszintű hozzáférés-vezérlő bejegyzések (ACE) által megadott hozzáférési és naplózási felhasználók és csoportok listájának vannak rendezve. A <xref:System.Security.AccessControl.RegistryAccessRule>vagy <xref:System.Security.AccessControl.RegistryAuditRule>objektum egynél több hozzáférés-vezérlő bejegyzések jelenthet.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Windows hozzáférés-vezérléssel csak alkalmazható beállításkulcsok. Az egyéni kulcs/érték párok tárolja a kulcsot nem lehet alkalmazni.       A RegistrySecurity <xref:System.Security.AccessControl.RegistryAccessRule>, és <xref:System.Security.AccessControl.RegistryAuditRule>osztályok megvalósítása részletes ACL-EK és ACE-k elrejtése.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule> Ezek lehetővé teszik, hogy hagyja figyelmen kívül a tizenhét különböző hozzáférés-vezérlő bejegyzések és öröklési és terjesztése a hozzáférési jogok megfelelően fenntartásának összetettségét. Ezek az objektumok is készültek, a következő gyakori ellenőrzési hibák megelőzése érdekében:-hoz létre biztonsági leíró null hozzáférés-vezérlési lista. Egy null hivatkozás egy hozzáférés-vezérlési lista lehetővé teszi, hogy a felhasználók hozzáférési szabályok felvétele objektumra, a-szolgáltatásmegtagadásos támadás potenciálisan létrehozása. Új RegistrySecurity objektum mindig egy üres hozzáférés-vezérlési lista, amely megtagadja az összes felhasználó hozzáférésének kezdődik.      -A szabályt sértő ACE kanonikus sorrendje. Ha a hozzáférés-vezérlő bejegyzések listáján, a hozzáférés-vezérlési lista nem kanonikus sorrendje maradjanak, felhasználók előfordulhat, hogy véletlenül hozzáférést kell biztosítani a biztonságos objektum. Például letiltott hozzáférési jogok mindig előtt kell szerepelnie engedélyezett hozzáférési jogosultsága. RegistrySecurity objektumok belső karbantartása a megfelelő sorrendben.      -Kezelésére szolgáló biztonsági leíró jelzőket, amelyek csak a resource manager ellenőrzése alatt kell lennie.      -Létrehozása a hozzáférés-vezérlő bejegyzések jelzők kombinációja érvénytelen.      -Az örökölt hozzáférés kezelésére. Öröklési és terjesztése az erőforrás-kezelő, hozzáférési és naplózási szabályok módosításai válaszként kezeli.      -A hozzáférés-vezérlési listák értelmetlen ACE-k beszúrása.       A nem támogatja a .NET biztonsági objektumok csak lehetőségek érhetők el kell kerülni az alkalmazásfejlesztők, például a következő többségével veszélyes tevékenységek:-általában az erőforrás-kezelő által elvégzett alacsony szintű feladatokat.      -Hozzáadása vagy eltávolítása a hozzáférés-vezérlő bejegyzéseket, amelyek nem tartanak kanonikus sorrendje módon.       Windows hozzáférés-vezérléssel a beállításkulcsok módosításához használja a <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>metódus használatával kérje le a RegistrySecurity objektum.</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> Módosítsa a biztonsági objektum hozzáadása és eltávolítása a szabályok, és használja a <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metódus újracsatolni azt.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > Egy RegistrySecurity objektum módosításai nem befolyásolják a beállításkulcs a hozzáférési szintek amíg meghívja a <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metódus a módosított biztonsági objektum hozzárendelése a beállításkulcsot.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>       Hozzáférés-vezérléssel másolása egy beállításkulcsot a másikra, használja a <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>metódust egy jelölő a hozzáférési és naplózási szabályok az első beállításkulcs RegistrySecurity objektum, és használja a <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>metódus ezeket a szabályokat rendelhet hozzá a második beállításkulcsot.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> A második beállításkulcsok is hozzárendelheti a szabályok egy <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>vagy <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName>metódus, amely egy RegistrySecurity objektum paramétert fogad.</xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>       A biztonsági leíró definition language (SDDL) befektetést rendelkező felhasználók használhatják a <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>metódus egy beállításkulcs megadásával vonatkozó hozzáférési szabályok beállítása és a <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>SDDL-formátumban a hozzáférési szabályok jelölő karakterlánccá beszerzéséhez.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Ez nem ajánlott új fejlesztésekhez."
  example:
  - "This section contains two code examples. The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.  \n  \n Example 1  \n  \n The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a RegistrySecurity object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the RegistrySecurity object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the RegistrySecurity object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the RegistrySecurity object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_15_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_15_1.cs)]  \n  \n Example 2  \n  \n The following code example demonstrates access rules with inheritance and propagation. The example creates a RegistrySecurity object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags> flag. The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags> and <xref:System.Security.AccessControl.PropagationFlags>.  \n  \n The program displays the rules in the RegistrySecurity object, and then uses the RegistrySecurity object to create a subkey. The program creates a child subkey and a grandchild subkey, then displays the security for each subkey. Finally, the program deletes the test keys.  \n  \n [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/visualbasic/t-system.security.access_15_2.vb)]\n [!code-cs[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/csharp/t-system.security.access_15_2.cs)]"
  syntax:
    content: 'public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> osztály az alapértelmezett értékekkel."
  remarks: "Egy új <xref:System.Security.AccessControl.RegistrySecurity>objektum mindig egy üres tulajdonosi hozzáférés listához (DACL), amely megtagadja az összes felhasználó hozzáférésének kezdődik.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public RegistrySecurity ();
    parameters: []
  overload: System.Security.AccessControl.RegistrySecurity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "A számbavételi típus, amely lekérdezi a <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> használ hozzáférési jogok képviselő osztályt."
  remarks: "Osztályok, amelyek a a <xref:System.Security.AccessControl.ObjectSecurity>felülbírálás osztály a <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>tulajdonság és visszaállítja a hozzáférési jogok képviselő használata típusát.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Tömb, vagy több biztonsági objektumtípusokat tartalmazó gyűjtemények használata, ez a tulajdonság segítségével határozza meg a megfelelő enumerálástípusra használata minden egyes biztonsági objektum."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objektumot képviselő a <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> számbavételi.</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Hoz létre egy új szabályhoz a megadott felhasználó a megadott hozzáférési jogosultságokat, a hozzáférés-vezérlés és a jelzők."
  remarks: "Hozzáférés-vezérlési szabályok létrehozása az ajánlott módszer használatához az <xref:System.Security.AccessControl.RegistryAccessRule>osztály</xref:System.Security.AccessControl.RegistryAccessRule> a konstruktorok      > [!NOTE] > Bár megadhatja azt a <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>jelzőt, nincs erre. Ennek során pont</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> Hozzáférés-vezérlés céljából a név/érték párok alkulcsban nincsenek külön objektumokat. Név/érték párok hozzáférési jogait szabályozzák az alkulcs a jogosultságokat. Továbbá mivel az összes alkulcsához tárolók (Ez azt jelenti, hogy tartalmazhatnak más alkulcsok), ezek nem érinti a <xref:System.Security.AccessControl.InheritanceFlags>jelzőt.</xref:System.Security.AccessControl.InheritanceFlags> Végül adja meg a <xref:System.Security.AccessControl.InheritanceFlags>jelző feleslegesen bonyolítja szabályok, a karbantartási, mert azt a normál kombinációja kompatibilis szabályok ütköző.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Egy <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> , amely azonosítja a felhasználót vagy csoportot a szabály vonatkozik."
    - id: accessMask
      type: System.Int32
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> értékek megadása vagy elutasításáról, hozzáférési jogosultságokat az egész számra konvertálni."
    - id: isInherited
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy a szabály öröklődik."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> értékek megadása, hogyan örökli a szabály alkulcsokat."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> értékeket, amelyeket módosítani a módszert, a szabály alkulcsok örökli. Értelmetlen if értékének `inheritanceFlags` van <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "Egy a <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> megadása, hogy a jogok engedélyezett vagy megtagadott értékeket."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> a megadott felhasználó a megadott jogok képviselő objektum."
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, vagy <code>type</code> érvénytelen értéket."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – <code>accessMask</code> nulla."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>az egyik típus sem <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, és nem olyan típusú, mint <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> be, amely átalakítható <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "A típus, amely lekérdezi a <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> képviselő hozzáférési szabályok által használt osztály."
  remarks: "Osztályok, amelyek a a <xref:System.Security.AccessControl.ObjectSecurity>felülbírálás osztály a <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>tulajdonság és visszaállítja a hozzáférési szabályok ábrázolására használják típusát.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Tömb, vagy több biztonsági objektumtípusokat tartalmazó gyűjtemények használata, a tulajdonság segítségével határozza meg a megfelelő hozzáférési szabály típust kíván használni a minden egyes biztonsági objektum."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objektumot képviselő a <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> osztály</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "A megfelelő hozzáférés-vezérlés, amelyhez az új szabály egyesíthető keres. Ha egyik sem található, az új szabály hozzáadása."
  remarks: "A AddAccessRule módszer megkeresi az ugyanazon felhasználó vagy csoport, és ugyanez rendelkező szabályok <xref:System.Security.AccessControl.AccessControlType>, `rule`.</xref:System.Security.AccessControl.AccessControlType> Ha nincs találhatók, `rule` jelenik meg. Ha egy megfelelő szabályt található, a jogok `rule` egyesítve lesznek az a meglévő szabályt.       Szabályok nem egyesíthetők, ha különböző Öröklődési jelzők rendelkeznek. Például akkor, ha a felhasználó nem öröklési hibajelzést olvasási hozzáférés engedélyezett, és AddAccessRule használatával vegye fel a szabályt, amely a felhasználói írási hozzáféréssel az öröklési alkulcs (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), a két szabály nem egyesíthetők.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>       A különböző szabályok <xref:System.Security.AccessControl.AccessControlType>értékek soha nem egyesítődnek.</xref:System.Security.AccessControl.AccessControlType>       Szabályok express jogok a leggazdaságosabb módon. Például, ha a felhasználó rendelkezik-e <xref:System.Security.AccessControl.RegistryRights>, <xref:System.Security.AccessControl.RegistryRights>és <xref:System.Security.AccessControl.RegistryRights>jogok, és adja hozzá egy szabály, amely lehetővé teszi <xref:System.Security.AccessControl.RegistryRights>jogok, a felhasználó rendelkezik-e az összes elemeire <xref:System.Security.AccessControl.RegistryRights>jogok.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> Ha a felhasználói engedélyek lekérdezése jelenik meg a szabályt tartalmazó <xref:System.Security.AccessControl.RegistryRights>jogok.</xref:System.Security.AccessControl.RegistryRights> Hasonlóképpen ha eltávolítja <xref:System.Security.AccessControl.RegistryRights>tartalomvédelmi, az egyéb összetevőit <xref:System.Security.AccessControl.RegistryRights>jogok újból meg fog jelenni.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights>"
  example:
  - "The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/csharp/0595520c-e456-4072-a959-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/0595520c-e456-4072-a959-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A eszközhozzáférés-vezérlési szabály hozzáadásához."
  overload: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Egy naplózási szabály, amelyhez az új szabály egyesíthető keres. Ha egyik sem található, az új szabály hozzáadása."
  remarks: "A AddAuditRule módszer megkeresi az ugyanazon felhasználó vagy csoport rendelkező szabályok `rule`. Ha nincs találhatók, `rule` jelenik meg. Ha egy megfelelő szabályt található, a jelzők a `rule` egyesülnek a meglévő szabályt.       Szabályok nem egyesíthetők, ha különböző Öröklődési jelzők rendelkeznek. Például ha egy kulcsot írni a sikertelen kísérletek naplóz egy adott felhasználó nem öröklési hibajelzést, és AddAuditRule megpróbál módosításokat végrehajtani egy szabály, adja meg, amely nem sikerült hozzáadni engedélyek is kell naplózni, a felhasználónak, de az öröklési alkulcs (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), a két szabály nem egyesíthetők.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A naplózási szabály hozzáadásához. Ez a szabály a megadott felhasználó meghatározza, hogy a keresés."
  overload: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Létrehoz egy új naplózási szabály, a felhasználó a szabály vonatkozik, naplózási, az öröklési és terjesztése a szabály a hozzáférési jogosultságokat és egyéb, amely elindítja a szabály eredménye."
  remarks: "Naplózási szabályok létrehozása az ajánlott módszer használatához az <xref:System.Security.AccessControl.RegistryAuditRule>osztály</xref:System.Security.AccessControl.RegistryAuditRule> a konstruktorok      > [!NOTE] > Bár megadhatja azt a <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>jelzőt, nincs erre. Ennek során pont</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> A naplózási ellenőrzés céljából a név/érték párok alkulcsban nincsenek külön objektumokat. A név/érték párok naplózási jogosultságok szabályozzák az alkulcs a jogosultságokat. Továbbá mivel az összes alkulcsához tárolók (Ez azt jelenti, hogy tartalmazhatnak más alkulcsok), ezek nem érinti a <xref:System.Security.AccessControl.InheritanceFlags>jelzőt.</xref:System.Security.AccessControl.InheritanceFlags> Végül adja meg a <xref:System.Security.AccessControl.InheritanceFlags>jelző feleslegesen bonyolítja szabályok, a karbantartási, mert azt a normál kombinációja kompatibilis szabályok ütköző.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Egy <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> , amely azonosítja a felhasználót vagy csoportot a szabály vonatkozik."
    - id: accessMask
      type: System.Int32
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> értékek megadását rendszervizsgálati, hozzáférési jogosultságokat az egész számra konvertálni."
    - id: isInherited
      type: System.Boolean
      description: "Egy logikai értéket adja meg, hogy a szabály öröklődik."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> értékek megadása, hogyan örökli a szabály alkulcsokat."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> értékeket, amelyeket módosítani a módszert, a szabály alkulcsok örökli. Értelmetlen if értékének `inheritanceFlags` van <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "Tagértékeinek <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> értékek megadása kell-e hozzáférési sikeres, sikertelen vagy mindkettő naplózni."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> a megadott naplózási szabály a megadott felhasználó a megadott jelzők a képviselő objektum. A metódus visszatérési típusa az alaposztály <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, de az eredményül kapott értéket is konvertálható biztonságosan a származtatott osztály."
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, vagy <code>flags</code> érvénytelen értéket."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       – vagy – <code>accessMask</code> nulla."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>az egyik típus sem <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, és nem olyan típusú, mint <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> be, amely átalakítható <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "A típus, amely lekérdezi a <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> képviselő naplózási szabályok által használt osztály."
  remarks: "Osztályok, amelyek a a <xref:System.Security.AccessControl.ObjectSecurity>felülbírálás osztály a <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>tulajdonság és visszaállítja a naplózási jogosultságok képviselő használata típusa.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Tömb, vagy több biztonsági objektumtípusokat tartalmazó gyűjtemények használata, a tulajdonság segítségével határozza meg a megfelelő naplózási szabály típust kíván használni a minden egyes biztonsági objektum."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objektumot képviselő a <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> osztály</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Keres egy hozzáférés-vezérlési szabály ugyanazt a felhasználói és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (engedélyezése vagy megtagadása) a megadott hozzáférési szabály, és kompatibilis öröklési és propagálás jelzők; Ha egy ilyen szabályt, a jogosultságok, a megadott hozzáférési szabály törlődnek azt."
  remarks: "Az aktuális <xref:System.Security.AccessControl.RegistrySecurity>kell keresni egy szabályt, amely ugyanahhoz a felhasználóhoz, és ugyanez <xref:System.Security.AccessControl.AccessControlType>érték szerint `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Ha nincs ilyen szabály található, nem szükséges művelet, és a metódus visszaadja `false`. Ha a megfeleltetési szabályoknak talál, az öröklési és kompatibilitási jelző kompatibilitás érdekében szerepel a jelzők ellenőrzi `rule`. Ha nem kompatibilis a szabály található, nem szükséges művelet, és a metódus visszaadja `false`. Ha egy szabály a kompatibilis jelzőkkel található, a jogok megadott `rule` kompatibilis a szabály el lesznek távolítva, és a metódus visszaadja `true`. Ha `rule` megadja a jogok kompatibilis a szabály nem található, nem szükséges művelet tekintetében ezeket a jogokat. Minden jog el lesznek távolítva a kompatibilis szabály, ha a teljes szabály törlődik az aktuális <xref:System.Security.AccessControl.RegistrySecurity>objektum.</xref:System.Security.AccessControl.RegistrySecurity>"
  example:
  - "The following code example shows how the RemoveAccessRule method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the RemoveAccessRule method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the RemoveAccessRule method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/797f5ef0-d4da-43dd-bbe9-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/797f5ef0-d4da-43dd-bbe9-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> , amely meghatározza, hogy a felhasználói és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> keresse meg és öröklési és propagálás jelzőket, amelyek egy megfelelő szabályt, ha található, kompatibilisnek kell lennie. Megadja a kompatibilis szabály eltávolítása, ha a jogok található."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha egy kompatibilis szabály található; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Megkeresi az összes hozzáférést vezérlő szabályaival ugyanahhoz a felhasználóhoz és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (engedélyezése vagy megtagadása) a megadott szabály és, ha található, távolítja el azokat."
  remarks: "Az aktuális <xref:System.Security.AccessControl.RegistrySecurity>kell keresni a szabályok, amelyek ugyanahhoz a felhasználóhoz, és ugyanez <xref:System.Security.AccessControl.AccessControlType>érték szerint `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Bármely jogok, Öröklődési jelzők vagy által megadott propagálás jelzők `rule` a keresés végrehajtása során figyelmen kívül lesznek hagyva. Ha nincsenek egyező szabályok találhatók, semmilyen művelet nem lesz végrehajtva.       Például ha egy felhasználó több szabály, amelyek lehetővé teszik a különböző öröklési és propagálás jelzők különböző jogokkal rendelkezik, akkor eltávolíthatja ezeket a szabályokat hozzon létre egy <xref:System.Security.AccessControl.RegistryAccessRule>objektum, amely meghatározza a felhasználói és <xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName>, bármilyen tetszőleges jogok és jelzők és sikeres a RemoveAccessRuleAll metódus a szabály által.</xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName> </xref:System.Security.AccessControl.RegistryAccessRule>"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user to take ownership, and passes that rule to the RemoveAccessRuleAll method to remove the two rules that allow access.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/2ba6e9de-1f41-4d05-af76-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/2ba6e9de-1f41-4d05-af76-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> , amely meghatározza, hogy a felhasználói és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> kereséséhez. Bármely jogok, Öröklődési jelzők vagy a szabály által megadott propagálás jelzők a rendszer figyelmen kívül hagyja."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Keres egy hozzáférés-vezérlési szabály, amely pontosan megegyezik a megadott szabály és, ha található, eltávolítja azt."
  remarks: "A szabály csak akkor, ha pontosan megegyezik eltávolítják `rule` összes részleteit, beleértve a jelzők. Adott felhasználó más szabályaival és <xref:System.Security.AccessControl.AccessControlType>, nem érintettek.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > Szabály egy vagy több alapul szolgáló hozzáférés-vezérlő bejegyzések (ACE) jelöli, és ezek a bejegyzések vágási vagy kombinált szükség szerint, amikor egy felhasználó a hozzáférési szabályok módosítása. Emiatt a szabály már nem létező előfordulhat, hogy az adott űrlap, amikor vették fel kellett, és ebben az esetben a RemoveAccessRuleSpecific metódus nem távolítható el."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method removes a rule only if it matches exactly.  \n  \n The example creates two rules that allow different rights. The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first. The example calls the RemoveAccessRuleSpecific method, specifying the first rule, but because the rules are merged there is no rule that matches. The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the RemoveAccessRuleSpecific method to remove the first rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/9819c0cd-2b26-4472-a333-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/9819c0cd-2b26-4472-a333-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> eltávolítása."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Egy naplózási ellenőrzési szabály ugyanaz a felhasználó a megadott szabály, és kompatibilis öröklési és propagálás jelzők; keres egy kompatibilis szabály található, a jogosultságok, a megadott szabály eltávolítja belőle."
  remarks: "Az aktuális <xref:System.Security.AccessControl.RegistrySecurity>egy naplózási szabály, amely rendelkezik a felhasználónak kell keresni `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Ha nincs ilyen szabály található, nem szükséges művelet, és a metódus visszaadja `false`. Ha a megfeleltetési szabályoknak talál, az öröklési és kompatibilitási jelző kompatibilitás érdekében szerepel a jelzők ellenőrzi `rule`. Ha nem kompatibilis a szabály található, nem szükséges művelet, és a metódus visszaadja `false`. Ha egy szabály a kompatibilis jelzőkkel található, a jogok megadott `rule` kompatibilis a szabály el lesznek távolítva, és a metódus visszaadja `true`. Ha `rule` megadja a jogok kompatibilis a szabály nem található, nem szükséges művelet tekintetében ezeket a jogokat. Minden jog el lesznek távolítva a kompatibilis szabály, ha a teljes szabály törlődik az aktuális <xref:System.Security.AccessControl.RegistrySecurity>objektum.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> , amely megadja a felhasználót, hogy keresse meg és öröklési és propagálás jelzőket, amelyek egy megfelelő szabályt, ha található, kompatibilisnek kell lennie. Megadja a kompatibilis szabály eltávolítása, ha a jogok található."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha egy kompatibilis szabály található; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Összes naplózási ugyanaz a felhasználó a megadott szabály szabályokat, és ha találhatók, eltávolítja azokat."
  remarks: "Az aktuális <xref:System.Security.AccessControl.RegistrySecurity>ellenőrzési szabályok, amelyek a felhasználónak kell keresni `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Bármely jogok, Öröklődési jelzők vagy által megadott propagálás jelzők `rule` a keresés végrehajtása során figyelmen kívül lesznek hagyva. Ha nincsenek egyező szabályok találhatók, semmilyen művelet nem lesz végrehajtva."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> , amely megadja, hogy a felhasználó kereséséhez. Bármely jogok, Öröklődési jelzők vagy a szabály által megadott propagálás jelzők a rendszer figyelmen kívül hagyja."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Egy naplózási szabály, amely pontosan megegyezik a megadott keres szabály és, ha található, eltávolítja azt."
  remarks: "A szabály csak akkor, ha pontosan megegyezik eltávolítják `rule` összes részleteit, beleértve a jelzők. A felhasználónak más naplózási szabály nem lesz hatással.      > [!IMPORTANT] > Szabály egy vagy több alapul szolgáló hozzáférés-vezérlő bejegyzések (ACE) jelöli, és ezek a bejegyzések vágási vagy kombinált szükség szerint, amikor módosítja egy felhasználó naplózási biztonsági szabályait. Emiatt a szabály már nem létező előfordulhat, hogy az adott űrlap, amikor vették fel kellett, és ebben az esetben a RemoveAuditRuleSpecific metódus nem távolítható el."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> távolíthatók el."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Eltávolítja a hozzáférés-vezérlési szabályokkal rendelkező ugyanaz a felhasználó a megadott szabály, függetlenül attól, <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>, és hozzáadja a megadott szabály."
  remarks: "Ha nincsenek felhasználót a megadott szabálynak megfelelő hozzáférési szabályok `rule` jelenik meg."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the ResetAccessRule method to remove the all rules for the user and replace them with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/csharp/80c97a6c-33e0-43c8-8894-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/80c97a6c-33e0-43c8-8894-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. Ez a szabály a megadott felhasználó meghatározza, hogy ez a szabály hozzáadása előtt eltávolítja a szabályokat."
  overload: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Eltávolítja a hozzáférés-vezérlési szabályok azonos felhasználói és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (engedélyezése vagy megtagadása) a megadott szabály, és hozzáadja a megadott szabály."
  remarks: "Ha a megadott szabály <xref:System.Security.AccessControl.AccessControlType>, annak hatását, hogy ez a módszer az, hogy távolítsa el az összes <xref:System.Security.AccessControl.AccessControlType>szabályok a megadott felhasználó, a megadott szabály lecserélése.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> Ha a megadott szabály <xref:System.Security.AccessControl.AccessControlType>, minden <xref:System.Security.AccessControl.AccessControlType>szabályok a megadott felhasználó a megadott szabály cserélése.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       Ha nincsenek szabályok felhasználót és <xref:System.Security.AccessControl.AccessControlType>felel meg a megadott szabály `rule` kerül.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows that the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the SetAccessRule method to remove the two rules that allow access and to replace them with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/908f14bb-fbc5-4e71-ac82-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/csharp/908f14bb-fbc5-4e71-ac82-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. A felhasználói és <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> Ez a szabály a meghatározását, hogy ez a szabály hozzáadása előtt eltávolítja a szabályokat."
  overload: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Összes naplózási szabályokat ugyanaz a felhasználó a megadott szabály, függetlenül attól, hogy eltávolítja a <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> értékét, és hozzáadja a megadott szabály."
  remarks: "Ha nincs naplózási szabály, amelynek felhasználói megegyezik a megadott szabály `rule` jelenik meg."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref> to add. Ez a szabály a megadott felhasználó meghatározza, hogy ez a szabály hozzáadása előtt eltávolítja a szabályokat."
  overload: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistryAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAccessRule
  nameWithType: RegistryAccessRule
  fullName: System.Security.AccessControl.RegistryAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistryAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAuditRule
  nameWithType: RegistryAuditRule
  fullName: System.Security.AccessControl.RegistryAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.#ctor*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity.RegistrySecurity
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: RegistrySecurity.AccessRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: RegistrySecurity.AddAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: RegistrySecurity.AddAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: RegistrySecurity.AuditRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: RegistrySecurity.RemoveAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: RegistrySecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: RegistrySecurity.RemoveAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: RegistrySecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: RegistrySecurity.ResetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: RegistrySecurity.SetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: RegistrySecurity.SetAuditRule
