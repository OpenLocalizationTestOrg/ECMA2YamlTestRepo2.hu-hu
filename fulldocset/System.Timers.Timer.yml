### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "Generál egy eseményt, egy set időszakban, és az ismétlődő események létrehozása után.       Keresse meg a .NET-keretrendszer forráskód ehhez a típushoz, tekintse meg a [hivatkozás forrás](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)."
  remarks: "> [!NOTE]> Forráskódját .NET-keretrendszer ehhez a típushoz, tekintse meg a [hivatkozás forrás](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082). Tallózzon a forráskód online, töltse le a hivatkozás nélküli megtekintéshez és a források (beleértve a javítások és frissítések) végighaladhat hibakeresési; Lásd: [utasításokat](http://referencesource.microsoft.com/).       Az időzítő összetevője egy kiszolgálóalapú időzítőt, amely kiváltja az <xref:System.Timers.Timer.Elapsed>esemény után a ezredmásodpercben az alkalmazásban a <xref:System.Timers.Timer.Interval%2A>tulajdonság lejárt.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Az objektum kell kiadni az esemény csak egyszer vagy ismételten használatával konfigurálhatja a <xref:System.Timers.Timer.AutoReset%2A>tulajdonság.</xref:System.Timers.Timer.AutoReset%2A> Általában egy objektum van deklarálva a osztály szinten, hogy folyamatosan hatókörében mindaddig, amíg a szükséges. Majd kezelheti a <xref:System.Timers.Timer.Elapsed>esemény arra, hogy szabályos feldolgozási.</xref:System.Timers.Timer.Elapsed> Tegyük fel például, a kritikus fontosságú kiszolgáló tartandó futtató 24 óra, nap, a hét. Létrehozhat olyan szolgáltatás, amely rendszeres időközönként ellenőrizze a kiszolgáló, és győződjön meg arról, hogy a rendszer megfelelően működik, és egy objektum használatával. Ha a rendszer nem válaszol, a szolgáltatás indítsa újra a kiszolgálót, és értesíthetők a rendszergazdák kísérletet.      > [!IMPORTANT] > Az időzítő osztály csak a .NET-keretrendszer érhető el. A .NET-szabvány könyvtárban nem szerepel, és nem érhető el a más platformokon, például a .NET Core vagy a univerzális Windows Platform. Ezek a rendszerek, valamint a hordozhatóság minden .NET platformon, használja a <xref:System.Threading.Timer?displayProperty=fullName>osztály helyette.</xref:System.Threading.Timer?displayProperty=fullName>       Ez a típus megvalósítja az <xref:System.IDisposable>felületet.</xref:System.IDisposable> Ha befejezte a típussal, ezért fel kell azt közvetlenül vagy közvetve. Arra, hogy a típus közvetlenül, hívja az <xref:System.IDisposable.Dispose%2A>metódust egy `try` / `catch` blokk.</xref:System.IDisposable.Dispose%2A> Eltávolítása után közvetve, használjon egy nyelvi szerkezet például `using` (a C#) vagy `Using` (a Visual Basic nyelvben). A &quot;Használatával az objektum, amely megvalósítja IDisposable&quot; szakaszában talál további információt a <xref:System.IDisposable>felületet a témakörben.</xref:System.IDisposable>       A kiszolgáló-alapú időzítő osztály munkaszál többszálas környezetben való használatra tervezték. Kiszolgáló időzítők áthelyezheti szálak között kezelni a megemelt <xref:System.Timers.Timer.Elapsed>eseményét, mint az esemény kiváltása idővel a Windows időzítők további pontossággal.</xref:System.Timers.Timer.Elapsed>       Az időzítő komponens kivált-e a <xref:System.Timers.Timer.Elapsed>esemény, a értékét (ezredmásodpercben) alapján a <xref:System.Timers.Timer.Interval%2A>tulajdonság.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Ez az esemény van szüksége a feldolgozás elvégzéséhez képes kezelni. Tegyük fel például, hogy rendelkezik-e folyamatosan küldi az adatbázishoz megrendelések online értékesítési alkalmazást. A szolgáltatás, amely a szállítási vonatkozó utasítások rendelések, hanem minden egyes rendelés feldolgozása külön-külön köteg működik. Egy időzítő segítségével indítsa el a kötegfeldolgozási 30 percenként.      > [!IMPORTANT] > A System.Timers.Timer osztály rendelkezik a rendszeróra megegyező felbontásban. Ez azt jelenti, hogy a <xref:System.Timers.Timer.Elapsed>esemény határozzák meg a rendszeróra felbontása Ha időközzel lesz érvényesítést a <xref:System.Timers.Timer.Interval%2A>tulajdonság értéke kisebb, mint a rendszeróra felbontása.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> További információkért lásd: a <xref:System.Timers.Timer.Interval%2A>tulajdonság.</xref:System.Timers.Timer.Interval%2A>       Ha <xref:System.Timers.Timer.AutoReset%2A>értéke `false`, egy objektum vet fel a <xref:System.Timers.Timer.Elapsed>esemény csak egyszer, az első után <xref:System.Timers.Timer.Interval%2A>lejárt.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> Tartsa előléptetése a <xref:System.Timers.Timer.Elapsed>esemény által meghatározott időközönként rendszeresen a <xref:System.Timers.Timer.Interval%2A>, beállíthatja <xref:System.Timers.Timer.AutoReset%2A>való `true`, az alapértelmezett érték.</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Az időzítő összetevő ki, és minden eseménykezelőinek által kiváltott kivételekre is letiltja a <xref:System.Timers.Timer.Elapsed>esemény.</xref:System.Timers.Timer.Elapsed> Ez a viselkedés van a a jövőbeni kiadásokban változhat. Vegye figyelembe azonban, hogy ez nem igaz az eseménykezelők, amely aszinkron, és tartalmazzák a `await` operátor (a C#) vagy a `Await` operátor (a Visual Basic nyelvben). Ezek az eseménykezelők kivételek rendszer nem propagál vissza a hívó szál az az alábbi példában látható módon. Aszinkron metódusok kivételek további információkért lásd: [kivételkezelést](~/add/includes/ajax-current-ext-md.md).       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ] Ha a <xref:System.Timers.Timer.SynchronizingObject%2A>tulajdonság `null`, a <xref:System.Timers.Timer.Elapsed>esemény jelenik meg az egy <xref:System.Threading.ThreadPool>szál.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   Ha a feldolgozása a <xref:System.Timers.Timer.Elapsed>esemény tart hosszabb, mint <xref:System.Timers.Timer.Interval%2A>, előfordulhat, hogy lehet kiváltott esemény újra egy másik <xref:System.Threading.ThreadPool>szál.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Ebben a helyzetben az eseménykezelő ismételten belépő kell lennie.      > [!NOTE] > A eseménykezelésnek metódus, amely egy másik szál behívja egyszerre előfordulhat, hogy fut egy szálat a <xref:System.Timers.Timer.Stop%2A>metódus vagy beállítja azt a <xref:System.Timers.Timer.Enabled%2A>tulajdonságot `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Emiatt előfordulhat, hogy a <xref:System.Timers.Timer.Elapsed>esemény után a időzítő le van állítva.</xref:System.Timers.Timer.Elapsed> A kódpéldákat biztosít a <xref:System.Timers.Timer.Stop%2A>metódus jeleníti meg a versenyhelyzet elkerülése érdekében egyirányú.</xref:System.Timers.Timer.Stop%2A>       Akkor is, ha <xref:System.Timers.Timer.SynchronizingObject%2A>nem `null`, <xref:System.Timers.Timer.Elapsed>események is előfordulhatnak, miután a <xref:System.Timers.Timer.Dispose%2A>vagy <xref:System.Timers.Timer.Stop%2A>metódus meghívása után vagy a <xref:System.Timers.Timer.Enabled%2A>tulajdonság van beállítva `false`, mert kell kiadni a jel a <xref:System.Timers.Timer.Elapsed>esemény mindig várakozik végrehajtási szál készlet szálban.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> Oldja meg a versenyhelyzet is, hogy a jelzőt, amely közli az eseménykezelőt a(z) egyik módja a <xref:System.Timers.Timer.Elapsed>esemény figyelmen kívül hagyja a további események.</xref:System.Timers.Timer.Elapsed>       Ha az időzítő osztály használata a felhasználói kezelőfelületi elem, például egy űrlap vagy a vezérlő, anélkül, hogy felhasználói kezelőfelületi elem az időzítő rendelje hozzá az űrlap vagy a időzítő tartalmazó vezérlő a <xref:System.Timers.Timer.SynchronizingObject%2A>tulajdonság, így az esemény át végrehajtásra, a felhasználói felület szálhoz.</xref:System.Timers.Timer.SynchronizingObject%2A>       A tulajdonságértékek alapértelmezett időzítő példányt listájáért lásd: a <xref:System.Timers.Timer.%23ctor%2A>konstruktor.</xref:System.Timers.Timer.%23ctor%2A>      > [!TIP] > Vegye figyelembe, hogy a .NET-keretrendszer Class Library tartalmaz négy osztály elnevezése `Timer`, minden egyes, amely különböző funkciót kínál: >>-időzítő (Ez a témakör): az esemény akkor következik be, rendszeres időközönként. Az osztály készült használata egy server-alapú vagy szolgáltatáskomponens többszálas környezetben; nincs felhasználói felülettel rendelkezik, és nem látható el futási időben.   >- <xref:System.Threading.Timer?displayProperty=fullName>: egyetlen visszahívási metódus végrehajtása rendszeres időközönként szál készlet szálban.</xref:System.Threading.Timer?displayProperty=fullName> A visszahívási metódus van definiálva, amikor az időzítő létrejön, és nem módosítható. Az időzítő osztályt, például ez az osztály készült használata egy server-alapú vagy szolgáltatáskomponens többszálas környezetben; nincs felhasználói felülettel rendelkezik, és nem látható el futási időben.   >- <xref:System.Windows.Forms.Timer?displayProperty=fullName>: a Windows Forms összetevője, amely az esemény akkor következik be, rendszeres időközönként.</xref:System.Windows.Forms.Timer?displayProperty=fullName> Az összetevő nincs felhasználói felülettel rendelkezik, és egyszálas környezetben való használatra szolgál.   >- <xref:System.Web.UI.Timer?displayProperty=fullName>: egy ASP.NET összetevő, amely végrehajtja a weblap szinkron vagy aszinkron visszaküldések rendszeres időközönként.</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Timers.Timer&quot;> </xref> osztály, és a tulajdonságok az kezdeti értékre állítja."
  remarks: "Az alábbi táblázat a kezdeti tulajdonságértékek <xref:System.Timers.Timer>.</xref:System.Timers.Timer> példánya      | Tulajdonság |} A kezdeti érték |}   |--------------|-------------------|   | <xref:System.Timers.Timer.AutoReset%2A>| `true`|   | <xref:System.Timers.Timer.Enabled%2A>| `false`|   | <xref:System.Timers.Timer.Interval%2A>|}&100; milliomod másodperc |}   | <xref:System.Timers.Timer.SynchronizingObject%2A>| Egy null hivatkozás (`Nothing` a Visual Basic nyelvben). |}</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Timers.Timer&quot;> </xref> osztály, és beállítja a <xref:System.Timers.Timer.Interval*>tulajdonság a megadott számú ezredmásodperc.</xref:System.Timers.Timer.Interval*>"
  remarks: "Ez a konstruktor beállítja a <xref:System.Timers.Timer.Interval%2A>tulajdonság az új időzítő példány, de nem engedélyezi az időzítőt.</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "Az idő, ezredmásodpercben, események között. Az értéknek kell lennie nullánál nem kisebb és kisebb vagy egyenlő, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Értékét a <code> interval </code> paraméter értéke kisebb vagy egyenlő, mint nulla, vagy nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Lekérdezi vagy beállítja a logikai, amely jelzi, hogy a <xref href=&quot;System.Timers.Timer&quot;> </xref> kell tennie a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> csak egyszer esemény (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) vagy ismételten (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)."
  remarks: "Ha a <xref:System.Timers.Timer>már engedélyezett, ha a <xref:System.Timers.Timer.Start%2A>metódust, az intervallum alaphelyzetbe áll.</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> Ha AutoReset `false`, a <xref:System.Timers.Timer.Start%2A>ahhoz, hogy indítsa újra a count metódust kell hívni.</xref:System.Timers.Timer.Start%2A>       Ha alaphelyzetbe állítása az időköz hatással van a <xref:System.Timers.Timer.Elapsed>egy esemény jelenik meg.</xref:System.Timers.Timer.Elapsed> Például, ha 5 másodpercen beállítani az időközt, és utána állítsa be a <xref:System.Timers.Timer.Enabled%2A>tulajdonságot `true`, a count elindítja a megadott időpontban <xref:System.Timers.Timer.Enabled%2A>van beállítva.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Ha alaphelyzetbe állítja az időköz 10 másodpercben, ha a szám 3 másodpercet, hogy a <xref:System.Timers.Timer.Elapsed>egy esemény jelenik meg először 13 másodperc után a <xref:System.Timers.Timer.Enabled%2A>tulajdonságának beállítása `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Timers.Timer&quot;> </xref> kell tennie a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> esemény minden alkalommal, amikor az az időtartam; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> kell tennie, ha a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> esemény csak egyszer, miután először az időtartam. Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "A futásidejű inicializálása kezdődik egy <xref href=&quot;System.Timers.Timer&quot;> </xref> , amely az űrlap vagy egy másik összetevő használja."
  remarks: "A [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] tervezési környezetben ezt a módszert használja az űrlap vagy egy másik összetevő által használt összetevő inicializálása elindításához. A <xref:System.Timers.Timer.EndInit%2A>metódus befejezi az inicializálási.</xref:System.Timers.Timer.EndInit%2A> A BeginInit metódus használatával és <xref:System.Timers.Timer.EndInit%2A>módszerek megakadályozza, hogy a vezérlő teljes inicializálása előtt használt.</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Feloldja a által használt erőforrások a <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  remarks: "A Close metódus meghívja a `Dispose` metódust."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Feloldja a jelenlegi által használt erőforrások <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a kibocsátási felügyelt és a nem felügyelt erőforrások; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> csak a nem felügyelt erőforrások kijelölése."
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "Akkor következik be, amikor az az időtartam."
  remarks: "Az eltelt esemény jelenik meg, ha a <xref:System.Timers.Timer.Enabled%2A>tulajdonság `true` és az időtartam (ezredmásodperc) határozzák meg a <xref:System.Timers.Timer.Interval%2A>tulajdonság eltelte.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> Ha a <xref:System.Timers.Timer.AutoReset%2A>tulajdonság `true`, a egy esemény jelenik meg ismételten által meghatározott időközönként a <xref:System.Timers.Timer.Interval%2A>tulajdonság; ellenkező esetben a esemény jelenik meg, csak egyszer, először a <xref:System.Timers.Timer.Interval%2A>érték eltelte.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       Ha <xref:System.Timers.Timer.Interval%2A>után állítja be a <xref:System.Timers.Timer>van elindítva, a számláló törlődik.</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> Például, ha 5 másodperc beállítani az időközt, és utána állítsa be <xref:System.Timers.Timer.Enabled%2A>való `true`, a count elindítja a megadott időpontban <xref:System.Timers.Timer.Enabled%2A>van beállítva.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Ha visszaállítása az intervallum száma 3 másodperc esetén 10 másodperc, a eltelt esemény jelenik meg először 13 másodperc után <xref:System.Timers.Timer.Enabled%2A>értékre lett beállítva `true`.</xref:System.Timers.Timer.Enabled%2A>       Ha a <xref:System.Timers.Timer.SynchronizingObject%2A>tulajdonság `null`, a eltelt esemény jelenik meg az egy <xref:System.Threading.ThreadPool>szál.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> Ha tovább tart a eltelt esemény feldolgozása mint <xref:System.Timers.Timer.Interval%2A>, előfordulhat, hogy lehet kiváltott esemény újra egy másik <xref:System.Threading.ThreadPool>szál.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> Ebben a helyzetben az eseménykezelő ismételten belépő kell lennie.      > [!NOTE] > A eseménykezelésnek metódus, amely egy másik szál behívja egyszerre előfordulhat, hogy fut egy szálat a <xref:System.Timers.Timer.Stop%2A>metódus vagy beállítja azt a <xref:System.Timers.Timer.Enabled%2A>tulajdonságot `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Az eltelt esemény időzítőt leállítása után eredményezhet. A kódpéldákat biztosít a <xref:System.Timers.Timer.Stop%2A>metódus jeleníti meg a versenyhelyzet elkerülése érdekében egyirányú.</xref:System.Timers.Timer.Stop%2A>       Akkor is, ha <xref:System.Timers.Timer.SynchronizingObject%2A>nem `null`, Elapsed események akkor fordulhat elő, miután a <xref:System.Timers.Timer.Dispose%2A>vagy <xref:System.Timers.Timer.Stop%2A>metódus meghívása után vagy a <xref:System.Timers.Timer.Enabled%2A>tulajdonság van beállítva `false`, mert a jel kell kiadni a eltelt esemény mindig várakozik végrehajtási szál készlet szálban.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> Egy oldja meg a versenyhelyzet módja a jelzőt, amely közli a figyelmen kívül hagyja a további események eltelt esemény eseménykezelőjét beállításához.       A <xref:System.Timers.Timer>összetevő ki, és letiltja a eltelt esemény eseménykezelőinek összes kivételek.</xref:System.Timers.Timer> Ez a viselkedés van a a jövőbeni kiadásokban változhat."
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Lekérdezi vagy beállítja, hogy egy érték, amely jelzi, hogy a <xref href=&quot;System.Timers.Timer&quot;> </xref> kell tennie a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> esemény."
  remarks: "Engedélyezve beállítás `true` azonos hívása <xref:System.Timers.Timer.Start%2A>, míg a beállítás engedélyezve van a `false` azonos <xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> hívása</xref:System.Timers.Timer.Start%2A>      > [!NOTE] > A jel kell kiadni a <xref:System.Timers.Timer.Elapsed>esemény mindig várakozik végrehajtási a egy <xref:System.Threading.ThreadPool>szál.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Emiatt előfordulhat, hogy a <xref:System.Timers.Timer.Elapsed>esemény után az engedélyezve tulajdonság értéke `false`.</xref:System.Timers.Timer.Elapsed> A következő kód példa a <xref:System.Timers.Timer.Stop%2A>metódus jeleníti meg a versenyhelyzet kerülő egyirányú.</xref:System.Timers.Timer.Stop%2A>       Ha engedélyezve van beállítva `true` és <xref:System.Timers.Timer.AutoReset%2A>értéke `false`, a <xref:System.Timers.Timer>kiváltja a <xref:System.Timers.Timer.Elapsed>esemény csak egyszer, az első alkalommal a időköz lejárta.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Ha az időköz után van megadva a <xref:System.Timers.Timer>van elindítva, a számláló törlődik.</xref:System.Timers.Timer> Például, ha 5 másodperc beállítani az időközt, és akkor értéke az engedélyezett tulajdonságot `true`, a count elindítja a megadott időpontban engedélyezve van-e beállítva. Ha alaphelyzetbe állítja az intervallum száma 3 másodperc esetén 10 másodperc az <xref:System.Timers.Timer.Elapsed>egy esemény jelenik meg először 13 másodperccel azután engedélyezve lett állítva: `true`.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Néhány visual tervezők, például a Microsoft Visual Studio, a tulajdonsága engedélyezve `true` egy új <xref:System.Timers.Timer>.</xref:System.Timers.Timer> beszúráskor"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Timers.Timer&quot;> </xref> kell tennie a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> esemény; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez a tulajdonság nem állítható be, mert az időzítő el lett távolítva."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <xref:System.Timers.Timer.Interval*>tulajdonság értékre lett állítva egy nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; az időzítő engedélyezése előtt.</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "A futásidejű inicializálása befejeződik a <xref href=&quot;System.Timers.Timer&quot;> </xref> , amely az űrlap vagy egy másik összetevő használja."
  remarks: "A [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] tervezési környezetben ezt a módszert használja az űrlap vagy egy másik összetevő által használt összetevő az inicializálás befejezéséhez. A <xref:System.Timers.Timer.BeginInit%2A>metódus elindítja az inicializálás.</xref:System.Timers.Timer.BeginInit%2A> Használja a <xref:System.Timers.Timer.BeginInit%2A>EndInit módszerek megakadályozza, hogy a vezérlő teljes inicializálása előtt használt.</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Lekérdezi vagy beállítja azt az időközt, amellyel indíthat ezredmásodpercben kifejezve a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> esemény."
  remarks: "Az intervallum tulajdonságban segítségével állapítja meg, a gyakoriság, amellyel a <xref:System.Timers.Timer.Elapsed>az esemény.</xref:System.Timers.Timer.Elapsed> Mivel a <xref:System.Timers.Timer>osztály attól függ, a rendszeróra, ezért a rendszer órája megegyező felbontásban.</xref:System.Timers.Timer> Ez azt jelenti, hogy a <xref:System.Timers.Timer.Elapsed>esemény a rendszeróra felbontása határozzák meg, ha az intervallum tulajdonságban nem éri el a rendszer órája felbontása időközzel lesz érvényesítést.</xref:System.Timers.Timer.Elapsed> A következő példa az intervallum tulajdonságban 5 ezredmásodpercig állítja be. Ha futtat a egy [!INCLUDE[win7](~/add/includes/win7-md.md)] rendszer, amelynek rendszeróra tartalmaz a megoldás körülbelül 15 ideje (MS), az esemény akkor következik be, minden 5 ezredmásodpercig helyett körülbelül minden 15 ezredmásodperc.       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ] az alábbi kód segítségével határozza meg a rendszeróra, az aktuális rendszeren felbontása: [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ] Ha az alkalmazás által biztosított-nál nagyobb feloldását követeli meg a <xref:System.Timers.Timer>osztály vagy a rendszeróra, a nagy felbontású multimédiás időzítők használata; lásd: [hogyan: használja a High-Resolution időzítő](http://msdn.microsoft.com/library/aa964692.aspx).</xref:System.Timers.Timer>           Ha az időköz után van megadva a <xref:System.Timers.Timer>van elindítva, a számláló törlődik.</xref:System.Timers.Timer> Például, ha 5 másodpercen beállítani az időközt, és utána állítsa be a <xref:System.Timers.Timer.Enabled%2A>tulajdonságot `true`, a count elindítja a megadott időpontban <xref:System.Timers.Timer.Enabled%2A>van beállítva.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Ha alaphelyzetbe állítja az intervallum száma 3 másodperc esetén 10 másodperc az <xref:System.Timers.Timer.Elapsed>egy esemény jelenik meg először 13 másodperc után <xref:System.Timers.Timer.Enabled%2A>értékre lett beállítva `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       Ha <xref:System.Timers.Timer.Enabled%2A>értéke `true` és <xref:System.Timers.Timer.AutoReset%2A>értéke `false`, a <xref:System.Timers.Timer>vet fel a <xref:System.Timers.Timer.Elapsed>esemény csak egyszer, az első alkalommal a időköz lejárta.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>akkor állítható `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Ha <xref:System.Timers.Timer.Enabled%2A>és <xref:System.Timers.Timer.AutoReset%2A>vannak `false`, és a időzítő korábban engedélyezve van, az intervallum tulajdonság okok beállítása a <xref:System.Timers.Timer.Elapsed>eseményre egyszer, mintha a <xref:System.Timers.Timer.Enabled%2A>tulajdonság beállítása `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> Szeretné beállítani az időközt az esemény kiváltása nélkül, ideiglenesen beállíthatja a <xref:System.Timers.Timer.Enabled%2A>tulajdonságot `true`, és az intervallum tulajdonságban beállítása a kívánt időre intervallum, majd azonnal állítsa be a <xref:System.Timers.Timer.Enabled%2A>vissza `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "Az idő, ezredmásodpercben közötti <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> események. Az értéknek kell lennie nullánál nem kisebb és kisebb vagy egyenlő, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;. Az alapértelmezett érték 100 milliomod másodperc."
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Az intervallum értéke nem nulla.       – vagy – az intervallum értéke nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;, és a időzítő be van kapcsolva. (Az időzítő jelenleg nem engedélyezett, ha nincs kivétel történt amíg aktívvá válik.)"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Lekérdezi vagy beállítja azt a helyet, amely összeköti a <xref href=&quot;System.Timers.Timer&quot;> </xref> Tervező módban a tárolóhoz."
  remarks: "Helyek kötése egy <xref:System.ComponentModel.Component>való egy <xref:System.ComponentModel.Container>és közötti kommunikáció engedélyezése, valamint a tárolót, hogy az összetevők kezelése biztosítva.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "Egy <xref href=&quot;System.ComponentModel.ISite&quot;> </xref> felület képviselő a helyet, amely összeköti a <xref href=&quot;System.Timers.Timer&quot;> </xref> tárolója objektumot."
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Elindítja a kiváltása a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> úgy, hogy az esemény <xref:System.Timers.Timer.Enabled*>való <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Kezdő hívása esetén és <xref:System.Timers.Timer.AutoReset%2A>értéke `false`, a <xref:System.Timers.Timer>kiváltja a <xref:System.Timers.Timer.Elapsed>esemény csak egyszer, az első alkalommal a időköz lejárta.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> Ha kezdő neve és <xref:System.Timers.Timer.AutoReset%2A>van `true`, a <xref:System.Timers.Timer>riasztást a <xref:System.Timers.Timer.Elapsed>az első esemény idő az időköz lejárta, és továbbra is fennáll, az esemény indíthat a megadott intervallumban.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Úgy is elindíthatja időzítési <xref:System.Timers.Timer.Enabled%2A>való `true`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Ha <xref:System.Timers.Timer.AutoReset%2A>van `false`, a Start metódus hívásához ahhoz, hogy indítsa újra a count.</xref:System.Timers.Timer.AutoReset%2A>       Ha a számláló a Start metódus nincs hatása."
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A <xref href=&quot;System.Timers.Timer&quot;> </xref> időközzel jön létre, egyenlő vagy nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1, vagy adja meg a időközönkénti nullánál kisebb."
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Leállítja a kiváltása a <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> úgy, hogy az esemény <xref:System.Timers.Timer.Enabled*>való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Úgy, hogy időzítési is leállíthatják <xref:System.Timers.Timer.Enabled%2A>való `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > A jel kell kiadni a <xref:System.Timers.Timer.Elapsed>esemény mindig várakozik végrehajtási a egy <xref:System.Threading.ThreadPool>szál, így a eseménykezelésnek metódus, amely a Stop metódus fut egy másik szálon egyszerre előfordulhat, hogy fut egy szálat.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Emiatt előfordulhat, hogy a <xref:System.Timers.Timer.Elapsed>esemény után a Stop metódus lehívásra kerül.</xref:System.Timers.Timer.Elapsed> A kód a következő szakaszban példában a versenyhelyzet kerülő egyik módja."
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Lekérdezi vagy beállítja azt az időközt elteltével kiadott eseménykezelő hívások átadásra való előkészítéséhez használt objektum."
  remarks: "SynchronizingObject esetén `null`, a módszer, amely kezeli a <xref:System.Timers.Timer.Elapsed>esemény nevezik, a rendszer szálkészlet a szálban.</xref:System.Timers.Timer.Elapsed> A rendszer-szál készletek további információkért lásd: <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Ha a <xref:System.Timers.Timer.Elapsed>eseményt kezeli visual Windows Forms összetevő, például egy gombra el az összetevőt a rendszer szálkészlet az eredmény egy kivételt vagy csak lehet, hogy nem működik.</xref:System.Timers.Timer.Elapsed> Elkerüléséhez a úgy SynchronizingObject, a Windows Forms összetevő, amely azt eredményezi, a módszer, amely kezeli a <xref:System.Timers.Timer.Elapsed>esemény, amely az összetevő készült elemmel azonos szálban kell meghívni.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Akkor is, ha a SynchronizingObject tulajdonság értéke nem `null`, <xref:System.Timers.Timer.Elapsed>események is előfordulhatnak után a <xref:System.Timers.Timer.Dispose%2A>vagy <xref:System.Timers.Timer.Stop%2A>metódus meghívása után vagy a <xref:System.Timers.Timer.Enabled%2A>tulajdonság van beállítva `false`, mert kell kiadni a jel a <xref:System.Timers.Timer.Elapsed>esemény mindig várakozik végrehajtási szál készlet szálban.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> Oldja meg a versenyhelyzet is, hogy a jelzőt, amely közli az eseménykezelőt a(z) egyik módja a <xref:System.Timers.Timer.Elapsed>esemény figyelmen kívül hagyja a további események.</xref:System.Timers.Timer.Elapsed>       Ha a <xref:System.Timers.Timer>van a Visual Studio használni a Windows Forms-tervezőben, SynchronizingObject értéke automatikusan a <xref:System.Timers.Timer>.</xref:System.Timers.Timer> tartalmazó vezérlő</xref:System.Timers.Timer> Például, ha egy <xref:System.Timers.Timer>tervezőjét a `Form1` (amely örökli <xref:System.Windows.Forms.Form>), a SynchronizingObject tulajdonsága <xref:System.Timers.Timer>példánya értéke `Form1`.</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "A <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> képviselő időközönkénti elteltével kiadott eseménykezelő hívások átadásra való előkészítéséhez használt objektum. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
