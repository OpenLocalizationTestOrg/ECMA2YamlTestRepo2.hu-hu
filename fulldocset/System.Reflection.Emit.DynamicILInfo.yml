### YamlMime:ManagedReference
items:
- uid: System.Reflection.Emit.DynamicILInfo
  id: DynamicILInfo
  children:
  - System.Reflection.Emit.DynamicILInfo.DynamicMethod
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  langs:
  - csharp
  name: DynamicILInfo
  nameWithType: DynamicILInfo
  fullName: System.Reflection.Emit.DynamicILInfo
  type: Class
  summary: "Alternatív módszereket a Microsoft köztes nyelv (MSIL) készítése támogatása és a metaadatok dinamikus metódus, beleértve a jogkivonatok létrehozásához, és a kódot, a kivételkezelés vagy a helyi változó aláírása blobok beillesztése biztosít."
  remarks: "A DynamicILInfo osztály lehetővé teszi a fejlesztők <xref:System.Reflection.Emit.ILGenerator>.</xref:System.Reflection.Emit.ILGenerator> használata helyett a saját MSIL generátorokat írása       Más típusú példányok létrehozása, módszerek és egyéb hívja, a létrehozhat MSIL tartalmaznia kell az ilyen entitások jogkivonatokat. A DynamicILInfo osztály biztosít a több túlterheléssel a <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>metódus, amely jogkivonatok érvényes vissza az aktuális DynamicILInfo hatókörében.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> Például, ha meg kell hívnia a túlterhelés a <xref:System.Console.WriteLine%2A?displayProperty=fullName>metódus, ezt úgy szerezheti be a <xref:System.RuntimeMethodHandle>, amely túlterhelés, és adja át azt, hogy a <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>metódus beágyazása a MSIL jogkivonat beszerzése.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> </xref:System.RuntimeMethodHandle> </xref:System.Console.WriteLine%2A?displayProperty=fullName>       Miután létrehozta <xref:System.Byte>tömbök a helyi változó aláírása, kivételeket és kód törzs, használhatja a <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, és <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A>módszerek szúrható be őket a <xref:System.Reflection.Emit.DynamicMethod>a DynamicILInfo objektumhoz rendelt.</xref:System.Reflection.Emit.DynamicMethod> </xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A> </xref:System.Byte>       A közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;Partíció II: metaadatok Definition és szemantika&quot; és &quot;Partíció III: CIL utasítás beállítása&quot; ismeretét saját metaadatok és MSIL létrehozásához szükséges. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén.      > [!NOTE] > Ne használjon DynamicILInfo kódot, amely egy másik dinamikus metódus delegált létrehozza a delegált konstruktor közvetlen hívásával létrehozásához. Ehelyett használja a <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>metódus a delegált létrehozásához.</xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> A delegált konstruktorral létrehozott meghatalmazott nem rendelkezik a célmetódushoz való kötéskor dinamikus hivatkozást. A dinamikus metódus szemétgyűjtés előfordulhat, hogy visszaigényelt, amíg a delegált még használatban van."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class DynamicILInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  id: DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi a dinamikus módszer, amelynek törzs hozza létre az aktuális példány."
  remarks: "A <xref:System.Reflection.Emit.DynamicILInfo>objektum mindig hozzárendelve egy dinamikus módszer.</xref:System.Reflection.Emit.DynamicILInfo> Az <xref:System.Reflection.Emit.DynamicILInfo>osztály az, hogy adjon meg egy másik módszer a Beszúrás a MSIL adatfolyam, kivételkezelést, és az egy dinamikus metódusnak a fejlesztők számára, akik jöjjön létre MSIL <xref:System.Reflection.Emit.ILGenerator>osztály</xref:System.Reflection.Emit.ILGenerator> használata nélkül helyi változó aláírás</xref:System.Reflection.Emit.DynamicILInfo> célja"
  syntax:
    content: public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }
    return:
      type: System.Reflection.Emit.DynamicMethod
      description: "A <xref:System.Reflection.Emit.DynamicMethod>jelképező a dinamikus módszer, amelynek az aktuális <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum kódot generál.</xref:System.Reflection.Emit.DynamicMethod>"
  overload: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  id: GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, a társított dinamikus metódus aláírása jelző."
  remarks: 'Az aláírás blobok további információkért lásd: a közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;partíció II: metaadatok Definition és szemantikáját&quot;. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén.'
  syntax:
    content: public int GetTokenFor (byte[] signature);
    parameters:
    - id: signature
      type: System.Byte[]
      description: "Olyan tömb, amely az aláírást tartalmaz."
    return:
      type: System.Int32
      description: "Egy, a metaadatok és a kapcsolódó dinamikus metódus a MSIL adatfolyam ágyazható jogkivonatot."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  id: GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, a társított metódus hívható meg dinamikus módszerét jelző."
  remarks: "Ez a módszer túlterhelés visszatérési értékeként lehetővé teszi a dinamikus metódus hívása az aktuális társított dinamikus metódusa <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo> A társított dinamikus metódus rekurzív módon hívja, továbbítja a értékének a <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>tulajdonság.</xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>"
  syntax:
    content: public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);
    parameters:
    - id: method
      type: System.Reflection.Emit.DynamicMethod
      description: "A dinamikus metódust kell meghívni."
    return:
      type: System.Int32
      description: "Az MSIL adatfolyam a társított dinamikus metódus MSIL-utasítás céljaként ágyazható lexikális eleme."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  id: GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, képviselő érhetők el a társított dinamikus metódus egy mezőt."
  remarks: "Be kell szereznie egy mezőt, a dinamikus módszer az aktuális társított fogják elérni egy token <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo> A <xref:System.Type.GetField%2A?displayProperty=fullName>metódus egy <xref:System.Reflection.FieldInfo>szeretné elérni, majd használja a <xref:System.Reflection.FieldInfo.FieldHandle%2A>tulajdonság használatával beolvassa a <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> mező</xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "A mező érhető el."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely használható a mezőket, az aktuális hatókörben hozzáférő MSIL-utasítás operandusa <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  id: GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, képviselő érhetők el a társított dinamikus metódus módszerét."
  remarks: "Be kell szereznie egy bármely metódus webböngészőügyfelek által az aktuális társított dinamikus metódus lexikális eleme <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo> A <xref:System.Type.GetMethod%2A?displayProperty=fullName>metódus egy <xref:System.Reflection.MethodInfo>szeretné elérni, és aztán a <xref:System.Reflection.MethodBase.MethodHandle%2A>tulajdonság használatával beolvassa a <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> módban</xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>      > [!NOTE] > Egy metódust, amely egy általános típus tartozik, használja a <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>metódus túlterhelés, és adjon meg egy <xref:System.RuntimeTypeHandle>az általános típus.</xref:System.RuntimeTypeHandle> </xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "A metódus számára érhető el."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely használható a módszerek, például a hozzáférő MSIL-utasítás operandusa <xref:System.Reflection.Emit.OpCodes.Call>vagy <xref:System.Reflection.Emit.OpCodes.Ldtoken>, az aktuális hatókörben <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, képviselő társított dinamikus metódus használható."
  remarks: "Ez a módszer túlterhelés visszatérési értékeként lehetővé teszi egy helyi változó típusa határozza meg, és a kibocsátás MSIL típusú példányt létrehozni az aktuális társított dinamikus metódus <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo>       A beolvasandó egy <xref:System.RuntimeTypeHandle>képviselő, használja a <xref:System.Type.TypeHandle%2A?displayProperty=fullName>tulajdonság.</xref:System.Type.TypeHandle%2A?displayProperty=fullName> </xref:System.RuntimeTypeHandle>"
  syntax:
    content: public int GetTokenFor (RuntimeTypeHandle type);
    parameters:
    - id: type
      type: System.RuntimeTypeHandle
      description: "A használt típus."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely használható a típusa, az aktuális hatókörben igénylő MSIL-utasítás operandusa <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  id: GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, képviselő karakterláncot a társított dinamikus metódus használható."
  syntax:
    content: public int GetTokenFor (string literal);
    parameters:
    - id: literal
      type: System.String
      description: "A karakterlánc használható."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely egy karakterlánc, az aktuális hatókörben igénylő MSIL-utasítás operandusa használható <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, a mező kitöltése képviselő egy mezőt érhetők el a társított dinamikus metódus; a megadott általános típus."
  remarks: "Be kell szereznie egy mezőt, a dinamikus módszer az aktuális társított fogják elérni egy token <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo> A <xref:System.Type.GetField%2A?displayProperty=fullName>metódus egy <xref:System.Reflection.FieldInfo>megnyitásához, majd a <xref:System.Reflection.FieldInfo.FieldHandle%2A>tulajdonság használatával beolvassa a <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> kívánt mező</xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "A mező érhető el."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "Az általános típus, a mező tartozik."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely az aktuális hatókörben mezők hozzáférő MSIL-utasítás operandusa használható <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Lekérdezi az aktuális hatókörben érvényes jogkivonat <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, képviselő vonatkozó általános típusú metódus."
  remarks: "Be kell szereznie egy bármely metódus, amelyeket a rendszer az aktuális társított a dinamikus metódus lexikális eleme <xref:System.Reflection.Emit.DynamicILInfo>objektum.</xref:System.Reflection.Emit.DynamicILInfo> A <xref:System.Type.GetMethod%2A?displayProperty=fullName>metódus egy <xref:System.Reflection.MethodInfo>hívható meg, és aztán a <xref:System.Reflection.MethodBase.MethodHandle%2A>tulajdonság használatával beolvassa a <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> kívánt módban</xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "A metódus."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "Az általános típusú metódus tartozik."
    return:
      type: System.Int32
      description: "Egy jogkivonatot, amely használható a módszerek, például a hozzáférő MSIL-utasítás operandusa <xref:System.Reflection.Emit.OpCodes.Call>vagy <xref:System.Reflection.Emit.OpCodes.Ldtoken>, az aktuális hatókörben <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> objektum.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  id: SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Beállítja a társított dinamikus metódus kód törzsét."
  remarks: "Nincs érvényességi a rendszer ellenőrzi a MSIL adatfolyamon.       Az első MSIL adatfolyam még egyszer a metódus hívása a második lecseréli.       A közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;Partíció II: metaadatok Definition és szemantika&quot; és &quot;Partíció III: CIL utasítás beállítása&quot; ismeretét saját metaadatok és MSIL létrehozásához szükséges. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén."
  syntax:
    content: public void SetCode (byte[] code, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte[]
      description: "Az MSIL adatfolyam tartalmazó tömb."
    - id: maxStackSize
      type: System.Int32
      description: "A metódus végrehajtásakor a operandus veremben elemek maximális száma."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  id: SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Beállítja a társított dinamikus metódus kód törzsét."
  remarks: "Nincs érvényességi a rendszer ellenőrzi a MSIL adatfolyamon.       Az első MSIL adatfolyam még egyszer a metódus hívása a második lecseréli.       Saját metaadatok és MSIL létrehozásához szükséges ismeretét a közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;partíció II: metaadatok Definition és szemantikáját&quot; és &quot;partíció III: CIL utasítás Set.&quot; A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén."
  syntax:
    content: public void SetCode (byte* code, int codeSize, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte*
      description: "Egy a MSIL folyamot tartalmazó bájttömb mutató hivatkozások."
    - id: codeSize
      type: System.Int32
      description: "Az MSIL adatfolyamban bájtok száma."
    - id: maxStackSize
      type: System.Int32
      description: "A metódus végrehajtásakor a operandus veremben elemek maximális száma."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>code</code>van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> és <code>codeSize</code> nagyobb, mint 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>codeSize</code>értéke 0-nál kisebb."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  id: SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "A társított dinamikus metódus kivételt metaadatainak beállítása."
  remarks: 'Egy metódus kivételt metaadatainak határozza meg a helyét és méretét, az összes `try`, `catch`, `finally`, és a tartalék blokkokat. Ezeket a metaadatokat az elrendezési adatokat dokumentációjában a közös nyelvi infrastruktúra (CLI), főleg &quot;partíció II: metaadatok Definition és szemantikáját&quot;. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén.'
  syntax:
    content: public void SetExceptions (byte[] exceptions);
    parameters:
    - id: exceptions
      type: System.Byte[]
      description: "A kivétel metaadatokat tartalmazó tömb."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  id: SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "A társított dinamikus metódus kivételt metaadatainak beállítása."
  remarks: 'Egy metódus kivételt metaadatainak határozza meg a helyét és méretét, az összes `try`, `catch`, `finally`, és a tartalék blokkokat. Ezeket a metaadatokat az elrendezés információ a dokumentációban a közös nyelvi infrastruktúra (CLI), különösen &quot;Partíció II: metaadatok Definition és szemantikájának módosítása&quot; és &quot;Partíció III: CIL utasítás beállítása&quot;. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén.'
  syntax:
    content: public void SetExceptions (byte* exceptions, int exceptionsSize);
    parameters:
    - id: exceptions
      type: System.Byte*
      description: "Egy bájttömbben a kivétel metaadatokat tartalmazó mutató hivatkozások."
    - id: exceptionsSize
      type: System.Int32
      description: "A kivétel metaadatok bájtok száma."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>exceptions</code>van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> és <code>exceptionSize</code> nagyobb, mint 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>exceptionSize</code>értéke 0-nál kisebb."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  id: SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "A helyi változó aláírása, amely leírja a társított dinamikus metódus helyi változók elrendezésének beállítása."
  remarks: "A helyi változó aláírás azzal, hogy egy metódus helyi változók ismerteti. Egyszerűbbé teheti a helyi változó aláírás konstrukció, használja a `static` (`Shared` a Visual Basic nyelvben) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>metódus használatával kérje le a <xref:System.Reflection.Emit.SignatureHelper>a helyi aláírás.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       A helyi változó aláírások információkért lásd: a közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;partíció II: metaadatok Definition és szemantikáját&quot;. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén."
  syntax:
    content: public void SetLocalSignature (byte[] localSignature);
    parameters:
    - id: localSignature
      type: System.Byte[]
      description: "Azzal, hogy a társított <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod> a helyi változót tartalmazó tömb"
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  id: SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "A helyi változó aláírása, amely leírja a társított dinamikus metódus helyi változók elrendezésének beállítása."
  remarks: "A helyi változó aláírás azzal, hogy egy metódus helyi változók ismerteti. Egyszerűbbé teheti a helyi változó aláírás konstrukció, használja a `static` (`Shared` a Visual Basic nyelvben) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>metódus használatával kérje le a <xref:System.Reflection.Emit.SignatureHelper>a helyi aláírás.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       A helyi változó aláírások információkért lásd: a közös nyelvi infrastruktúra (CLI) dokumentációja, különösen akkor &quot;partíció II: metaadatok Definition és szemantikáját&quot;. A dokumentáció áll rendelkezésre online; Lásd: [ECMA C# és a közös nyelvi infrastruktúra szabványok](http://go.microsoft.com/fwlink/?LinkID=99212) az MSDN-en és [szabványos ECMA-335 - közös nyelvi infrastruktúra (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) Ecma nemzetközi webhelyén."
  syntax:
    content: public void SetLocalSignature (byte* localSignature, int signatureSize);
    parameters:
    - id: localSignature
      type: System.Byte*
      description: "Azzal, hogy a társított <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod> a helyi változót tartalmazó tömb"
    - id: signatureSize
      type: System.Int32
      description: "Az aláírás bájtok száma."
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localSignature</code>van <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> és <code>signatureSize</code> nagyobb, mint 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>signatureSize</code>értéke 0-nál kisebb."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicMethod
  parent: System.Reflection.Emit
  isExternal: true
  name: DynamicMethod
  nameWithType: DynamicMethod
  fullName: System.Reflection.Emit.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: true
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
- uid: System.RuntimeMethodHandle
  parent: System
  isExternal: true
  name: RuntimeMethodHandle
  nameWithType: RuntimeMethodHandle
  fullName: System.RuntimeMethodHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor
  nameWithType: DynamicILInfo.GetTokenFor
- uid: System.Reflection.Emit.DynamicILInfo.SetCode*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode
  nameWithType: DynamicILInfo.SetCode
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions
  nameWithType: DynamicILInfo.SetExceptions
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature
  nameWithType: DynamicILInfo.SetLocalSignature
