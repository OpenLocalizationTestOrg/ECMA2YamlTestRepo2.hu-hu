### YamlMime:ManagedReference
items:
- uid: System.Windows.Rect
  id: Rect
  children:
  - System.Windows.Rect.#ctor(System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  - System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  - System.Windows.Rect.Bottom
  - System.Windows.Rect.BottomLeft
  - System.Windows.Rect.BottomRight
  - System.Windows.Rect.Contains(System.Windows.Point)
  - System.Windows.Rect.Contains(System.Windows.Rect)
  - System.Windows.Rect.Contains(System.Double,System.Double)
  - System.Windows.Rect.Empty
  - System.Windows.Rect.Equals(System.Object)
  - System.Windows.Rect.Equals(System.Windows.Rect)
  - System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.GetHashCode
  - System.Windows.Rect.Height
  - System.Windows.Rect.Inflate(System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Double,System.Double)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.Intersect(System.Windows.Rect)
  - System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  - System.Windows.Rect.IsEmpty
  - System.Windows.Rect.Left
  - System.Windows.Rect.Location
  - System.Windows.Rect.Offset(System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Double,System.Double)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Parse(System.String)
  - System.Windows.Rect.Right
  - System.Windows.Rect.Scale(System.Double,System.Double)
  - System.Windows.Rect.Size
  - System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Rect.Top
  - System.Windows.Rect.TopLeft
  - System.Windows.Rect.TopRight
  - System.Windows.Rect.ToString
  - System.Windows.Rect.ToString(System.IFormatProvider)
  - System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  - System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  - System.Windows.Rect.Union(System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Width
  - System.Windows.Rect.X
  - System.Windows.Rect.Y
  langs:
  - csharp
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
  type: Struct
  summary: "A megadott helyre egy szélessége és magassága ismerteti."
  remarks: "<a name=&quot;xamlAttributeUsage_Duration&quot;></a>## XAML attribútumok használata ```   <object property=&quot;x,y,width,height&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> ## XAML értékek *x* <xref:System.Double?displayProperty=fullName> bal oldalán található a négyszög x koordinátáját helyét.</xref:System.Double?displayProperty=fullName>                 *y* <xref:System.Double?displayProperty=fullName> Téglalap felső y koordinátáját helyét.</xref:System.Double?displayProperty=fullName>           *szélesség* <xref:System.Double?displayProperty=fullName> nem negatív értéket a <xref:System.Windows.Rect.Width%2A>téglalap.</xref:System.Windows.Rect.Width%2A> </xref:System.Double?displayProperty=fullName>           *magasság* <xref:System.Double?displayProperty=fullName> nem negatív értéket a <xref:System.Windows.Rect.Height%2A>téglalap.</xref:System.Windows.Rect.Height%2A> </xref:System.Double?displayProperty=fullName>    "
  example:
  - "The following example shows how to use a Rect structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.Windows.RectConverter))]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.Converters.RectValueSerializer))]

      public struct Rect : IFormattable
  inheritance:
  - System.ValueType
  implements:
  - System.IFormattable
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  id: '#ctor(System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúrában, amelynek a megadott méretű és helye (0,0)."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample2_csharp)]"
  syntax:
    content: public Rect (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktúra, amely meghatározza a szélességét és magasságát téglalap."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  id: '#ctor(System.Windows.Point,System.Windows.Point)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúra, amely pontosan elég nagy a két megadott ponton."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample3_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point1, System.Windows.Point point2);
    parameters:
    - id: point1
      type: System.Windows.Point
      description: "Az első pontot, az új téglalap kell tartalmaznia."
    - id: point2
      type: System.Windows.Point
      description: "A második pont, amely az új téglalap kell tartalmaznia."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  id: '#ctor(System.Windows.Point,System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúrában, amelynek van a megadott bal felső sarkának helyét, valamint a megadott szélességét és magasságát."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample4_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point location, System.Windows.Size size);
    parameters:
    - id: location
      type: System.Windows.Point
      description: "A pont, amely megadja a bal felső sarkának téglalap helyét."
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktúra, amely meghatározza a szélességét és magasságát téglalap."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  id: '#ctor(System.Windows.Point,System.Windows.Vector)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúrában, amelynek pontosan elég nagy az adott pont és az adott pont és a megadott vektor összege."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample5_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample5_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point, System.Windows.Vector vector);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "A téglalap tartalmaznia kell az első pontot."
    - id: vector
      type: System.Windows.Vector
      description: "A megadott pont eltolás összeg. Az eredményül kapott téglalap pontosan elég nagy mindkét pont lesz."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  id: '#ctor(System.Double,System.Double,System.Double,System.Double)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúrában, amelynek van a megadott x koordinátáját, y koordinátáját, szélességét és magasságát."
  remarks: "A következő példa bemutatja, hogyan hozzon létre egy új <xref:System.Windows.Rect>struktúra téglalap konstruktorának használatával.</xref:System.Windows.Rect>       [!code-cs[RectExamples_snip #CreateRectExample6_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample6_csharp)]"
  syntax:
    content: public Rect (double x, double y, double width, double height);
    parameters:
    - id: x
      type: System.Double
      description: "Az x koordinátáját a téglalap bal felső sarkában."
    - id: y
      type: System.Double
      description: "Az y koordinátáját a téglalap bal felső sarkában."
    - id: width
      type: System.Double
      description: "A téglalap szélességét."
    - id: height
      type: System.Double
      description: "A téglalap magasságát."
  overload: System.Windows.Rect.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>width</code>a rendszer negatív értékű.       – vagy – <code>height</code> negatív érték."
  platform:
  - net462
- uid: System.Windows.Rect.Bottom
  id: Bottom
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap alján y értékének beolvasása."
  remarks: "A téglalap alján y tengely értéke a összege a <xref:System.Windows.Rect.Y%2A>és <xref:System.Windows.Rect.Height%2A>Tulajdonságok.</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Bottom { get; }
    return:
      type: System.Double
      description: "A téglalap alján y értéke. A téglalap üres, az érték akkor <xref:System.Double>.</xref:System.Double>"
  overload: System.Windows.Rect.Bottom*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomLeft
  id: BottomLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a bal alsó sarkába a téglalap pozíciója"
  remarks: "A bal alsó sarkába a téglalap pozíciója megegyezik (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>).</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomLeft { get; }
    return:
      type: System.Windows.Point
      description: "A bal alsó sarkába a téglalap pozíciója."
  overload: System.Windows.Rect.BottomLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomRight
  id: BottomRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a négyszög jobb alsó sarkában pozícióját."
  remarks: "A négyszög jobb alsó sarkában pozíciója megegyezik (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>).</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomRight { get; }
    return:
      type: System.Windows.Point
      description: "A négyszög jobb alsó sarkában pozícióját."
  overload: System.Windows.Rect.BottomRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  id: Contains(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a téglalap tartalmaz-e az adott pont."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the specified <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#ContainsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample1_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "A pont kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a téglalap tartalmazza a megadott pontot; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  id: Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Jelzi, hogy a téglalap tartalmaz-e a megadott téglalap."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if one rectangle is contained by another rectangle.  \n  \n [!code-cs[RectExamples_snip#ContainsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample2_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap ellenőrzéséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha <code> rect </code> teljesen a téglalap által tartalmazott; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  id: Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a téglalap tartalmaz-e a megadott x koordinátáját és y koordinátáját."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the point specified by the given x-coordinate and y-coordinate.  \n  \n [!code-cs[RectExamples_snip#ContainsExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample3_csharp)]"
  syntax:
    content: public bool Contains (double x, double y);
    parameters:
    - id: x
      type: System.Double
      description: "Az x koordinátáját a pont kereséséhez."
    - id: y
      type: System.Double
      description: "Az y koordinátáját a pont kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha (<code>x</code>, <code> y </code>) a téglalap által tartalmazott; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Empty
  id: Empty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Nincs pozícióját vagy téglalap jelző különleges érték beolvasása."
  remarks: "Ne használjon használata esetén üres téglalapok matematikai számításokat. Mivel mindkét <xref:System.Windows.Rect.X%2A>és <xref:System.Windows.Rect.Y%2A>végtelen értékek, a processzor műveletek vannak jelentősen ronthatja ezeket a műveleteket.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Használata esetén ezek az értékek összehasonlítása nem befolyásolja az alkalmazások teljesítményének."
  syntax:
    content: public static System.Windows.Rect Empty { get; }
    return:
      type: System.Windows.Rect
      description: "Az üres téglalap, amelynek <> </> *> és <> </> *> tulajdonság értékének <xref:System.Double.PositiveInfinity>, és rendelkezik <> </> *> és <> </> *> tulajdonságértékek <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Double.PositiveInfinity>"
  overload: System.Windows.Rect.Empty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a megadott objektum aktuális téglalap egyenlő."
  remarks: "Ez a művelet teszteli, az objektum egyezés keresésekor.       Ez az összehasonlítás két példánya a <xref:System.Double.NaN?displayProperty=fullName>egyenlő minősülnek.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Téglalap pozíciója és dimenziókat szerint <xref:System.Double>értékek.</xref:System.Double> Mivel <xref:System.Double>értékek el amikor pontosság, két értékek, amelyek logikailag egyenlő összehasonlítása meghiúsulhat.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified object.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public override bool Equals (object o);
    parameters:
    - id: o
      type: System.Object
      description: "Az aktuális téglalap hasonlítsa össze az objektumhoz."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha <code> o </code> van egy <xref href=&quot;System.Windows.Rect&quot;> </xref> és azonos <> </> *> és <> </> *> értékeket az aktuális téglalap; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  id: Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a megadott téglalap az aktuális téglalap egyenlő."
  remarks: "Ez a művelet teszteli, az objektum egyezés keresésekor.       Ez az összehasonlítás két példánya a <xref:System.Double.NaN?displayProperty=fullName>egyenlő minősülnek.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Téglalap pozíciója és dimenziókat szerint <xref:System.Double>értékek.</xref:System.Double> Mivel <xref:System.Double>értékek el amikor pontosság, két értékek, amelyek logikailag egyenlő összehasonlítása meghiúsulhat.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified rectangle.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public bool Equals (System.Windows.Rect value);
    parameters:
    - id: value
      type: System.Windows.Rect
      description: "A téglalap az aktuális téglalap összehasonlítandó."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a megadott téglalap azonos <> </> *> és <> </> *> értékeket az aktuális téglalap; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  id: Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a megadott téglalapok egyenlő."
  remarks: "Ez a művelet teszteli, az objektum egyezés keresésekor.       Ez az összehasonlítás két példánya a <xref:System.Double.NaN?displayProperty=fullName>egyenlő minősülnek.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Téglalap pozíciója és dimenziókat szerint <xref:System.Double>értékek.</xref:System.Double> Mivel <xref:System.Double>értékek el amikor pontosság, két értékek, amelyek logikailag egyenlő összehasonlítása meghiúsulhat.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if one rectangle is equal to another.  \n  \n [!code-cs[RectExamples_snip#EqualsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample2_csharp)]"
  syntax:
    content: public static bool Equals (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Az első téglalap összehasonlítani."
    - id: rect2
      type: System.Windows.Rect
      description: "A második téglalap összehasonlítani."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a téglalapok azonos <> </> *> és <> </> *> értékeket, ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.GetHashCode
  id: GetHashCode
  parent: System.Windows.Rect
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap kivonatoló kódot hoz létre."
  remarks: "Ez a módszer egy kivonatkód használatával hozza létre a <xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>, <xref:System.Windows.Rect.Width%2A>, és <xref:System.Windows.Rect.Height%2A>tulajdonságértékek.</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use the GetHashCode method to get the hash code of a <xref:System.Windows.Rect>.  \n  \n [!code-cs[RectExamples_snip#GetHashCodeExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#gethashcodeexample_csharp)]"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Az aktuális kivonatoló kódot <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúra."
  overload: System.Windows.Rect.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Height
  id: Height
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a téglalap magasságát."
  remarks: "A <xref:System.Windows.Rect.Empty%2A>Téglalap rendelkezik egy <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> magassága</xref:System.Windows.Rect.Empty%2A> A <xref:System.Windows.Rect.Empty%2A>téglalap csak olvasható; magassága nem lehet módosítani.</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "Egy pozitív szám, amely a téglalap magasságát. Az alapértelmezett érték a 0."
  overload: System.Windows.Rect.Height*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Magasság értéke negatív értékű."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A magasság értéke egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  id: Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap kibontja a megadott használatával <xref href=&quot;System.Windows.Size&quot;> </xref>, minden irányban."
  remarks: "A <xref:System.Windows.Rect.Width%2A>által jobb lesz a létrejövő téglalap kétszer a <xref:System.Windows.Size.Width%2A>, a megadott <xref:System.Windows.Size>szerkezete, mert mind a jobb és bal oldalon a téglalap növelve.</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> Hasonlóképpen a <xref:System.Windows.Rect.Height%2A>által jobb lesz a létrejövő téglalap kétszer a <xref:System.Windows.Size.Height%2A>, a megadott <xref:System.Windows.Size>struktúra.</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to increase the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample1_csharp)]"
  syntax:
    content: public void Inflate (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "Megadja azt az időt, bontsa ki a téglalap. A <xref href=&quot;System.Windows.Size&quot;> </xref> szerkezet <> </> *> tulajdonság határozza meg a téglalap növeléséhez <> </> *> és <> </> *> tulajdonságait. A <xref href=&quot;System.Windows.Size&quot;> </xref> szerkezet <> </> *> tulajdonság határozza meg a téglalap növeléséhez <> </> *> és <> </> *> tulajdonságait."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez a metódus hívása a &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  id: Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Kiterjeszti, vagy a téglalap zsugorítja minden irányban a megadott szélességének és magasságának összegek, használatával."
  remarks: "A <xref:System.Windows.Rect.Width%2A>, az eredményül kapott téglalap nő vagy csökken az adott szélesség eltolás kétszer által, mert mind a jobb és bal oldalon a téglalap alkalmazva.</xref:System.Windows.Rect.Width%2A> Hasonlóképpen a <xref:System.Windows.Rect.Height%2A>, az eredményül kapott téglalap nő vagy csökken által a megadott magasságát.</xref:System.Windows.Rect.Height%2A>       Ha a megadott szélessége és magassága zsugorítása a téglalap nagyobb, mint a jelenlegi <xref:System.Windows.Rect.Width%2A>vagy <xref:System.Windows.Rect.Height%2A>– jogosultságot ad a téglalap negatív terület – a téglalap válik a <xref:System.Windows.Rect.Empty%2A>téglalap.</xref:System.Windows.Rect.Empty%2A> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample2_csharp)]"
  syntax:
    content: public void Inflate (double width, double height);
    parameters:
    - id: width
      type: System.Double
      description: "Az összeget amellyel és a bal oldalon a téglalap igazodjon."
    - id: height
      type: System.Double
      description: "Az összeg által, ami a felső és alsó oldala igazodjon."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez a metódus hívása a &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  id: Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap által a megadott téglalap bővülő a megadott függvény <xref href=&quot;System.Windows.Size&quot;> </xref>, minden irányban."
  remarks: "A <xref:System.Windows.Rect.Width%2A>által jobb lesz a létrejövő téglalap kétszer a <xref:System.Windows.Size.Width%2A>, a megadott <xref:System.Windows.Size>szerkezete, mert mind a jobb és bal oldalon a téglalap növelve.</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> Hasonlóképpen a <xref:System.Windows.Rect.Height%2A>által jobb lesz a létrejövő téglalap kétszer a <xref:System.Windows.Size.Height%2A>, a megadott <xref:System.Windows.Size>struktúra.</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, System.Windows.Size size);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúra módosításához."
    - id: size
      type: System.Windows.Size
      description: "Megadja azt az időt, bontsa ki a téglalap. A <xref href=&quot;System.Windows.Size&quot;> </xref> szerkezet <> </> *> tulajdonság határozza meg a téglalap növeléséhez <> </> *> és <> </> *> tulajdonságait. A <xref href=&quot;System.Windows.Size&quot;> </xref> szerkezet <> </> *> tulajdonság határozza meg a téglalap növeléséhez <> </> *> és <> </> *> tulajdonságait."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>van egy &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  id: Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Létrehoz egy téglalap bővítését vagy zsugorítását a megadott téglalap adott szélességének és magasságának mértékben, minden irányban."
  remarks: "A <xref:System.Windows.Rect.Width%2A>, az eredményül kapott téglalap nő vagy csökken az adott szélesség eltolás kétszer által, mert mind a jobb és bal oldalon a téglalap alkalmazva.</xref:System.Windows.Rect.Width%2A> Hasonlóképpen a <xref:System.Windows.Rect.Height%2A>, az eredményül kapott téglalap nő vagy csökken által a megadott magasságát.</xref:System.Windows.Rect.Height%2A>       Ha a megadott szélessége és magassága módosítók zsugorítása a téglalap nagyobb, mint a jelenlegi <xref:System.Windows.Rect.Width%2A>vagy <xref:System.Windows.Rect.Height%2A>– jogosultságot ad a téglalap negatív terület – Ez a metódus visszaadja <xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, double width, double height);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A <xref href=&quot;System.Windows.Rect&quot;> </xref> struktúra módosításához."
    - id: width
      type: System.Double
      description: "Az összeget amellyel és a bal oldalon a téglalap igazodjon."
    - id: height
      type: System.Double
      description: "Az összeg által, ami a felső és alsó oldala igazodjon."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>van egy &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  id: Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Az aktuális téglalap és a megadott téglalap talál, és az eredmény az aktuális téglalap tárolja."
  remarks: "Ha nincs metszetének létezik, az aktuális téglalap válik <xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Intersect method to find the intersection of two rectangles and store the result as a rectangle.  \n  \n [!code-cs[RectExamples_snip#IntersectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample1_csharp)]"
  syntax:
    content: public void Intersect (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap ütközik az aktuális téglalap."
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  id: Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A megadott téglalapok metszetét adja vissza."
  remarks: "A következő példa bemutatja, hogyan két téglalapok metszetének megkeresése az Intersect módszer használatával.       [!code-cs[RectExamples_snip #IntersectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Intersect (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Az első téglalap összehasonlítani."
    - id: rect2
      type: System.Windows.Rect
      description: "A második téglalap összehasonlítani."
    return:
      type: System.Windows.Rect
      description: "A két téglalapok metszetét vagy &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; nem metszetének létezésének."
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  id: IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Azt jelzi, hogy a megadott téglalap az aktuális téglalap metszi."
  remarks: ''
  example:
  - "The following example shows how to use the IntersectsWith method to determine if two rectangles intersect.  \n  \n [!code-cs[RectExamples_snip#IntersectsWithExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectswithexample_csharp)]"
  syntax:
    content: public bool IntersectsWith (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap ellenőrzéséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a megadott téglalap metszi az aktuális téglalap; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.IntersectsWith*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IsEmpty
  id: IsEmpty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy érték, amely azt jelzi, hogy a téglalap lekérdezi a <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  remarks: "Ne használja ezt a tulajdonságot nulla területre; tesztelése egy nulla terület téglalap nincs feltétlenül a <xref:System.Windows.Rect.Empty%2A>téglalap.</xref:System.Windows.Rect.Empty%2A> További információkért lásd: a <xref:System.Windows.Rect.Empty%2A>tulajdonság.</xref:System.Windows.Rect.Empty%2A>"
  syntax:
    content: public bool IsEmpty { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a téglalap esetén a <xref:System.Windows.Rect.Empty*>Téglalap; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.Rect.Empty*>"
  overload: System.Windows.Rect.IsEmpty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Left
  id: Left
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A bal oldalon a négyszög x tengely értékének beolvasása."
  remarks: "Ez a tulajdonság lekérdezése értéke megegyezik az első a <xref:System.Windows.Rect.X%2A>tulajdonság.</xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Left { get; }
    return:
      type: System.Double
      description: "A bal oldalon a négyszög x tengely értéke."
  overload: System.Windows.Rect.Left*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Location
  id: Location
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a téglalap bal felső sarkának pozícióját."
  remarks: "A téglalap bal felső sarkának pozíciója megegyezik (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point Location { get; set; }
    return:
      type: System.Windows.Point
      description: "A téglalap a bal felső sarkának pozícióját. Az alapértelmezett érték (0, 0)."
  overload: System.Windows.Rect.Location*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Be van állítva egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  id: Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap eltolja az adott vektort."
  remarks: "A metódus hívása az üres háromszög (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nem engedélyezett.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       Vegye figyelembe, hogy az eltolást metódus hívása csak fog tudni hatása módosíthatja a <xref:System.Windows.Rect.X%2A>és <xref:System.Windows.Rect.Y%2A>Tulajdonságok közvetlenül.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Mivel <xref:System.Windows.Rect>is egy érték, ha hivatkozik egy <xref:System.Windows.Rect>objektum tulajdonság vagy indexelő használatával le az objektum nem egy hivatkozást az objektum egy példányát.</xref:System.Windows.Rect> </xref:System.Windows.Rect> Ha próbálja meg módosítani a <xref:System.Windows.Rect.X%2A>vagy <xref:System.Windows.Rect.Y%2A>tulajdonság vagy indexelő hivatkozással, egy fordítási hiba akkor fordul elő.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Hasonlóképpen eltolás hívása a következő tulajdonság vagy indexelő nem módosítja az alapul szolgáló objektum.  Ha szeretné módosítani a értékének egy <xref:System.Windows.Rect>tulajdonság vagy indexelő hivatkozik, amely, hozzon létre egy új <xref:System.Windows.Rect>, módosítsa a mezőket, és hozzárendelheti a <xref:System.Windows.Rect>vissza a tulajdonság vagy indexelő.</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample1_csharp)]"
  syntax:
    content: public void Offset (System.Windows.Vector offsetVector);
    parameters:
    - id: offsetVector
      type: System.Windows.Vector
      description: "A téglalap áthelyezése vízszintes és függőleges összegek megadó vektort."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez a metódus hívása a &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  id: Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap eltolja a megadott vízszintes és függőleges értékeket."
  remarks: "A metódus hívása az üres háromszög (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nem engedélyezett.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       Vegye figyelembe, hogy az eltolást metódus hívása csak fog tudni hatása módosíthatja a <xref:System.Windows.Rect.X%2A>és <xref:System.Windows.Rect.Y%2A>Tulajdonságok közvetlenül.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Mivel <xref:System.Windows.Rect>is egy érték, ha hivatkozik egy <xref:System.Windows.Rect>objektum tulajdonság vagy indexelő használatával le az objektum nem egy hivatkozást az objektum egy példányát.</xref:System.Windows.Rect> </xref:System.Windows.Rect> Ha próbálja meg módosítani a <xref:System.Windows.Rect.X%2A>vagy <xref:System.Windows.Rect.Y%2A>tulajdonság vagy indexelő hivatkozással, egy fordítási hiba akkor fordul elő.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Hasonlóképpen eltolás hívása a következő tulajdonság vagy indexelő nem módosítja az alapul szolgáló objektum.  Ha szeretné módosítani a értékének egy <xref:System.Windows.Rect>tulajdonság vagy indexelő hivatkozik, amely, hozzon létre egy új <xref:System.Windows.Rect>, módosítsa a mezőket, és hozzárendelheti a <xref:System.Windows.Rect>vissza a tulajdonság vagy indexelő.</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample2_csharp)]"
  syntax:
    content: public void Offset (double offsetX, double offsetY);
    parameters:
    - id: offsetX
      type: System.Double
      description: "A téglalap vízszintesen áthelyezése összeg."
    - id: offsetY
      type: System.Double
      description: "A téglalap függőleges áthelyezése összeg."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez a metódus hívása a &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; téglalap."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  id: Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap, amelyet az vissza a megadott téglalap megadott vektor segítségével."
  remarks: "Az egy üres téglalap a metódus hívása (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nem engedélyezett.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, System.Windows.Vector offsetVector);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Az eredeti téglalap."
    - id: offsetVector
      type: System.Windows.Vector
      description: "A vektor, amely megadja az új téglalap vízszintes és függőleges eltolás."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>van &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  id: Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A megadott téglalap a négyszög, amelyet az ad vissza, a megadott vízszintes és függőleges összegek használatával."
  remarks: "Az egy üres téglalap a metódus hívása (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nem engedélyezett.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, double offsetX, double offsetY);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap történő áthelyezéséhez."
    - id: offsetX
      type: System.Double
      description: "Új téglalap vízszintes eltolását."
    - id: offsetY
      type: System.Double
      description: "Új téglalap függőleges eltolását."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>van &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  id: op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Összehasonlítja két téglalapok az pontos egyezés keresésekor."
  remarks: "Ez a művelet teszteli, az objektum egyezés keresésekor.       Ez az összehasonlítás két példánya a <xref:System.Double.NaN?displayProperty=fullName>egyenlő minősülnek.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Téglalap pozíciója és dimenziókat szerint <xref:System.Double>értékek.</xref:System.Double> Mivel <xref:System.Double>értékek el amikor pontosság, két értékek, amelyek logikailag egyenlő összehasonlítása meghiúsulhat.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equality operator to determine if two rectangles are exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedequalityoperatorexample)]"
  syntax:
    content: public static bool op_Equality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Az első téglalap összehasonlítani."
    - id: rect2
      type: System.Windows.Rect
      description: "A második téglalap összehasonlítani."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a téglalapok azonos <> </> *> és <> </> *> értékeket, ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.op_Equality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  id: op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Összehasonlítja a egyenlőtlen két téglalapok."
  remarks: "Ez a művelet az objektum egyenlőtlen teszteli.       Ez az összehasonlítás két példánya a <xref:System.Double.NaN?displayProperty=fullName>egyenlő minősülnek.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Téglalap pozíciója és dimenziókat szerint <xref:System.Double>értékek.</xref:System.Double> Mivel <xref:System.Double>értékek el amikor pontosság, két értékek, amelyek logikailag egyenlő összehasonlítása meghiúsulhat.</xref:System.Double>"
  example:
  - "The following example shows how to use the Inequality operator to determine if two rectangles are not exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedinequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedinequalityoperatorexample)]"
  syntax:
    content: public static bool op_Inequality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Az első téglalap összehasonlítani."
    - id: rect2
      type: System.Windows.Rect
      description: "A második téglalap összehasonlítani."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a téglalapok nem rendelkeznek azonos <> </> *> és <> </> *> értékeket, ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.op_Inequality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Parse(System.String)
  id: Parse(System.String)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Új téglalap hoz létre a megadott karakterlánc-ábrázolása."
  remarks: ''
  example:
  - "The following example shows how to use the Parse method to convert a string representation of a rectangle into a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ParseExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#parseexample)]\n [!code-vb[RectExamples_snip#ParseExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#parseexample)]"
  syntax:
    content: public static System.Windows.Rect Parse (string source);
    parameters:
    - id: source
      type: System.String
      description: "A téglalap formájában karakterláncos ábrázolása &quot;x, y, szélesség, magasság&quot;."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Parse*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Right
  id: Right
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a négyszög jobb oldalán x tengely értékét."
  remarks: "Az x tengely a négyszög jobb oldalán értéke megegyezik a jelen a <xref:System.Windows.Rect.X%2A>és <xref:System.Windows.Rect.Width%2A>Tulajdonságok.</xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Right { get; }
    return:
      type: System.Double
      description: "A jobb oldalon a négyszög x tengely értéke."
  overload: System.Windows.Rect.Right*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  id: Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Az aktuális téglalap méretének szorozza meg által a megadott x és y értékeket."
  remarks: ''
  example:
  - "The following example shows how to use the Scale method to multiply the width and height of a rectangle by the specified amount.  \n  \n [!code-cs[RectExamples_snip#ScaleExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#scaleexample_csharp)]"
  syntax:
    content: public void Scale (double scaleX, double scaleY);
    parameters:
    - id: scaleX
      type: System.Double
      description: "Az x tengely Mérettényező."
    - id: scaleY
      type: System.Double
      description: "Az y-tengely Mérettényező."
  overload: System.Windows.Rect.Scale*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Size
  id: Size
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a szélességét és magasságát téglalap."
  remarks: ''
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Size Size { get; set; }
    return:
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktúra, amely meghatározza a szélességét és magasságát téglalap."
  overload: System.Windows.Rect.Size*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Méret megadása egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  id: System#IFormattable#ToString(System.String,System.IFormatProvider)
  isEii: true
  parent: System.Windows.Rect
  langs:
  - csharp
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Az érték az aktuális példány a megadott formátumban formázza."
  remarks: "Ez a tag egy explicit illesztőfelületet tag megvalósítása. Használat csak akkor, ha a <xref:System.Windows.Rect>példány típusúvá egy <xref:System.IFormattable>felületet.</xref:System.IFormattable> </xref:System.Windows.Rect>"
  syntax:
    content: string IFormattable.ToString (string format, IFormatProvider provider);
    parameters:
    - id: format
      type: System.String
      description: "A formátumát.       – vagy – egy null hivatkozás (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) a megadott típusú alapértelmezett formátumának a használatára a <xref:System.IFormattable>végrehajtása.</xref:System.IFormattable>"
    - id: provider
      type: System.IFormatProvider
      description: "Az érték formázásához használni kívánt szolgáltató.       – vagy – egy null hivatkozás (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> a Visual Basic nyelvben) a számformátumot tájékoztatást kapni az operációs rendszer aktuális területi beállítása."
    return:
      type: System.String
      description: "A téglalap karakterlánc-ábrázolása."
  overload: System.Windows.Rect.System#IFormattable#ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Top
  id: Top
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a téglalap felső y pozícióját."
  remarks: "Ez a tulajdonság lekérdezése értéke megegyezik az első a <xref:System.Windows.Rect.Y%2A>tulajdonság.</xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Top { get; }
    return:
      type: System.Double
      description: "A téglalap felső y pozíciója."
  overload: System.Windows.Rect.Top*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopLeft
  id: TopLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a téglalap a bal felső sarkának pozícióját."
  remarks: "A téglalap bal felső sarkának pozíciója megegyezik (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopLeft { get; }
    return:
      type: System.Windows.Point
      description: "A téglalap a bal felső sarkának pozícióját."
  overload: System.Windows.Rect.TopLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopRight
  id: TopRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a jobb felső sarokban a téglalap pozíciója."
  remarks: "A jobb felső sarokban a téglalap pozíciója megegyezik (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopRight { get; }
    return:
      type: System.Windows.Point
      description: "A jobb felső sarokban a téglalap pozíciója."
  overload: System.Windows.Rect.TopRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString
  id: ToString
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap karakterlánc alakot adja vissza."
  remarks: ''
  example:
  - "The following example shows how to use the ToString method to get a string representation of a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ToStringExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#tostringexample_csharp)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: 'A jelenlegi téglalap karakterlánc-ábrázolása. The string has the following form: &quot;<>*>,<>*>,<>*>,<>*>&quot;.'
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  id: ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap karakterlánc alakot adja vissza a megadott formátumban szolgáltató használatával."
  syntax:
    content: public string ToString (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: "Kulturális környezet formázási adatait."
    return:
      type: System.String
      description: "A megadott formátumban szolgáltató határozza meg. a jelenlegi négyszög karakterlánc-ábrázolása."
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  id: Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap átalakítja a megadott matrix alkalmazásával."
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to transform a <xref:System.Windows.Rect> structure by using a <xref:System.Windows.Media.Matrix>.  \n  \n [!code-cs[RectExamples_snip#TransformExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample1_csharp)]"
  syntax:
    content: public void Transform (System.Windows.Media.Matrix matrix);
    parameters:
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "Olyan mátrixa, amely megadja az alkalmazandó átalakítás."
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  id: Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A téglalap által a megadott matrix alkalmazása a megadott téglalap adja vissza."
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to create a new <xref:System.Windows.Rect> structure that results from applying a <xref:System.Windows.Media.Matrix> to an existing rectangle.  \n  \n [!code-cs[RectExamples_snip#TransformExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Transform (System.Windows.Rect rect, System.Windows.Media.Matrix matrix);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Az alapja az átalakítási téglalap."
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "Olyan mátrixa, amely megadja az alkalmazandó átalakítás."
    return:
      type: System.Windows.Rect
      description: "A téglalap által a műveletet."
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Point)
  id: Union(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Bontja ki az aktuális téglalap elég pontosan a megadott pontot tartalmaz."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample1_csharp)]"
  syntax:
    content: public void Union (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "A pont tartalmazza."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  id: Union(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Bontja ki az aktuális téglalap elég pontosan a megadott téglalap tartalmaz."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain the specified rectangle.  \n  \n [!code-cs[RectExamples_snip#UnionExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample2_csharp)]"
  syntax:
    content: public void Union (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap tartalmazza."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  id: Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pontosan elég nagy a megadott téglalap és az adott pont téglalap hoz létre."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain a given rectangle and a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect, System.Windows.Point point);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "A téglalap tartalmazza."
    - id: point
      type: System.Windows.Point
      description: "A pont tartalmazza."
    return:
      type: System.Windows.Rect
      description: "A téglalap, amely pontosan elég nagy a megadott téglalap, az adott pont."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  id: Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Létrehoz egy téglalapot, pontosan elég nagy a két megadott téglalapok."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain two given rectangles.  \n  \n [!code-cs[RectExamples_snip#UnionExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Az első téglalap tartalmazza."
    - id: rect2
      type: System.Windows.Rect
      description: "A második téglalap tartalmazza."
    return:
      type: System.Windows.Rect
      description: "Az eredményül kapott téglalap."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Width
  id: Width
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a téglalap szélességét."
  remarks: "A <xref:System.Windows.Rect.Empty%2A>Téglalap rendelkezik <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> szélessége</xref:System.Windows.Rect.Empty%2A> A <xref:System.Windows.Rect.Empty%2A>téglalap csak olvasható; szélessége nem módosítható.</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "Egy pozitív szám, amely a téglalap szélességét jelöli. Az alapértelmezett érték a 0."
  overload: System.Windows.Rect.Width*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Szélesség értéke negatív értékű."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A szélesség értéke egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.X
  id: X
  parent: System.Windows.Rect
  langs:
  - csharp
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a bal oldalon a négyszög x tengely értékét."
  remarks: "Ez a tulajdonság lekérdezése értéke megegyezik az első a <xref:System.Windows.Rect.Left%2A>tulajdonság.</xref:System.Windows.Rect.Left%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double X { get; set; }
    return:
      type: System.Double
      description: "A bal oldalon a négyszög x tengely értéke."
  overload: System.Windows.Rect.X*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "X be van állítva egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Y
  id: Y
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi vagy beállítja a téglalap felső y tengely értékét."
  remarks: "Ez a tulajdonság lekérdezése értéke megegyezik az első a <xref:System.Windows.Rect.Top%2A>tulajdonság.</xref:System.Windows.Rect.Top%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Y { get; set; }
    return:
      type: System.Double
      description: "A téglalap felső y értéke."
  overload: System.Windows.Rect.Y*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Y be van állítva egy <xref:System.Windows.Rect.Empty*>téglalap.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
references:
- uid: System.ValueType
  isExternal: false
  name: System.ValueType
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
- uid: System.Windows.Point
  parent: System.Windows
  isExternal: false
  name: Point
  nameWithType: Point
  fullName: System.Windows.Point
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
- uid: System.Windows.Vector
  parent: System.Windows
  isExternal: false
  name: Vector
  nameWithType: Vector
  fullName: System.Windows.Vector
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Rect.Bottom
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
- uid: System.Windows.Rect.BottomLeft
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
- uid: System.Windows.Rect.Empty
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
- uid: System.Windows.Rect.Equals(System.Object)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
- uid: System.Windows.Rect.GetHashCode
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Rect.Height
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
- uid: System.Windows.Rect.IsEmpty
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
- uid: System.Windows.Rect.Left
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
- uid: System.Windows.Rect.Location
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
- uid: System.Windows.Rect.Parse(System.String)
  parent: System.Windows.Rect
  isExternal: false
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Rect.Right
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
- uid: System.Windows.Rect.Size
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
- uid: System.IFormatProvider
  parent: System
  isExternal: true
  name: IFormatProvider
  nameWithType: IFormatProvider
  fullName: System.IFormatProvider
- uid: System.Windows.Rect.Top
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
- uid: System.Windows.Rect.TopLeft
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
- uid: System.Windows.Rect.TopRight
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
- uid: System.Windows.Rect.ToString
  parent: System.Windows.Rect
  isExternal: false
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
- uid: System.Windows.Media.Matrix
  parent: System.Windows.Media
  isExternal: false
  name: Matrix
  nameWithType: Matrix
  fullName: System.Windows.Media.Matrix
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
- uid: System.Windows.Rect.Union(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
- uid: System.Windows.Rect.Width
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
- uid: System.Windows.Rect.X
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
- uid: System.Windows.Rect.Y
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
- uid: System.Windows.Rect.#ctor*
  parent: System.Windows.Rect
  isExternal: false
  name: Rect
  nameWithType: Rect.Rect
- uid: System.Windows.Rect.Bottom*
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
- uid: System.Windows.Rect.BottomLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
- uid: System.Windows.Rect.Contains*
  parent: System.Windows.Rect
  isExternal: false
  name: Contains
  nameWithType: Rect.Contains
- uid: System.Windows.Rect.Empty*
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
- uid: System.Windows.Rect.Equals*
  parent: System.Windows.Rect
  isExternal: false
  name: Equals
  nameWithType: Rect.Equals
- uid: System.Windows.Rect.GetHashCode*
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode
  nameWithType: Rect.GetHashCode
- uid: System.Windows.Rect.Height*
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
- uid: System.Windows.Rect.Inflate*
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate
  nameWithType: Rect.Inflate
- uid: System.Windows.Rect.Intersect*
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect
  nameWithType: Rect.Intersect
- uid: System.Windows.Rect.IntersectsWith*
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith
  nameWithType: Rect.IntersectsWith
- uid: System.Windows.Rect.IsEmpty*
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
- uid: System.Windows.Rect.Left*
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
- uid: System.Windows.Rect.Location*
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
- uid: System.Windows.Rect.Offset*
  parent: System.Windows.Rect
  isExternal: false
  name: Offset
  nameWithType: Rect.Offset
- uid: System.Windows.Rect.op_Equality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality
  nameWithType: Rect.op_Equality
- uid: System.Windows.Rect.op_Inequality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality
  nameWithType: Rect.op_Inequality
- uid: System.Windows.Rect.Parse*
  parent: System.Windows.Rect
  isExternal: false
  name: Parse
  nameWithType: Rect.Parse
- uid: System.Windows.Rect.Right*
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
- uid: System.Windows.Rect.Scale*
  parent: System.Windows.Rect
  isExternal: false
  name: Scale
  nameWithType: Rect.Scale
- uid: System.Windows.Rect.Size*
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString
  nameWithType: Rect.System.IFormattable.ToString
- uid: System.Windows.Rect.Top*
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
- uid: System.Windows.Rect.TopLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
- uid: System.Windows.Rect.TopRight*
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
- uid: System.Windows.Rect.ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: ToString
  nameWithType: Rect.ToString
- uid: System.Windows.Rect.Transform*
  parent: System.Windows.Rect
  isExternal: false
  name: Transform
  nameWithType: Rect.Transform
- uid: System.Windows.Rect.Union*
  parent: System.Windows.Rect
  isExternal: false
  name: Union
  nameWithType: Rect.Union
- uid: System.Windows.Rect.Width*
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
- uid: System.Windows.Rect.X*
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
- uid: System.Windows.Rect.Y*
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
