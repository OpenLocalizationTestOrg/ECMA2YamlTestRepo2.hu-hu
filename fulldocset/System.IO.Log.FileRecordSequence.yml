### YamlMime:ManagedReference
items:
- uid: System.IO.Log.FileRecordSequence
  id: FileRecordSequence
  children:
  - System.IO.Log.FileRecordSequence.#ctor(System.String)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  - System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.BaseSequenceNumber
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.CreateReservationCollection
  - System.IO.Log.FileRecordSequence.Dispose
  - System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.Flush
  - System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.LastSequenceNumber
  - System.IO.Log.FileRecordSequence.MaximumRecordLength
  - System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.FileRecordSequence.ReadRestartAreas
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReservedBytes
  - System.IO.Log.FileRecordSequence.RestartSequenceNumber
  - System.IO.Log.FileRecordSequence.RetryAppend
  - System.IO.Log.FileRecordSequence.TailPinned
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: FileRecordSequence
  nameWithType: FileRecordSequence
  fullName: System.IO.Log.FileRecordSequence
  type: Class
  summary: "Megvalósít egy <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> fölött egy fájlt. Ez az osztály nem örökölhető."
  remarks: "Az FileRecordSequence objektumot egy rekordsorozat, egyetlen naplófájl alapján a fájlrendszerben. Egy egyszerű megvalósított <xref:System.IO.Log.IRecordSequence>illesztőfelület fölött egy egyszerű fájlalapú naplóban.</xref:System.IO.Log.IRecordSequence>       Kezelheti egy fájl alapú napló, a fiókot, amelyet az alkalmazás fut a kell megfelelő jogosultsággal rendelkezik, a FileRecordSequence objektumot összeállított időpontjában biztonsági által előírtaknak. Emellett a FullTrust kér a létrehozás időpontjában történik. Az engedély ellenőrzési eredmények ezt követően a Windows biztonsági modell összhangban lettek gyorsítótárazva. Ellenőrizze, hogy nem véletlenül teszi ki a tartalmát a rekord módon, hogy egy jogosulatlan felhasználó."
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/t-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/t-system.io.log.filereco_1.cs)]"
  syntax:
    content: 'public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály egy adott fájlt."
  remarks: "Ez a konstruktor olvasási/írási hozzáférést a fájlt hoz létre, és megnyitja a fájlt megosztással olvasási hozzáférést. Ez azt jelenti, hogy a fájl írásra megnyitni vagy egy másik folyamat által a kérelmek sikertelen lesz, amíg <xref:System.IO.Log.FileRecordSequence>példány el lett távolítva a, de olvasási kísérletet tesz a lesz sikeres.</xref:System.IO.Log.FileRecordSequence> Ha `path` nem található, egy új fájl jön létre 0 bájt méretű."
  example:
  - "The following example creates a record sequence, appends record to it, reads the records, and finally diposes the sequence.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/m-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/m-system.io.log.filereco_1.cs)]"
  syntax:
    content: public FileRecordSequence (string path);
    parameters:
    - id: path
      type: System.String
      description: "A fájl egy relatív vagy abszolút elérési útját, amelyhez a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> példányt fog foglalják magukban."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A megadott fájl <code> path </code> érvénytelen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott fájl <code> path </code> nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileAccess)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály egy adott fájl és egy hozzáférési mód."
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "A fájl egy relatív vagy abszolút elérési útját, amelyhez a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> példányt fog foglalják magukban."
    - id: access
      type: System.IO.FileAccess
      description: "Egy érvényes <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, milyen típusú hozzáféréssel rendelkező felhasználók rendelkezik egy naplófájlt használ."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A megadott fájl <code> path </code> érvénytelen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott fájl <code> path </code> nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  id: '#ctor(System.String,System.IO.FileAccess,System.Int32)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> osztály egy adott fájl, egy hozzáférési mód és a fájlméretet."
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access, int size);
    parameters:
    - id: path
      type: System.String
      description: "A fájl egy relatív vagy abszolút elérési útját, amelyhez a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> példányt fog foglalják magukban."
    - id: access
      type: System.IO.FileAccess
      description: "Egy érvényes <xref href=&quot;System.IO.FileAccess&quot;> </xref> érték, amely meghatározza, milyen típusú hozzáféréssel rendelkező felhasználók rendelkezik egy naplófájlt használ."
    - id: size
      type: System.Int32
      description: "Meg kell nyitni a naplófájl mérete."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A paraméterek közül legalább az érvényes tartományon kívül."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A megadott fájl <code> path </code> érvénytelen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott fájl <code> path </code> nem található."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Az operációs rendszer megtagadta a hozzáférést a megadott naplótároló."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A kiinduló sorszám napló továbblép. Ez a módszer nem örökölhető."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A rekordsorozat új alap sequence száma."
  overload: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>érvénytelen."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt a feladatütemezési módosítása."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A napló rekordot ír a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-cs[FileRecordSequence#0](~/add/codesnippet/csharp/10554b85-231e-4dbf-ad02-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A napló rekordot ír a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how you can create a record sequence with this method.  \n  \n [!code-vb[IRecordSequence#3](~/add/codesnippet/visualbasic/5cdfd57c-5dff-4f9a-a7e0-_1.vb)]\n [!code-cs[IRecordSequence#3](~/add/codesnippet/csharp/5cdfd57c-5dff-4f9a-a7e0-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A napló rekordot ír a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nem hozta létre a rekord feladatütemezési..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A napló rekordot ír a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>, sorrendben korábban fenntartott helyet használja. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nem hozta létre a rekord feladatütemezési..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A sorszám az első érvényes rekord lekérdezi az aktuális <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>."
  remarks: "Érvényes sorszámok: nagyobb vagy egyenlő BaseSequenceNumber és <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> -nál kisebb Minden más sorszámok érvénytelenek.       Ez a tulajdonság értékének megváltoztatására meghívásával a <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>vagy <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>metódus.</xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>"
  example:
  - "The following example shows using BaseSequenceNumber in a loop:  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/p-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/p-system.io.log.filereco_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A legalacsonyabb sorszám, amely érvényes rekord megfelel a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Megkezdődik egy aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kezdődik hozzáfűzése a sorozatban korábban fenntartott helyet műveletet. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kezdődik hozzáfűzése a sorozatban korábban fenntartott helyet műveletet. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A hozzáfűzött rekord fogyaszt korábban lefoglalt, által megadott foglalást használó hely a `reservations` paraméter. Ha a Hozzáfűzés sikeres, a legkisebb foglalás területet, amely képes tárolni az adatokat, és hogy a Foglalás terület törlődni fognak a gyűjtemény fog felhasználni.       Általában ez a metódus befejezése előtt a rekord írása után. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a foglalás, amely ezt a rekordot szeretne használni."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelöli az aszinkron append, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kiürítési művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Meg kell adni a <xref:System.IAsyncResult>az aktuális metódus által visszaadott a <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>módszer annak biztosítására, hogy a kiürítés befejeződött, és erőforrásokat megfelelő felszabadítását.</xref:System.IO.Log.FileRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Egy aszinkron kiürítése közben hiba lép fel, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndFlush%2A>       A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.FileRecordSequence>tartósan íródtak.</xref:System.IO.Log.FileRecordSequence>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Aszinkron kiürítési kérés, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák hatására a kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, hogy hívható meg abban az esetben, ha a kiürítés befejeződött."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron kiürítési kérés megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron flush műveletet, amely sikerült még függőben lehet.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy vagy több argumentum érvénytelen.       <code>sequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron tartalék kezdődik, és a hozzáfűzendő műveletet. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron tartalék kezdődik, és a hozzáfűzendő műveletet. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>módszert, győződjön meg arról, hogy a hozzáfűzési művelet befejeződött, és erőforrások megfelelően kell szabadítani.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Ha hiba történt egy aszinkron append, kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás a hozzáfűző befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely megkülönbözteti az adott aszinkron hozzáfűzése küldött egyéb kérések-kéréseket."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, amely jelzi, hogy ehhez az aszinkron művelethez, esetleg még függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódus ahhoz, hogy biztosítsa, hogy az újraindítás terület írási művelet befejeződött, és erőforrásokat is megfelelő felszabadítását.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült.       – vagy – <code>newBaseSeqNum</code> érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítás terület írási művelet, a sorrendben korábban fenntartott helyet használó kezdődik. Ez a módszer nem örökölhető."
  remarks: "Át kell a <xref:System.IAsyncResult>vissza ezt a metódust a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódus ahhoz, hogy biztosítsa, hogy az újraindítás terület írási művelet befejeződött, és erőforrásokat is megfelelő felszabadítását.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Hiba történt egy aszinkron újraindítás terület írási művelet során, ha kivételt nem vált ki, amíg a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódus hívásakor a <xref:System.IAsyncResult>Ez a metódus által visszaadott.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       Ha a művelet sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy <xref:System.IO.Log.ReservationCollection>van megadva, az írásbeli újraindítás területen fogyaszt korábban lefoglalt, használja a gyűjteményben szereplő foglalás terület.</xref:System.IO.Log.ReservationCollection> Ha a metódus sikeres, a legkisebb foglalást, amely képes tárolni az adatokat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az újraindítás terület írási befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron újraindítás terület írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>, hogy jelöli az aszinkron indítsa újra a sikertelen még terület írási művelet lehet függőben.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült.       – vagy – <code>newBaseSeqNum</code> érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Létrehoz egy új <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ez a módszer nem örökölhető."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Az újonnan létrehozott <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A nem felügyelt objektumok által használt erőforrások azonnal kiadását."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.FileRecordSequence.Dispose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Befejeződik az aszinkron művelet hozzáfűzése. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>metódus.</xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron kiürítési művelet véget ér. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron kiürítési kérés, például a lemez i/o kérelem során során előforduló hibákat EndFlush meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.FileRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Aszinkron végpontok lefoglalni, és a hozzáfűző műveletet. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndReserveAndAppend meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>metódus.</xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy aszinkron újraindítási terület írási művelet véget ér. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer blokkolja az i/o-művelet befejezéséig. Egy aszinkron írási kérelem, például a lemez i/o kérelem során során előforduló hibákat EndWriteRestartArea meghívásakor láthatóvá válnak.       Ez a módszer pontosan egyszer hívható meg minden <xref:System.IAsyncResult>által visszaadott a <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>metódus.</xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron i/o-kérelmek mutató hivatkozás."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Írásbeli naplórekord sorszámát."
  overload: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>érvénytelen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>már meghívták a aszinkron művelet."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Biztosítja, hogy az összes hozzáfűzött rekord írva. Ez a módszer nem örökölhető."
  remarks: "A metódus hívása biztosítja, hogy az összes rögzíti, amely rendelkezik lett hozzáfűzi a <xref:System.IO.Log.FileRecordSequence>tartósan írt.</xref:System.IO.Log.FileRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Biztosítja, hogy az összes hozzáfűzött rekord írva. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer biztosítja, hogy az összes rekordot feladatütemezési legfeljebb számok hívása és többek között a megadott sorszám tartósan készült."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A legfrissebb rekord, amely úgy kell megírni, sorszámát. Ha a <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> érvénytelen, akkor úgy kell megírni, az összes rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Az utolsó rekord írása sorszámát."
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nincs ebben a sorozatban és utolsó sorszámok között."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Érvénytelen ebben a sorozatban."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba történt az adatok."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a sorszám lesz hozzáfűzve utolsó rekordját nagyobb."
  remarks: "Ez a tulajdonság tartalmazza a sorszámot, amely nagyobb, mint a sorozat száma az utolsó hozzáfűzi a rekordot. Érvényes sorszámok nagyobb vagy egyenlő <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>pedig kisebb LastSequenceNumber.</xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> Minden más sorszámok érvénytelenek."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám, ez pedig nagyobb, mint az utolsó hozzáfűzött rekord."
  overload: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a legnagyobb rekordot, amely fűzött vagy olvasni az ebben a sorozatban, bájtban méretét."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "A legnagyobb rekordot, amely fűzött vagy olvasni az ebben a sorozatban, bájtban kifejezett mérete."
  overload: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A feladatütemezési a rekordok egy enumerálható gyűjteményhez adja vissza. Ez a módszer nem örökölhető."
  remarks: "Ez a módszer egy rekordok enumerálható gyűjteménye a feladatütemezési adja vissza. A felsorolt rekordok függ értékének a `logRecordEnum` paraméter."
  example:
  - "The following example shows how you can use this method to read the records in a log sequence.  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/5d31b2a4-d7cf-41cf-80bb-_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/5d31b2a4-d7cf-41cf-80bb-_1.cs)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Ha a olvasási indítja el az első rekordra sorszámát."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Egy érvényes <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> érték, amely meghatározza a rekordok olvassa el a módon (vagyis előre vagy visszafelé haladva) egy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Rögzíti a sorozatban enumerálható gyűjteménye."
  overload: System.IO.Log.FileRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak írási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A rekordsorozat sérült.       – vagy – a rekord a rekordsorozat nem kompatibilis verziójával készült."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A számbavétel befejeződött.       – vagy – a számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A feladatütemezési egy enumerálható gyűjteményt újraindítás területek adja vissza. Ez a módszer nem örökölhető."
  remarks: "Az újraindítás területek enumerálása a feladatütemezési fordított sorrendben, ez azt jelenti, hogy az a legnagyobb sorszám a legalacsonyabb sorszámmal. Csak indítsa újra a területek sorszámmal közötti utolsó számát, és a kiinduló sorszám enumerálása."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "A feladatütemezési újraindítás területein enumerálható gyűjteménye."
  overload: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak írási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A rekordsorozat sérült.       – vagy – a rekord a rekordsorozat nem kompatibilis verziójával készült."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A számbavétel befejeződött.       – vagy – a számbavétel nem lett elindítva. Hívása <xref:System.Collections.IEnumerator.MoveNext*>kell tenni.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatikusan lehetővé teszi egyetlen foglalást, és hozzáfűzi a rekord a feladatütemezési. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nem hozta létre a rekord feladatütemezési..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatikusan lehetővé teszi egyetlen foglalást, és hozzáfűzi a rekord a feladatütemezési. Ez a módszer nem örökölhető."
  remarks: "Szereplő adatok a `data` paraméter fog összefűzendő, a rekordként lehetőséggel egy egybájtos tömbbe. Azonban nem rendelkezik vágását meghatározó adatok tömb szegmensek programba, amikor a rekord olvasható legyen.       A megadott foglalásokat ad hozzá a megadott foglalási gyűjteményt a rekordot tartalmazó atomi művelet fűzzön hozzá műveletet. A Hozzáfűzés nem sikerül, ha nincs szabad hely van fenntartva.       Ez a módszer általában előtt a rekord írása után előfordulhat, hogy végezze. Győződjön meg arról, hogy a rekord írása után, vagy adja meg a <xref:System.IO.Log.RecordAppendOptions>használata jelzőt a `recordAppendOptions` paraméter vagy hívási a <xref:System.IO.Log.FileRecordSequence.Flush%2A>metódus.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord, a felhasználó által megadott sorrendben."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "A sorszám a következő rekord előző sorrendben."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Érvényes értéket <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , amely meghatározza, hogyan lehet az adatokat írni."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A foglalási gyűjteményt, amelyben a fenntartásokat."
    - id: reservations
      type: System.Int64[]
      description: "A foglalások bájtban tételéhez."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A hozzáfűzött naplóbejegyzés sorszámát."
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Egy vagy több argumentum engedélyezett tartományon kívül van."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nem hozta létre a rekord feladatütemezési..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem végezhető el."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a lefoglalt bájtok száma."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "A rekord sorozat összes foglalások teljes mérete."
  overload: System.IO.Log.FileRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi a legutóbb írt újraindítási terület sorszámát."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. A közös napló fájl System (Naplófájlrendszer) tart fenn két indítsa újra a területek garantálja, hogy az legalább egy érvényes terület mindig elérhető legyen. Ha egy helyreállítási szükség, a CLFS olvassa be az újraindítás területről, és az adatok az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A legtöbb legutóbb írt sorszámát területén indítsa újra."
  overload: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Lekérdezi vagy beállítja, hogy egy érték, amely azt jelzi-e hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt."
  remarks: "Ha ez a tulajdonság értéke `true`, és egy <xref:System.IO.Log.FileRecordSequence.Append%2A>hívás sikertelen lesz, mivel nincs elegendő lemezterület a sorrendben, a rekordsorozat megpróbálja szabadítson fel lemezterületet, és ismételje meg a Hozzáfűzés.</xref:System.IO.Log.FileRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha hozzáfűzi a rendszer automatikusan rendszer megpróbálja újból végrehajtani a napló megtelt; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A tulajdonság után a feladatütemezési el lett távolítva a történt hozzáférés."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "A rekord feladatütemezési határozza meg, hogy a kiegészítő kell áthelyezni előre következik be. Ez a módszer nem örökölhető."
  remarks: "Ezt az eseményt, amikor a rekordsorozat elfogyott a lemezterület is érvényesítést. Ez az esemény akkor következik be, amikor a feladatütemezési (Ez azt jelenti, hogy az alap sorszáma) végének került előre szabadítson fel lemezterületet."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Az adatok a bájt tömb szegmensekben fog kell összefűzendő a rekordként lehetőséggel egy egybájtos tömbbe. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült.       – vagy – <code>newBaseSeqNum</code> érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Egy újraindítás területen írja a <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ez a módszer nem örökölhető."
  remarks: "Egy újraindítás terület ideiglenesen tárolja az adatokat tartalmazó ügyfél utolsó ellenőrzőpont-művelet használható. Ha egy helyreállítási szükség, egy újraindítás területen olvassa el, és lekérik az adatokat az utolsó ellenőrzőpont-művelet. Ezeket az adatokat a tranzakció, inkonzisztencia lapok tábla, nyitott fájlok táblázat és inicializálja, a helyreállítási folyamat során is használhatók.       Használatával egy újraindítás területen tudja olvasni a <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metódus.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Egy újraindítás terület írásakor az adatokat a bájt tömb szegmensekben a rekordként lehetőséggel egyetlen bájttömb be vannak összefűzendő. Nem rendelkezik vágását meghatározó adatok tömb szegmensek be, ha az újraindítás területen olvasható legyen.       Ha foglalás van megadva, az írásbeli újraindítás területen fog használni, korábban lefoglalt, a gyűjteményben szereplő foglalást használó hely. Ha a metódus sikeres, a legkisebb foglalást, amely az adatokat is tartalmazhat, és hogy a Foglalás törlődni fognak a gyűjtemény fog felhasználni.       Ha ez a metódus sikeresen befejeződött, a kiinduló sorszám frissítve lett. Az összes naplórekordok sorszámmal kisebb, mint az új alap sorszáma nem érhetők el.       Ha egy rekord feladatütemezési el lett távolítva a, vagy érvénytelen argumentumot át, kivételek azonnal belül ezt a műveletet. Egy aszinkron append kérelem, például egy lemezt érintő hibákkal az i/o-kérelem során bekövetkezett hibák eredményez kivételek merültek fel, ha a <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metódust.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Bájt tömb szegmensek összefűzendő, és hozzáfűzi a rekordként listáját."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Az új alap sorszáma. A megadott sorszám nagyobb vagy egyenlő a jelenlegi alap sorszámmal kell lennie."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , amely tartalmazza a Foglalás a újraindítás terület használandó."
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sorszám írásbeli terület indítsa újra."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egy vagy több argumentum <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nincs ebben a sorozatban és utolsó sorszámok között.       – vagy – vége vagy eleje az aktív napló új vagy meglévő archiválási érvénytelen."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>a rekord feladatütemezési nem készült.       – vagy – <code>newBaseSeqNum</code> érvénytelen ebben a sorozatban."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A művelet nem hajtható végre, mert a rekordsorozat csak olvasási hozzáféréssel lett megnyitva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A kérelem váratlan i/o-kivétel miatt nem hajtható végre."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A metódus lett meghívva, miután a feladatütemezési el lett távolítva a."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a program futásának folytatásához."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A rekordsorozat megtelt."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nem elég nagy ahhoz, hogy elférjen foglalási <code> data </code> található <code> reservations </code>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.FileRecordSequence.Dispose
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.Flush
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.FileRecordSequence.TailPinned
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.#ctor*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence
  nameWithType: FileRecordSequence.FileRecordSequence
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append
  nameWithType: FileRecordSequence.Append
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: FileRecordSequence.BeginAppend
- uid: System.IO.Log.FileRecordSequence.BeginFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: FileRecordSequence.BeginFlush
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: FileRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: FileRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: FileRecordSequence.CreateReservationCollection
- uid: System.IO.Log.FileRecordSequence.Dispose*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: FileRecordSequence.Dispose
- uid: System.IO.Log.FileRecordSequence.EndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: FileRecordSequence.EndAppend
- uid: System.IO.Log.FileRecordSequence.EndFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: FileRecordSequence.EndFlush
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: FileRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: FileRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.Flush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush
  nameWithType: FileRecordSequence.Flush
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: FileRecordSequence.ReadLogRecords
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: FileRecordSequence.ReadRestartAreas
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: FileRecordSequence.ReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.ReservedBytes*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: FileRecordSequence.WriteRestartArea
