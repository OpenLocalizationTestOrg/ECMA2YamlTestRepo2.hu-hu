### YamlMime:ManagedReference
items:
- uid: System.Net.HttpListener
  id: HttpListener
  children:
  - System.Net.HttpListener.#ctor
  - System.Net.HttpListener.Abort
  - System.Net.HttpListener.AuthenticationSchemes
  - System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  - System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  - System.Net.HttpListener.Close
  - System.Net.HttpListener.DefaultServiceNames
  - System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  - System.Net.HttpListener.ExtendedProtectionPolicy
  - System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  - System.Net.HttpListener.GetContext
  - System.Net.HttpListener.GetContextAsync
  - System.Net.HttpListener.IgnoreWriteExceptions
  - System.Net.HttpListener.IsListening
  - System.Net.HttpListener.IsSupported
  - System.Net.HttpListener.Prefixes
  - System.Net.HttpListener.Realm
  - System.Net.HttpListener.Start
  - System.Net.HttpListener.Stop
  - System.Net.HttpListener.System#IDisposable#Dispose
  - System.Net.HttpListener.TimeoutManager
  - System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  langs:
  - csharp
  name: HttpListener
  nameWithType: HttpListener
  fullName: System.Net.HttpListener
  type: Class
  summary: "Egy egyszerű, szoftveresen vezérelt HTTP protokoll figyelő biztosít. Ez az osztály nem örökölhető."
  remarks: "Using the HttpListener class, you can create a simple HTTP protocol listener that responds to HTTP requests. The listener is active for the lifetime of the HttpListener object and runs within your application with its permissions.  \n  \n> [!NOTE]\n>  This class is available only on computers running the Windows XP SP2 or Windows Server 2003 operating systems. If you attempt to create an HttpListener object on a computer that is running an earlier operating system, the constructor throws a <xref:System.PlatformNotSupportedException> exception.  \n  \n To use HttpListener, create a new instance of the class using the HttpListener constructor and use the <xref:System.Net.HttpListener.Prefixes%2A> property to gain access to the collection that holds the strings that specify which Uniform Resource Identifier (URI) prefixes the HttpListener should process.  \n  \n A URI prefix string is composed of a scheme (http or https), a host, an optional port, and an optional path. An example of a complete prefix string is \"`http://www.contoso.com:8080/customerData``/`\". Prefixes must end in a forward slash (\"/\"). The HttpListener object with the prefix that most closely matches a requested URI responds to the request. Multiple HttpListener objects cannot add the same prefix; a <xref:System.ComponentModel.Win32Exception> exception is thrown if a HttpListener adds a prefix that is already in use.  \n  \n When a port is specified, the host element can be replaced with \"*\" to indicate that the HttpListener accepts requests sent to the port if the requested URI does not match any other prefix. For example, to receive all requests sent to port 8080 when the requested URI is not handled by any HttpListener, the prefix is \"`http://*:8080``/`\". Similarly, to specify that the HttpListener accepts all requests sent to a port, replace the host element with the \"+\" character, \"`https://+:8080`\". The \"\\*\" and \"+\" characters can be present in prefixes that include paths.  \n  \n Starting with .NET 4.5.3 and Windows 10, wildcard subdomains are supported in URI prefixes that are managed by an HttpListener object. To specify a wildcard subdomain, use the \"*\" character as part of the hostname in a URI prefix: for example, `http://*.foo.com/`, and pass this as the argument to the HttpListenerPrefixCollection.Add method. This will work on .NET 4.5.3 and Windows 10; in earlier versions, this would generate an <xref:System.Net.HttpListenerException>  \n  \n To begin listening for requests from clients, add the URI prefixes to the collection and call the <xref:System.Net.HttpListener.Start%2A> method. HttpListener offers both synchronous and asynchronous models for processing client requests. Requests and their associated responses are accessed using the <xref:System.Net.HttpListenerContext> object returned by the <xref:System.Net.HttpListener.GetContext%2A> method or its asynchronous counterparts, the <xref:System.Net.HttpListener.BeginGetContext%2A> and <xref:System.Net.HttpListener.EndGetContext%2A> methods.  \n  \n The synchronous model is appropriate if your application should block while waiting for a client request and if you want to process only one request at a time. Using the synchronous model, call the <xref:System.Net.HttpListener.GetContext%2A> method, which waits for a client to send a request. The method returns an <xref:System.Net.HttpListenerContext> object to you for processing when one occurs.  \n  \n In the more complex asynchronous model, your application does not block while waiting for requests and each request is processed in its own execution thread. Use the <xref:System.Net.HttpListener.BeginGetContext%2A> method to specify an application-defined method to be called for each incoming request. Within that method, call the <xref:System.Net.HttpListener.EndGetContext%2A> method to obtain the request, process it, and respond.  \n  \n In either model, incoming requests are accessed using the <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerRequest> objects. Similarly, responses are accessed using the <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerResponse> objects. These objects share some functionality with the <xref:System.Net.HttpWebRequest> and <xref:System.Net.HttpWebResponse> objects, but the latter objects cannot be used in conjunction with HttpListener because they implement client, not server, behaviors.  \n  \n An HttpListener can require client authentication. You can either specify a particular scheme to use for authentication, or you can specify a delegate that determines the scheme to use. You must require some form of authentication to obtain information about the client's identity. For additional information, see the <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, and <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> properties.  \n  \n> [!NOTE]\n>  If you create an HttpListener using https, you must select a Server Certificate for that listener. Otherwise, an <xref:System.Net.HttpWebRequest> query of this HttpListener will fail with an unexpected close of the connection.  \n  \n> [!NOTE]\n>  You can configure Server Certificates and other listener options by using HttpCfg.exe. See [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) for more details. The executable is shipped with Windows Server 2003, or can be built from source code available in the Platform SDK.  \n  \n> [!NOTE]\n>  If you specify multiple authentication schemes for the HttpListener, the listener will challenge clients in the following order: `Negotiate`, `NTLM`, `Digest`, and then `Basic`."
  example:
  - "The following code example demonstrates using a HttpListener.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/t-system.net.httplistener_1.cs)]"
  syntax:
    content: 'public sealed class HttpListener : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.HttpListener.#ctor
  id: '#ctor'
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Net.HttpListener&quot;> </xref> osztály."
  remarks: "Az ebben a konstruktorban által visszaadott példány használatához meg kell hívnia a <xref:System.Net.HttpListener.Start%2A>metódus.</xref:System.Net.HttpListener.Start%2A>"
  example:
  - "The following code example demonstrates using the <xref:System.Net.HttpListener> constructor to create a new <xref:System.Net.HttpListener> object. For the complete example, see the <xref:System.Net.HttpListener> class topic.  \n  \n [!code-cs[Net_listener_Basic#9](~/add/codesnippet/csharp/m-system.net.httplistene_20_1.cs)]"
  syntax:
    content: public HttpListener ();
    parameters: []
  overload: System.Net.HttpListener.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Ez az osztály nem használható a jelenlegi operációs rendszeren. Windows Server 2003 vagy Windows XP SP2 kell használnia az osztály példányai."
  platform:
  - net462
- uid: System.Net.HttpListener.Abort
  id: Abort
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Leállítja a <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum azonnal, jelenleg eldobja az összes sorba állított kérelmek."
  remarks: "Ez a módszer megválik az e figyelő által tárolt összes erőforrás. Minden függőben lévő kérések használata nem fejezhető be.       A metódus hívása után kapni fog egy <xref:System.ObjectDisposedException>Ha megkísérli a <xref:System.Net.HttpListener>.</xref:System.Net.HttpListener> használata</xref:System.ObjectDisposedException>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#11](~/add/codesnippet/csharp/m-system.net.httplistene_4_1.cs)]"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Net.HttpListener.Abort*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemes
  id: AuthenticationSchemes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi vagy beállítja a séma, amely hitelesíti az ügyfeleket."
  remarks: "A <xref:System.Net.HttpListener>beérkező összes kérelmet hitelesíteni a megadott sémát használja.</xref:System.Net.HttpListener> A <xref:System.Net.HttpListener.GetContext%2A>és <xref:System.Net.HttpListener.EndGetContext%2A>módszerek az bejövő ügyfélkérés ad vissza, ha csak a <xref:System.Net.HttpListener>sikeresen hitelesíti a kérelmet.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Akkor is kérdezze meg végre sikeresen hitelesített ügyfél identitásának használatával a <xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>tulajdonság.</xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>       Ha szeretne egy <xref:System.Net.HttpListener>különböző hitelesítési mechanizmusok olyankor kap kérelmek jellemzők alapján (például a kérelem <xref:System.Net.HttpListenerRequest.Url%2A>vagy <xref:System.Net.HttpListenerRequest.UserHostName%2A>tulajdonság), meg kell valósítani egy módszert, amelyet úgy dönt, a hitelesítési séma.</xref:System.Net.HttpListenerRequest.UserHostName%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener> Ezzel kapcsolatos útmutatásért lásd: a <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>tulajdonság dokumentációját.</xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>      > [!NOTE] > Kivonatoló engedélyezéséhez a tulajdonság beállításához, NTLM vagy Negotiate van szükség a <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example demonstrates using the AuthenticationSchemes property to specify an authentication scheme.  \n  \n [!code-cs[Net_listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_0_1.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }
    return:
      type: System.Net.AuthenticationSchemes
      description: "Tagértékeinek <xref:System.Net.AuthenticationSchemes>számbavételi érték, amely meghatározza, hogy hogyan ügyfelek hitelesítését.</xref:System.Net.AuthenticationSchemes> Az alapértelmezett érték: <xref:System.Net.AuthenticationSchemes>.</xref:System.Net.AuthenticationSchemes>"
  overload: System.Net.HttpListener.AuthenticationSchemes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  id: AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi vagy beállítja a meghatalmazott, és határozza meg az ügyfelek hitelesítéséhez használt protokoll hívni."
  remarks: "> [!NOTE]> Ha azt szeretné, hogy a hitelesítési protokollnak az adott alkalmazáspéldány által kezelt összes kérelmekhez használható <xref:System.Net.HttpListener>, nem kell állítani ezt a tulajdonságot.</xref:System.Net.HttpListener> Az összes ügyféli kérelmek részére használandó protokoll megadásához használja a <xref:System.Net.HttpListener.AuthenticationSchemes%2A>tulajdonság.</xref:System.Net.HttpListener.AuthenticationSchemes%2A>       Ha az ügyfél nem adott meg a fejlécek, a hitelesítési adatokat a <xref:System.Net.HttpListener>meghívja az adott delegált nem hitelesített bejövő kérelmeket meghatározni, ha van ilyen protokoll használatát az ügyfél hitelesítése céljából.</xref:System.Net.HttpListener> A <xref:System.Net.HttpListener.GetContext%2A>és <xref:System.Net.HttpListener.EndGetContext%2A>módszerek vissza egy bejövő kérelem csak akkor, ha a <xref:System.Net.HttpListener>sikeresen hitelesíteni a kérelmet.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A> Nem lehet hitelesíteni a kérelmet, ha a <xref:System.Net.HttpListener>automatikusan küld vissza a 401-es válasz.</xref:System.Net.HttpListener> Sikeresen hitelesített ügyfél identitásának beszerezheti a <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>tulajdonság.</xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>       A választott hitelesítési protokoll, az alkalmazás-specifikus metódusra delegálni képes akkor hasznos, ha azt szeretné, hogy egy példánya <xref:System.Net.HttpListener>attól függően, hogy megkapja a kérelmek jellemzői különböző hitelesítési protokollok használata (például a kérelem <xref:System.Net.HttpListenerRequest.Url%2A>vagy <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>tulajdonság).</xref:System.Net.HttpListenerRequest.UserHostAddress%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Kivonatoló engedélyezéséhez a tulajdonság beállításához, NTLM vagy Negotiate van szükség a <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example sets the value of this property.  \n  \n [!code-vb[NclListener#2](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_1.vb)]\n [!code-cs[NclListener#2](~/add/codesnippet/csharp/p-system.net.httplistene_2_1.cs)]  \n  \n The following code example provides an implementation of a method invoked by an <xref:System.Net.AuthenticationSchemeSelector> delegate.  \n  \n [!code-vb[NclListener#1](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_2.vb)]\n [!code-cs[NclListener#1](~/add/codesnippet/csharp/p-system.net.httplistene_2_2.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }
    return:
      type: System.Net.AuthenticationSchemeSelector
      description: "Egy <xref href=&quot;System.Net.AuthenticationSchemeSelector&quot;> </xref> delegált esetén, amely hív meg, válasszon olyan hitelesítési protokoll használandó módszert. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  id: BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Megkezdődik a aszinkron módon beolvasása az olyan bejövő kérelemre."
  remarks: "A BeginGetContext metódus egy aszinkron (nem blokkoló) hívás fogadása a bejövő ügyfélkérelmeket kezdődik. A metódus meghívása előtt meg kell hívnia a <xref:System.Net.HttpListener.Start%2A>metódus és a URI karakterlánc való hozzáadásával a figyelésére legalább egy egységes erőforrás-azonosító (URI)-előtag hozzáadása a <xref:System.Net.HttpListenerPrefixCollection>által visszaadott a <xref:System.Net.HttpListener.Prefixes%2A>tulajdonság.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A>       Az aszinkron művelet által hívott a <xref:System.Net.HttpListener.EndGetContext%2A>metódus.</xref:System.Net.HttpListener.EndGetContext%2A> A metódus által indított általában a `callback` delegálni.       Ez a módszer nem blokkolható, amíg a művelet befejeződik. Ahhoz, hogy egy bejövő kérelem, és letiltja a művelet befejeződéséig, hívja az <xref:System.Net.HttpListener.GetContext%2A>metódus.</xref:System.Net.HttpListener.GetContext%2A>       Az aszinkron programozási modell használatával kapcsolatos részletes információkért lásd: [aszinkron szinkron módszerek hívja.](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example demonstrates using the BeginGetContext method to specify a callback method that will handle incoming client requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_13_1.cs)]  \n  \n The following code example implements a callback method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_13_2.cs)]"
  syntax:
    content: public IAsyncResult BeginGetContext (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "Egy <xref:System.AsyncCallback>delegált, ha egy ügyfél kérelmet elérhető meghívni kívánt metódus hivatkozó.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "A felhasználói objektum, amely tartalmazza a műveletekre vonatkozó információk. Ez az objektum átadott a `callback` delegálása a művelet befejeződése után."
    return:
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>objektum, amely az aszinkron művelet állapotát jelzi.</xref:System.IAsyncResult>"
  overload: System.Net.HttpListener.BeginGetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 függvény hívása nem sikerült. Ellenőrizze a kivétel <xref:System.Net.HttpListenerException.ErrorCode*>tulajdonság a kivétel a hiba okának megállapításához.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez az objektum nem lett elindítva, vagy jelenleg le van állítva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.Close
  id: Close
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Leállítja a <xref href=&quot;System.Net.HttpListener&quot;> </xref>."
  remarks: "E metódus meghívása után már nem használható a <xref:System.Net.HttpListener>objektum.</xref:System.Net.HttpListener> Átmenetileg felfüggeszti az <xref:System.Net.HttpListener>objektumazonosító, használja a <xref:System.Net.HttpListener.Stop%2A>metódus.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>       Ez a módszer állítsa időszakosan megszakadó a <xref:System.Net.HttpListener>objektum nélkül sorba állított kérelmek feldolgozásához.</xref:System.Net.HttpListener> Minden függőben lévő kérések használata nem fejezhető be."
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_10_1.cs)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.HttpListener.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.DefaultServiceNames
  id: DefaultServiceNames
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Beolvassa a szolgáltató szolgáltatásnevek (SPN) alapértelmezett listáját, regisztrált előtagok alapján."
  remarks: "The DefaultServiceNames property is used with integrated Windows authentication to provide extended protection. The list of SPNs is initialized from the <xref:System.Net.HttpListener.Prefixes%2A> property when accessed and cleared when new prefixes are added to the <xref:System.Net.HttpListener.Prefixes%2A> property.  \n  \n The DefaultServiceNames property is used if an application doesn't set the <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> property on its extended protection policy.  \n  \n The <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> that is retrieved with the DefaultServiceNames property is built from the <xref:System.Net.HttpListener.Prefixes%2A> property according to the following rules:  \n  \n1.  If the hostname is \"+\", \"*\", or an IPv4 or IPv6 literal (equivalent to \"\\*\" but restricted to a specific local interface), the following SPN is added:  \n  \n `\"HTTP/\"` plus the fully qualified domain name of the computer.  \n  \n1.  If the hostname contains no dots (no domains or subdomains), an attempt is made to resolve the fully-qualified domain name using DNS (the same behavior used by <xref:System.Net.HttpWebRequest>). If the fully-qualified domain name can be resolved, the following SPNs are added:  \n  \n `\"HTTP/\"` plus the hostname (the short name).  \n  \n `\"HTTP/\"` plus the fully qualified domain name for the hostname.  \n  \n1.  If the hostname contains not dots (no domains or subdomains) and a fully-qualified domain name can't be resolved, the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n1.  If the hostname contains dots (domains or subdomains), the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n The DefaultServiceNames property can be used by an application to review the list of default SPNs which will be used for authentication if no custom list is supplied. If other SPNs are needed, an application can add them using one of the <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> methods.  \n  \n It is not safe when using extended protection to make policy decisions based on the requested URL, since this can be spoofed. Rather, applications should rely on the <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> or <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> properties to make such policy decisions."
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ServiceNameCollection&quot;> </xref> , amely egyszerű szolgáltatásnevek listáját tartalmazza."
  overload: System.Net.HttpListener.DefaultServiceNames*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  id: EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Egy bejövő ügyfélkérés lekérdezni egy aszinkron művelet befejeződik."
  remarks: "A EndGetContext metódus lehívásra kerül, általában az alkalmazás által meghatározott visszahívási metódus egy delegált beszerzése által meghívott belül a <xref:System.Net.HttpListenerContext>objektum, amely tartalmazza az bejövő ügyfélkérés és társított válaszában.</xref:System.Net.HttpListenerContext> Ez a metódus meghívásával korábban elindított egy műveletet befejezi a <xref:System.Net.HttpListener.BeginGetContext%2A>metódus.</xref:System.Net.HttpListener.BeginGetContext%2A> A művelet nem fejeződött be, ha ez a módszer letiltja a rendszer, amíg az hajtja végre.       Mivel a EndGetContext metódus hívása a <xref:System.Net.HttpListener>objektum, ez az objektum általában átad a egy visszahívási metódus által az állapot-objektum lett átadva a <xref:System.Net.HttpListener.BeginGetContext%2A>metódus.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener> Ezt úgy szerezheti be az állapot objektum használatával a <xref:System.IAsyncResult.AsyncState%2A>tulajdonsága a `asyncResult` objektum.</xref:System.IAsyncResult.AsyncState%2A>       Az aszinkron programozási modell használatával kapcsolatos részletes információkért lásd: [aszinkron szinkron módszerek hívja.](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example shows the implementation of a callback method that calls the EndGetContext method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_1_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Egy <xref:System.IAsyncResult>objektumot kapott az aszinkron művelet indításakor.</xref:System.IAsyncResult>"
    return:
      type: System.Net.HttpListenerContext
      description: "Egy <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> az ügyfélkérés képviselő objektum."
  overload: System.Net.HttpListener.EndGetContext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>nem sikerült beolvasni a meghívásával a <xref:System.Net.HttpListener.BeginGetContext*> metódust."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A EndGetContext metódust már meghívták a megadott <code> asyncResult </code> objektum."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  id: ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Beolvasni vagy megadni a <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> munkamenet kiterjesztett védelem használata."
  remarks: "Az ExtendedProtectionPolicy tulajdonságát szolgál az integrált Windows-hitelesítés kiterjesztett védelem biztosításához. Az ExtendedProtectionPolicy tulajdonság lehetővé teszi, hogy a kibővített védelmi házirend a teljes konfigurációjának <xref:System.Net.HttpListener>munkamenet.</xref:System.Net.HttpListener> A <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>tulajdonság lehetővé teszi, hogy minden egyes kérelem kibővített védelmi házirend beállításait.</xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>       A <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>tulajdonságnak kell lennie `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> A <xref:System.Net.HttpListener>példány lekérdezi a csatorna kötési jogkivonat (CBT) közvetlenül a saját TLS-munkamenet, ha van ilyen.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , amely megadja, hogy a házirend a bővített védelmet."
  overload: System.Net.HttpListener.ExtendedProtectionPolicy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Kísérlet történt a ExtendedProtectionPolicy tulajdonsága, de a <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>tulajdonság nem volt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Kísérlet történt a tulajdonsága ExtendedProtectionPolicy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kísérlet történt a ExtendedProtectionPolicy tulajdonsága után a <xref:System.Net.HttpListener.Start*>metódus már meg lett hívva.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>tulajdonságának beállítása <xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;> </xref> platformon, amely nem támogatja a bővített védelmet.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  id: ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Beolvasni vagy megadni a delegált nevű meghatározásához a <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> minden kérelem esetén használandó."
  remarks: "A <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>tulajdonság segítségével integrált Windows-hitelesítés adja meg a bővített védelmet.</xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> A <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>tulajdonság lehetővé teszi, hogy a kibővített védelmi házirend a teljes konfigurációjának <xref:System.Net.HttpListener>munkamenet.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> A ExtendedProtectionSelectorDelegate tulajdonság lehetővé teszi, hogy az egyes kérelmenként kibővített védelmi házirend beállításait.       A <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>tulajdonságnak kell lennie `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> A <xref:System.Net.HttpListener>példány lekérdezi a csatorna kötési jogkivonat (CBT) közvetlenül a saját TLS-munkamenet, ha van ilyen.</xref:System.Net.HttpListener>       Az egyes kérelmek a delegált választhatja a beállításokat, amelyek a <xref:System.Net.HttpListener>példányt fogja használni a kiterjesztett védelem biztosításához.</xref:System.Net.HttpListener>       Ha egy delegált függvény `null` ehhez a tulajdonsághoz jelképez egy <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>amely <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>.</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> tulajdonsága</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>"
  syntax:
    content: public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }
    return:
      type: System.Net.HttpListener.ExtendedProtectionSelector
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , amely megadja, hogy a házirend a bővített védelmet."
  overload: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Kísérlet történt a ExtendedProtectionSelectorDelegate tulajdonsága, de a <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>tulajdonságnak kell lennie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Kísérlet történt a tulajdonsága ExtendedProtectionSelectorDelegate <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kísérlet történt a ExtendedProtectionSelectorDelegate tulajdonsága után a <xref:System.Net.HttpListener.Start*>metódus már meg lett hívva.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Kísérlet történt a ExtendedProtectionSelectorDelegate tulajdonságának beállítása egy platform, amely nem támogatja a bővített védelmet."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContext
  id: GetContext
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Olyan bejövő kérelemre megvárja, és adja vissza, amikor egy érkezik."
  remarks: "A metódus meghívása előtt meg kell hívnia a <xref:System.Net.HttpListener.Start%2A>metódust, és adja hozzá a URI karakterlánc való hozzáadásával a figyelésére legalább egy URI-előtag a <xref:System.Net.HttpListenerPrefixCollection>által visszaadott a <xref:System.Net.HttpListener.Prefixes%2A>tulajdonság.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Előtagok részletes ismertetését lásd: a <xref:System.Net.HttpListener>osztály áttekintése.</xref:System.Net.HttpListener>       A metódus blokkok olyan bejövő kérelemre várakozás közben. Ha azt szeretné, hogy a bejövő kérelem feldolgozását aszinkron módon történik (külön szál), hogy nem blokkolja az alkalmazás, használja a <xref:System.Net.HttpListener.BeginGetContext%2A>metódus.</xref:System.Net.HttpListener.BeginGetContext%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_19_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext GetContext ();
    parameters: []
    return:
      type: System.Net.HttpListenerContext
      description: "Egy <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> egy ügyfél kérelmet képviselő objektum."
  overload: System.Net.HttpListener.GetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 függvény hívása nem sikerült. Ellenőrizze a kivétel <xref:System.Net.HttpListenerException.ErrorCode*>tulajdonság a kivétel a hiba okának megállapításához.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ez az objektum nem lett elindítva, vagy jelenleg le van állítva.       – vagy – a <xref href=&quot;System.Net.HttpListener&quot;> </xref> nem rendelkezik a egységes erőforrás-azonosító (URI) előtagokat válaszolni. Tekintse meg a megjegyzés."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContextAsync
  id: GetContextAsync
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Olyan bejövő kérelemre megvárja, mint egy aszinkron művelet."
  remarks: "Ez a művelet nem fogja tiltani. A visszaadott <xref:System.Threading.Tasks.Task%601>objektum befejeződik, ha a bejövő kérelem érkezett.</xref:System.Threading.Tasks.Task%601>       A metódus meghívása előtt meg kell hívnia a <xref:System.Net.HttpListener.Start%2A>metódust, és adja hozzá a URI karakterlánc való hozzáadásával a figyelésére legalább egy URI-előtag a <xref:System.Net.HttpListenerPrefixCollection>által visszaadott a <xref:System.Net.HttpListener.Prefixes%2A>tulajdonság.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Előtagok részletes ismertetését lásd: a <xref:System.Net.HttpListener>osztály áttekintése.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.HttpListenerContext> GetContextAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
      description: "Beolvasása &lt;xref:System.Threading.Tasks.Task%601&gt;.       Az aszinkron művelet képviselő feladat objektum. A &lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt; feladat objektum tulajdonságának adja vissza egy <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> egy ügyfél kérelmet képviselő objektum."
  overload: System.Net.HttpListener.GetContextAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  id: IgnoreWriteExceptions
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi vagy beállítja a <xref:System.Boolean>érték, amely meghatározza, hogy az alkalmazás megkapja-e a kivételeket, amelyek fordulhat elő, amikor egy <xref href=&quot;System.Net.HttpListener&quot;> </xref> visszaküldi a választ az ügyfélnek.</xref:System.Boolean>"
  remarks: "Ez a tulajdonság beállítása `true` Ha az alkalmazás nem igényli, hogy a válasz sikeresen elküldte-e az egyes ügyfelek."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_31_1.cs)]"
  syntax:
    content: public bool IgnoreWriteExceptions { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Net.HttpListener&quot;> </xref> nem adhat vissza kivételeket, amelyek akkor történik, ha a választ küld az ügyfélnek; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IgnoreWriteExceptions*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.IsListening
  id: IsListening
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi egy érték, amely azt jelzi, hogy <xref href=&quot;System.Net.HttpListener&quot;> </xref> el lett indítva."
  remarks: "Elindítani egy <xref:System.Net.HttpListener>, hívja az <xref:System.Net.HttpListener.Start%2A>metódus.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using this property to determine the listening state of an instance.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_41_1.cs)]"
  syntax:
    content: public bool IsListening { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Net.HttpListener&quot;> </xref> indult el, ha, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsListening*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IsSupported
  id: IsSupported
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi egy érték, amely azt jelzi, hogy <xref href=&quot;System.Net.HttpListener&quot;> </xref> az aktuális operációs rendszerrel használható."
  remarks: "Ez az osztály csak a Windows XP SP2 vagy Windows Server 2003 operációs rendszert futtató számítógépeken érhető el."
  example:
  - "The following code example demonstrates the use of the IsSupported property to detect whether an <xref:System.Net.HttpListener> object can be used with the current operating system.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/p-system.net.httplistene_21_1.cs)]"
  syntax:
    content: public static bool IsSupported { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha <xref href=&quot;System.Net.HttpListener&quot;> </xref> támogatott; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsSupported*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.Prefixes
  id: Prefixes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi az egységes erőforrás-azonosító (URI) előtagok által kezelt <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum."
  remarks: "Az előtagok kanonikus alakú. Előtagok részletes ismertetését lásd: a <xref:System.Net.HttpListener>osztály áttekintése.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Prefixes property to obtain and print the URI prefixes that are handled.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_24_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerPrefixCollection Prefixes { get; }
    return:
      type: System.Net.HttpListenerPrefixCollection
      description: "Egy <xref href=&quot;System.Net.HttpListenerPrefixCollection&quot;> </xref> , amely tartalmazza az URI Azonosítót, amelyhez a előtagok <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum van konfigurálva."
  overload: System.Net.HttpListener.Prefixes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.Realm
  id: Realm
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi vagy beállítja a tartomány, vagy az erőforrás partíció található, a társított <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum."
  remarks: "Kiszolgálók tartományok használják a védett erőforrások; particionálása Mindegyik partíció saját hitelesítési séma-és/vagy engedélyezési adatbázissal rendelkezhetnek. Tartományok használt csak az alapszintű és a kivonatoló hitelesítésben. Sikeresen hitelesíti az ügyfelet, miután a hitelesítést a rendszer az összes erőforrás a megadott tartomány érvénytelen. Tartományok részletes ismertetését lásd: RFC 2617: [http://www.ietf.org](http://www.ietf.org).       Példányának <xref:System.Net.HttpListener>csak egy társított tartomány van.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates setting the Realm property.  \n  \n [!code-cs[Net_Listener_Basic#10](~/add/codesnippet/csharp/p-system.net.httplistene_26_1.cs)]"
  syntax:
    content: public string Realm { get; set; }
    return:
      type: System.String
      description: "A <xref:System.String>érték, amely tartalmazza a társított a tartomány nevét a <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum.</xref:System.String>"
  overload: System.Net.HttpListener.Realm*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.Start
  id: Start
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Lehetővé teszi, hogy ez a példány bejövő kérelmek fogadására."
  remarks: "Ez a metódus meghívása előtt kell meghívni a <xref:System.Net.HttpListener.GetContext%2A>vagy <xref:System.Net.HttpListener.BeginGetContext%2A>metódus.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Miután elindította egy <xref:System.Net.HttpListener>objektumot, az <xref:System.Net.HttpListener.Stop%2A>eljárás azt.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Ha ez a figyelő példány HTTPS protokollt használ, akkor telepítse, és kiszolgálói tanúsítvány kiválasztása. Ellenkező esetben egy <xref:System.Net.HttpWebRequest>e lekérdezés <xref:System.Net.HttpListener>sikertelen lesz, és a kapcsolat egy váratlanul véget ért.</xref:System.Net.HttpListener> </xref:System.Net.HttpWebRequest> Kiszolgálói tanúsítványokat és más figyelő beállításokat konfigurálhatja a HttpCfg.exe használatával. Lásd: [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) további részleteket."
  example:
  - "The following code example demonstrates using the Start method to begin processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_12_1.cs)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.HttpListener.Start*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 függvény hívása nem sikerült. Ellenőrizze a kivétel <xref:System.Net.HttpListenerException.ErrorCode*>tulajdonság a kivétel a hiba okának megállapításához.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.Stop
  id: Stop
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Ez a példány kapni a bejövő kéréseket okoz."
  remarks: "Ez a példány már le van állítva, ha a metódus hívása nincs hatása.       Miután leállította az <xref:System.Net.HttpListener>objektumot, használhatja a <xref:System.Net.HttpListener.Start%2A>metódust, hogy újraindítsa.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Stop method to stop processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_5_1.cs)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.HttpListener.Stop*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  id: System#IDisposable#Dispose
  isEii: true
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Az erőforrásokat ennek birtokában kiadott <xref href=&quot;System.Net.HttpListener&quot;> </xref> objektum."
  remarks: "Alkalmazások használhatják a <xref:System.Net.HttpListener.Close%2A>metódus a metódus hívása helyett.</xref:System.Net.HttpListener.Close%2A>"
  syntax:
    content: void IDisposable.Dispose ();
    parameters: []
  overload: System.Net.HttpListener.System#IDisposable#Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.TimeoutManager
  id: TimeoutManager
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Ez időtúllépés kezelő <xref href=&quot;System.Net.HttpListener&quot;> </xref> példány."
  remarks: "Az időtúllépés meghatározza a kapcsolati időkorlát határt a <xref:System.Net.HttpListener>példány.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }
    return:
      type: System.Net.HttpListenerTimeoutManager
      description: "Returns <xref href=&quot;System.Net.HttpListenerTimeoutManager&quot;></xref>.       Ez időtúllépés kezelő <xref href=&quot;System.Net.HttpListener&quot;> </xref> példány."
  overload: System.Net.HttpListener.TimeoutManager*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  id: UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Lekérdezi vagy beállítja a <xref:System.Boolean>érték, amely szabályozza, NTLM használata esetén további kéréseket ugyanaz a Transmission Control Protocol (TCP) kapcsolaton keresztül csatlakoznak-e alapján hitelesíti.</xref:System.Boolean>"
  remarks: "Ha ez a tulajdonság értéke `true` és egy adott TCP-kapcsolaton keresztül az első kérelem hitelesítése NTLM használatával, a azonos TCP-kapcsolaton kéréseknél dolgoznak fel a hitelesítő adatok használata (<xref:System.Security.Principal.IIdentity>) a kezdeti kérés.</xref:System.Security.Principal.IIdentity>       Ez a tulajdonság nincs hatása, ha az NTLM nem a hitelesítési protokoll. Ha a hitelesítési protokoll egyeztetése van megadva, ezt a tulajdonságot van hatása, csak ha NTLM-hitelesítéshez használt a tényleges protokoll.      > [!NOTE] > Során ez a tulajdonság `true` növeli a teljesítményt, mivel a <xref:System.Net.HttpListener>nem nem küldési további NTLM hitelesítési kihívást, nincs biztonsági kockázatot nem igénylő összes kérelem megadnia hitelesítési adatokat.</xref:System.Net.HttpListener> Meg kell határoznia, hogy van-e a javítja a teljesítményt a kockázat-érdemes."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_34_1.cs)]"
  syntax:
    content: public bool UnsafeConnectionNtlmAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref:System.Security.Principal.IIdentity>az első kérelem lesz az azonos kapcsolaton kéréseknél szolgál; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Principal.IIdentity> Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ez az objektum le van zárva."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.HttpListenerException
  parent: System.Net
  isExternal: false
  name: HttpListenerException
  nameWithType: HttpListenerException
  fullName: System.Net.HttpListenerException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.HttpListener.#ctor
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
- uid: System.Net.HttpListener.Abort
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
- uid: System.Net.HttpListener.AuthenticationSchemes
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
- uid: System.Net.AuthenticationSchemes
  parent: System.Net
  isExternal: true
  name: AuthenticationSchemes
  nameWithType: AuthenticationSchemes
  fullName: System.Net.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.AuthenticationSchemeSelector
  parent: System.Net
  isExternal: false
  name: AuthenticationSchemeSelector
  nameWithType: AuthenticationSchemeSelector
  fullName: System.Net.AuthenticationSchemeSelector
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.HttpListener.Close
  parent: System.Net.HttpListener
  isExternal: false
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
- uid: System.Net.HttpListener.DefaultServiceNames
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
- uid: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ServiceNameCollection
  nameWithType: ServiceNameCollection
  fullName: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
- uid: System.Net.HttpListenerContext
  parent: System.Net
  isExternal: false
  name: HttpListenerContext
  nameWithType: HttpListenerContext
  fullName: System.Net.HttpListenerContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.ExtendedProtectionSelector
  parent: System.Net
  isExternal: false
  name: HttpListener+ExtendedProtectionSelector
  nameWithType: HttpListener+ExtendedProtectionSelector
  fullName: System.Net.HttpListener+ExtendedProtectionSelector
- uid: System.Net.HttpListener.GetContext
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
- uid: System.Net.HttpListener.GetContextAsync
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
- uid: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<HttpListenerContext>
  nameWithType: Task<HttpListenerContext>
  fullName: System.Threading.Tasks.Task<System.Net.HttpListenerContext>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.HttpListenerContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.HttpListenerContext
    name: HttpListenerContext
    nameWithType: HttpListenerContext
    fullName: HttpListenerContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.HttpListener.IsListening
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
- uid: System.Net.HttpListenerPrefixCollection
  parent: System.Net
  isExternal: false
  name: HttpListenerPrefixCollection
  nameWithType: HttpListenerPrefixCollection
  fullName: System.Net.HttpListenerPrefixCollection
- uid: System.Net.HttpListener.Realm
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.HttpListener.Start
  parent: System.Net.HttpListener
  isExternal: false
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
- uid: System.Net.HttpListener.Stop
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
- uid: System.Net.HttpListener.TimeoutManager
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
- uid: System.Net.HttpListenerTimeoutManager
  parent: System.Net
  isExternal: false
  name: HttpListenerTimeoutManager
  nameWithType: HttpListenerTimeoutManager
  fullName: System.Net.HttpListenerTimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
- uid: System.Net.HttpListener.#ctor*
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener
  nameWithType: HttpListener.HttpListener
- uid: System.Net.HttpListener.Abort*
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort
  nameWithType: HttpListener.Abort
- uid: System.Net.HttpListener.AuthenticationSchemes*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.HttpListener.BeginGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext
  nameWithType: HttpListener.BeginGetContext
- uid: System.Net.HttpListener.Close*
  parent: System.Net.HttpListener
  isExternal: false
  name: Close
  nameWithType: HttpListener.Close
- uid: System.Net.HttpListener.DefaultServiceNames*
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
- uid: System.Net.HttpListener.EndGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext
  nameWithType: HttpListener.EndGetContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.GetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext
  nameWithType: HttpListener.GetContext
- uid: System.Net.HttpListener.GetContextAsync*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync
  nameWithType: HttpListener.GetContextAsync
- uid: System.Net.HttpListener.IgnoreWriteExceptions*
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
- uid: System.Net.HttpListener.IsListening*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes*
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
- uid: System.Net.HttpListener.Realm*
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
- uid: System.Net.HttpListener.Start*
  parent: System.Net.HttpListener
  isExternal: false
  name: Start
  nameWithType: HttpListener.Start
- uid: System.Net.HttpListener.Stop*
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop
  nameWithType: HttpListener.Stop
- uid: System.Net.HttpListener.System#IDisposable#Dispose*
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose
  nameWithType: HttpListener.System.IDisposable.Dispose
- uid: System.Net.HttpListener.TimeoutManager*
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
