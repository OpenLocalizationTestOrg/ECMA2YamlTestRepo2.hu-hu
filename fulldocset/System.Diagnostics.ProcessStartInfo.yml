### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Domain
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - System.Diagnostics.ProcessStartInfo.ErrorDialog
  - System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.LoadUserProfile
  - System.Diagnostics.ProcessStartInfo.Password
  - System.Diagnostics.ProcessStartInfo.PasswordInClearText
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UserName
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.Verb
  - System.Diagnostics.ProcessStartInfo.Verbs
  - System.Diagnostics.ProcessStartInfo.WindowStyle
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  summary: "Adja meg a folyamat elindításához használt értékek."
  remarks: "ProcessStartInfo együtt használja a <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> Indításkor a folyamat használja a <xref:System.Diagnostics.Process>osztály, Ön hozzáférhet mellett áll rendelkezésre információ akkor dolgozza fel, ha egy futó folyamatot csatolása.</xref:System.Diagnostics.Process>       Használhatja a ProcessStartInfo osztály több elindítja a folyamatot. Legalább meg kell adni a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság, vagy manuálisan, vagy használja a konstruktort.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A fájlnév pedig bármilyen alkalmazást vagy dokumentumot. Itt egy dokumentumot a megnyitott fájltípust vagy alapértelmezett társítva művelet van definiálva. Megtekintheti regisztrált fájltípusok és a hozzájuk tartozó alkalmazásokat a számítógép segítségével a **mappa beállításai** párbeszédpanelt, amely az operációs rendszeren keresztül érhető el. A **speciális** gombra egy párbeszédpanelt, amely jelzi, hogy egy bizonyos regisztrált fájltípus társított nyitott művelet eredménye.       Emellett beállíthat egyéb műveleteket ezzel a fájllal meghatározó tulajdonságok biztosítása. Egy adott típusának értéket is megadhat a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonságát a <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Megadhatja például, &quot;nyomtatása&quot; egy típus. Emellett megadhatja <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>tulajdonság értékét, hogy azok a fájl megnyitása eljárás parancssori argumentumokat.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Például, ha megad egy text editor alkalmazást a a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság, használhatja a <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>kell megnyitni a szerkesztő szövege fájlt megadó tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Szabványos bemeneti általában a billentyűzet, és standard kimenet és a standard hiba általában a képernyőt. Azonban használhatja a <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, és <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>Tulajdonságok a folyamat az beszerzése bemeneti vagy kimeneti egy fájl vagy más eszköz okozza.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> Ha használja a <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, vagy <xref:System.Diagnostics.Process.StandardError%2A>tulajdonságainak a <xref:System.Diagnostics.Process>összetevő, először meg kell adnia a megfelelő értékkel ProcessStartInfo tulajdonság.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.StandardInput%2A> Ellenkező esetben a rendszer kivételt olvasni vagy írni az adatfolyam.       Állítsa be <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>megadhatja, hogy a folyamat elindításához az operációs rendszer parancsértelmezőjét használatával.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Módosíthatja a ProcessStartInfo tulajdonság idejével, hogy a folyamat elindul. A folyamat megkezdése után ezek az értékek módosítása nem befolyásolja.      > [!NOTE] > Ez az osztály tartalmaz egy hivatkozást igény szerint az összes tagjára érvényes osztály szintjén. A <xref:System.Security.SecurityException>fordul elő, amikor a közvetlen hívónak nincs engedélye teljesen megbízható.</xref:System.Security.SecurityException> További biztonsági követelményeivel kapcsolatos további információkért lásd: [hivatkozás iránti igények kielégítése érdekében](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to use the ProcessStartInfo class to start Internet Explorer, providing the destination URLs as ProcessStartInfo arguments.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]

      public sealed class ProcessStartInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> osztály egy fájlnevet, a folyamat elindításához használt megadása nélkül."
  remarks: "Meg kell adni legalább a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság a folyamat megkezdése előtt.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A fájlnév pedig bármilyen alkalmazást vagy dokumentumot. Ebben az esetben egy dokumentumot a megnyitott fájltípust vagy alapértelmezett művelet társítva van meghatározva. Megtekintheti regisztrált fájltípusok és a hozzájuk tartozó alkalmazásokat a számítógép segítségével a **mappa beállításai** párbeszédpanelt, amely az operációs rendszeren keresztül érhető el. A **speciális** gombra egy párbeszédpanelt, amely jelzi, hogy egy bizonyos regisztrált fájltípus társított nyitott művelet eredménye.       Szükség esetén is beállíthat más tulajdonságok a folyamat megkezdése előtt. A <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>tulajdonság megadja az műveleteket kell elvégezni, például a &quot;print&quot;, a fájl szerepelnek a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.ProcessStartInfo.Verb%2A> A <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>tulajdonság megadja az olyan módon felelt meg a parancssori paraméterek, a fájlt, amikor a rendszer megnyitja azt.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>"
  syntax:
    content: public ProcessStartInfo ();
    parameters: []
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> osztályhoz, és adja meg egy fájlnevet, például egy alkalmazást vagy dokumentumot. a folyamat elindításához használt."
  remarks: "A fájlnév pedig bármilyen alkalmazást vagy dokumentumot. Ebben az esetben egy dokumentumot a megnyitott fájltípust vagy alapértelmezett művelet társítva van meghatározva. Megtekintheti regisztrált fájltípusok és a hozzájuk tartozó alkalmazásokat a számítógép segítségével a **mappa beállításai** párbeszédpanelt, amely az operációs rendszeren keresztül érhető el. A **speciális** gombra egy párbeszédpanelt, amely jelzi, hogy egy bizonyos regisztrált fájltípus társított nyitott művelet eredménye.       Módosíthatja a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság idejével, hogy a folyamat elindul, a konstruktor hívása után.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A folyamat megkezdése után ezek az értékek módosítása nem befolyásolja."
  syntax:
    content: public ProcessStartInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Egy alkalmazás vagy a folyamat elindításához használt dokumentum."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> osztály, egy alkalmazás, amellyel a folyamat nevét adja meg, és itt adhatja meg az alkalmazás parancssori argumentumokat."
  remarks: "A fájlnév pedig bármilyen alkalmazást vagy dokumentumot. Ebben az esetben egy dokumentumot a megnyitott fájltípust vagy alapértelmezett művelet társítva van meghatározva. Megtekintheti regisztrált fájltípusok és a hozzájuk tartozó alkalmazásokat a számítógép segítségével a **mappa beállításai** párbeszédpanelt, amely az operációs rendszeren keresztül érhető el. A **speciális** gombra egy párbeszédpanelt, amely jelzi, hogy egy bizonyos regisztrált fájltípus társított nyitott művelet eredménye.       Módosíthatja a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>vagy <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>Tulajdonságok idejével, hogy a folyamat elindul, a konstruktor hívása után.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A folyamat megkezdése után ezek az értékek módosítása nem befolyásolja."
  syntax:
    content: public ProcessStartInfo (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "A folyamat elindításához használt alkalmazás."
    - id: arguments
      type: System.String
      description: "Parancssori argumentumok átadása az alkalmazást, a folyamat indításakor."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a parancssori argumentumokat használni az alkalmazás indításakor készletét."
  remarks: ''
  example:
  - "The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.  \n  \n [!code-vb[Process.Start_static#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#3](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_1.cpp)]  \n  \n [!code-vb[Process.Start_static#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_2.vb)]\n [!code-cs[Process.Start_static#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_2.cs)]\n [!code-cpp[Process.Start_static#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_2.cpp)]"
  syntax:
    content: public string Arguments { get; set; }
    return:
      type: System.String
      description: "A megadott célalkalmazásnak történő argumentumokat tartalmazó egyetlen karakterláncot a <xref:System.Diagnostics.ProcessStartInfo.FileName*>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName*> Az alapértelmezett érték egy üres karakterlánc (&quot;&quot;). A Windows Vista és a Windows operációs rendszer korábbi verzióiban a folyamat teljes elérési útja hosszának hozzáadott argumentum hossza kisebb, mint 2080 kell lennie. A Windows 7 és újabb verziókban a hossza kisebb, mint 32699 kell lennie.       Argumentumok értelmezni, és a célalkalmazás, így kell megfelel-e az alkalmazás követelményeinek értelmezi. Az alábbi példák az egy For.NET alkalmazások, például szóközöket több argumentum elválasztására értelmezi. Egy egyetlen argumentum szóközt tartalmaz, idézőjelek között kell lennie.%n, de ezek idézőjelek közé vannak nem végzett a célalkalmazás. A tartalmazza az idézőjelek közé a végleges elemezni argumentum, háromszoros-escape minden be van jelölve."
  overload: System.Diagnostics.ProcessStartInfo.Arguments*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi, hogy egy új ablakban a folyamat elindításához."
  remarks: "Ha a <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>tulajdonság `true` vagy a <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>és <xref:System.Diagnostics.ProcessStartInfo.Password%2A>tulajdonság `null`, a CreateNoWindow tulajdonság értékét a rendszer figyelmen kívül hagyja, és egy új ablak jön létre.</xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_19_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_19_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_19_1.cs)]
  syntax:
    content: public bool CreateNoWindow { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha nem kíván létrehozni egy új ablak; a folyamat el kell kezdődnie Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Domain
  id: Domain
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely azonosítja a tartomány, a folyamat indításakor használja."
  syntax:
    content: public string Domain { get; set; }
    return:
      type: System.String
      description: "A folyamat indításakor használja az Active Directory-tartomány. A tartomány tulajdonság elsősorban az egyik fontos vállalati környezetekben, amelyek az Active Directory használata a felhasználók számára."
  overload: System.Diagnostics.ProcessStartInfo.Domain*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a környezeti változókat, amelyek ezt a folyamatot és annak alárendelt vonatkozik."
  remarks: "The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the Environment property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: `myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")`.  You must set the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property to `false` to start the process after changing the Environment property. If <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, an <xref:System.InvalidOperationException> is thrown when the <xref:System.Diagnostics.Process.Start%2A> method is called.  \n  \n On .NET Framework applications, using the Environment property is the same as using the <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> property."
  syntax:
    content: public System.Collections.Generic.IDictionary<string,string> Environment { get; }
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
      description: "A környezeti változókat, amelyek érvényesek a folyamat és annak alárendelt tartalmazó általános dictionary. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.Environment*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  id: EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi fájlok elérési útja, könyvtárak ideiglenes fájlok, az alkalmazás-specifikus beállításokat és egyéb hasonló információk keresése."
  remarks: 'Bár a változók tulajdonság nem állítható, módosíthatja a <xref:System.Collections.Specialized.StringDictionary>tulajdonság által visszaadott.</xref:System.Collections.Specialized.StringDictionary> Például az alábbi kód létrehozza a TEMPPATH tulajdonság környezeti változót: `myProcess.StartInfo.EnvironmentVariables.Add(&quot;TempPath&quot;, &quot;C:\\Temp&quot;)`.  Meg kell adni a <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>tulajdonságot `false` a folyamat elindításához a változók tulajdonság módosítása után.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ha <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>van `true`, egy <xref:System.InvalidOperationException>vált ki, ha a <xref:System.Diagnostics.Process.Start%2A>metódust.</xref:System.Diagnostics.Process.Start%2A> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>'
  syntax:
    content: public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }
    return:
      type: System.Collections.Specialized.StringDictionary
      description: "Egy karakterlánc szótár, amely környezeti változókat, amelyek alkalmazása ehhez a folyamathoz és gyermekeihez tartoznak. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  id: ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely egy hiba-párbeszédpanel megjelenik-e a felhasználó számára, ha a folyamat nem indítható el."
  remarks: >-
    > [!NOTE]

    >  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> must be `true` if you want to set ErrorDialog to `true`.
  syntax:
    content: public bool ErrorDialog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha egy párbeszédablak üzenetnek kell megjelennie a képernyőn, ha a folyamat nem indítható el; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  id: ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja az ablakleíró használni, amikor egy párbeszédablak jelenik meg, amely nem lehet elindítani a folyamatot."
  remarks: "Ha <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>van `true`, a ErrorDialogParentHandle tulajdonság határozza meg a párbeszédpanelen látható szülő ablakának.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> Akkor célszerű adja meg a párbeszédpanelen, az alkalmazás előtt tartása szülője."
  syntax:
    content: public IntPtr ErrorDialogParentHandle { get; set; }
    return:
      type: System.IntPtr
      description: "A hiba-párbeszédpanel, hogy egy folyamat eredményeinek indítása sikertelen leíróját mutató hivatkozások."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja az alkalmazás és a dokumentumok elindításához."
  remarks: "Meg kell adni legalább a FileName tulajdonságban a folyamat megkezdése előtt. A fájlnév pedig bármilyen alkalmazást vagy dokumentumot. A dokumentum bármilyen fájltípus, amely a megnyitott vagy alapértelmezett társítva művelet van definiálva. Megtekintheti regisztrált fájltípusok és a hozzájuk tartozó alkalmazásokat a számítógép segítségével a **mappa beállításai** párbeszédpanelt, amely az operációs rendszeren keresztül érhető el. A **speciális** gombra egy párbeszédpanelt, amely jelzi, hogy egy bizonyos regisztrált fájltípus társított nyitott művelet eredménye.       A használható fájltípusok készlete függ értékének a <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ha <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>van `true`, indítsa el a dokumentum, és a fájl, nyomtatás, például a műveleteket a <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ha <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>van `false`, csak a végrehajtható fájlokat is elindítható a <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Olyan ClickOnce alkalmazásokhoz megkezdheti úgy, hogy a FileName tulajdonságban a helyre (például egy webcímet), ahonnan eredetileg telepítette az alkalmazást. A ClickOnce alkalmazáshoz nem indulnak el megadásával a telepítés helyén a merevlemezen."
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_27_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_27_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_27_1.cs)]
  syntax:
    content: public string FileName { get; set; }
    return:
      type: System.String
      description: "Indítsa el az alkalmazás neve, vagy a fájl típusa, amely társítva van egy alkalmazást, és, amely rendelkezik a művelet számára elérhető nyissa meg az alapértelmezett dokumentum neve. Az alapértelmezett érték egy üres karakterlánc (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.FileName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  id: LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely azt jelzi, hogy a Windows-felhasználói profil betöltését a beállításjegyzékből."
  remarks: "Ez a tulajdonság hivatkoznak, ha a folyamat elindul a felhasználónév, jelszó és tartomány segítségével.       Ha az érték `true`, a profil a `HKEY_USERS` beállításkulcs be van töltve. A profil betöltését időigényes lehet. Ezért célszerű használni ezt az értéket csak akkor, ha az információk kell elérnie a `HKEY_CURRENT_USER` beállításkulcsot.       A Windows Server 2003 és Windows 2000 a profil nincs betöltve az új folyamat megszakítása után, függetlenül attól, hogy a folyamat hozott létre gyermek folyamatokat.       A Windows XP a profil nincs betöltve az új folyamat után, és hozott létre az összes alárendelt folyamata leállítva."
  syntax:
    content: public bool LoadUserProfile { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha be kell tölteni a Windows-felhasználói profil; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Password
  id: Password
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a biztonságos karakterláncot, amely tartalmazza a felhasználói jelszavát használja, ha a folyamat elindítása."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and Password are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n> [!NOTE]\n>  Setting the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, and the Password properties in a <xref:System.Diagnostics.ProcessStartInfo> object is the recommended practice for starting a process with user credentials.  \n  \n A <xref:System.Security.SecureString> object is like a <xref:System.String> object in that it has a text value. However, the value of a <xref:System.Security.SecureString> object is automatically encrypted, it can be modified until your application marks it as read-only, and it can be deleted from computer memory by either your application or the .NET Framework garbage collector.  \n  \n For more information about secure strings and an example of how to obtain a password to set this property, see the <xref:System.Security.SecureString> class.  \n  \n> [!NOTE]\n>  If you provide a value for the Password property, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public System.Security.SecureString Password { get; set; }
    return:
      type: System.Security.SecureString
      description: "A felhasználói jelszó használja, ha a folyamat elindítása."
  overload: System.Diagnostics.ProcessStartInfo.Password*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  id: PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a felhasználó jelszavát a folyamat indításakor használja az egyszerű szöveges."
  syntax:
    content: public string PasswordInClearText { get; set; }
    return:
      type: System.String
      description: "A jelszó nyílt szövegként."
  overload: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdez vagy beállít egy értéket, amely azt jelzi, hogy az alkalmazás kimenete hiba van a &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt; adatfolyamot."
  remarks: "Ha egy <xref:System.Diagnostics.Process>szöveg ír a szabványos hibaadatfolyam, hogy az általában üzenet jelenik meg a konzolon.</xref:System.Diagnostics.Process> Irányítják a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam, kezelheti, vagy ne jelenjen meg többé a folyamat hiba kimenő.</xref:System.Diagnostics.Process.StandardError%2A> Például a szöveg szűrése, másképp formázza, vagy kiírhatja a kimenetet a konzol és a kijelölt naplófájl.      > [!NOTE] > Be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>való `false` Ha be szeretné állítani a RedirectStandardError `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ellenkező esetben olvasásakor a <xref:System.Diagnostics.Process.StandardError%2A>stream kivételt jelez.</xref:System.Diagnostics.Process.StandardError%2A>       Az átirányított <xref:System.Diagnostics.Process.StandardError%2A>szinkron vagy aszinkron módon olvasható adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A> Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a folyamat a hiba kimeneti adatfolyam.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>ír a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Ezzel szemben <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>aszinkron elindul az olvasási műveletek a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Ez a módszer lehetővé teszi, hogy az adatfolyam-kimenetét a megadott eseménykezelőt, és azonnal visszaadja a hívónak, amely más feladatok is hajtható végre, amíg az eseménykezelő irányul, az adatfolyam-kimenetét.      > [!NOTE] > Az aszinkron kimeneti feldolgozó meg kell hívnia a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer annak biztosítására, hogy a kimeneti puffer ki lettek ürítve.</xref:System.Diagnostics.Process.WaitForExit%2A>       Szinkron olvasási műveletek bevezetni a hívó olvasásakor közötti függőség a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam és a gyermek folyamat adott adatfolyamba való írás.</xref:System.Diagnostics.Process.StandardError%2A> Ezeket a függőségeket feltételek holtpontot okozhat. Amikor a hívó olvassa be az egyik gyermekfolyamata átirányított adatfolyamot, nem a gyermek függ. A hívó az olvasási művelet megvárja, amíg a gyermek a adatfolyamba ír, vagy bezárja az adatfolyam. A gyermek folyamat kevés az adat a töltse ki az átirányított adatfolyam ír, esetén a fölérendelt függ. A gyermekfolyamat a következő írási művelet megvárja, amíg a szülő olvassa be a teljes adatfolyam, vagy bezárja az adatfolyam. A holtpont feltétel ad eredményt, ha a hívó és gyermekfolyamat Várakozás egymással elvégezni egy műveletet, és továbbra sem. A hívó és gyermekfolyamat közötti függőségek kiértékelésével elkerülheti a holtpont.       Például az alábbi C# kód bemutatja, hogyan átirányított adatfolyamból beolvasott, és várja meg a gyermek-folyamat kilép.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```A Kódpélda holtpontra elkerülhető meghívásával `p.StandardError.ReadToEnd` előtt `p.WaitForExit`. Holtpontra okozhat, ha a szülő feldolgozási hívások `p.WaitForExit` előtt `p.StandardError.ReadToEnd` és a gyermek folyamat ír az átirányított adatfolyam bevitt. A szülő folyamat határozatlan ideig Várakozás volna a gyermekfolyamat való kilépéshez. A gyermekfolyamat határozatlan vár volna olvasni a teljes szülő <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A>       Probléma van, ha a standard kimenet és a standard hiba adatfolyamok olvassa el az összes szöveget. Például az alábbi C#-kódban végez a két adatfolyam egy olvasási művelet.      ```   // Do not perform a synchronous read to the end of both   // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```A Kódpélda elvégzésével aszinkron olvasási művelet a Ezzel elkerülheti a holtpontra a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> Holtpontra eredménye, ha a szülő feldolgozási hívások `p.StandardOutput.ReadToEnd` követ `p.StandardError.ReadToEnd` és a gyermek folyamat ír a hibafolyam bevitt. A szülő folyamat lenne várakozást a gyermekfolyamat bezárásához a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> A gyermekfolyamat határozatlan vár volna olvasni a teljes szülő <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A>       Aszinkron olvasási műveleteknél használhatja ezeket a függőségeket és azok holtpont lehetséges elkerülése érdekében. Alternatív megoldásként úgy kerülheti el a holtpontra két szálak létrehozása és az egyes adatfolyamokkal külön szálban kimenetének olvasása során."
  example:
  - "The following example uses the `net use` command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_31_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_31_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_31_1.vb)]"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha lehet írni a kimeneti hiba &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi, hogy a bemeneti alkalmazás olvasása az a &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt; adatfolyam."
  remarks: "A <xref:System.Diagnostics.Process>beviteli olvashatók be a szabványos bemeneti folyama, általában a billentyűzet.</xref:System.Diagnostics.Process> Irányítják a <xref:System.Diagnostics.Process.StandardInput%2A>adatfolyam, programozott módon adja meg a folyamat a bemeneti.</xref:System.Diagnostics.Process.StandardInput%2A> Például bevitel a billentyűzetről helyett megadhatja a kijelölt fájl tartalmát a szöveg vagy egy másik alkalmazás.      > [!NOTE] > Be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>való `false` Ha be szeretné állítani a RedirectStandardInput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ellenkező esetben írása a <xref:System.Diagnostics.Process.StandardInput%2A>adatfolyam kivételt jelez.</xref:System.Diagnostics.Process.StandardInput%2A>"
  example:
  - "The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process. The `sort` command is a console application that reads and sorts text input.  \n  \n The example starts the `sort` command with redirected input. It then prompts the user for text, and passes the text to the `sort` process through the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_43_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_43_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_43_1.vb)]"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a bemeneti olvassa el a &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdez vagy beállít egy értéket, amely azt jelzi, hogy az alkalmazás a szöveges kimenet van a &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt; adatfolyam."
  remarks: "Ha egy <xref:System.Diagnostics.Process>szöveg ír a szabványos adatfolyam, hogy az általában üzenet jelenik meg a konzolon.</xref:System.Diagnostics.Process> RedirectStandardOutput értékre állításával `true` átirányítani a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam, kezelheti, vagy ne jelenjen meg többé a folyamat kimenetét.</xref:System.Diagnostics.Process.StandardOutput%2A> Például a szöveg szűrése, másképp formázza, vagy kiírhatja a kimenetet a konzol és a kijelölt naplófájl.      > [!NOTE] > Be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>való `false` Ha be szeretné állítani a RedirectStandardOutput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ellenkező esetben olvasásakor a <xref:System.Diagnostics.Process.StandardOutput%2A>stream kivételt jelez.</xref:System.Diagnostics.Process.StandardOutput%2A>       Az átirányított <xref:System.Diagnostics.Process.StandardOutput%2A>szinkron vagy aszinkron módon olvasható adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a kimeneti adatfolyamba, a folyamat.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>ír a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Ezzel szemben <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>aszinkron elindul az olvasási műveletek a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Ez a módszer lehetővé teszi, hogy a kijelölt eseménykezelő (lásd: <xref:System.Diagnostics.Process.OutputDataReceived>) az adatfolyam-kimenetét pedig azonnal visszaadja a hívó, amely képes végezze el más feladatok közben az adatfolyam-kimenetét van irányítva az eseménykezelő.</xref:System.Diagnostics.Process.OutputDataReceived>      > [!NOTE] > Az aszinkron kimeneti feldolgozó meg kell hívnia a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer annak biztosítására, hogy a kimeneti puffer ki lettek ürítve.</xref:System.Diagnostics.Process.WaitForExit%2A>       Szinkron olvasási műveletek bevezetni a hívó olvasásakor közötti függőség a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam és a gyermek folyamat adott adatfolyamba való írás.</xref:System.Diagnostics.Process.StandardOutput%2A> Ezeket a függőségeket feltételek holtpontot okozhat. Amikor a hívó olvassa be az egyik gyermekfolyamata átirányított adatfolyamot, nem a gyermek függ. A hívó az olvasási művelet megvárja, amíg a gyermek a adatfolyamba ír, vagy bezárja az adatfolyam. A gyermek folyamat kevés az adat a töltse ki az átirányított adatfolyam ír, esetén a fölérendelt függ. A gyermekfolyamat a következő írási művelet megvárja, amíg a szülő olvassa be a teljes adatfolyam, vagy bezárja az adatfolyam. A holtpont feltétel ad eredményt, ha a hívó és gyermekfolyamat Várakozás egymással elvégezni egy műveletet, és továbbra sem. A hívó és gyermekfolyamat közötti függőségek kiértékelésével elkerülheti a holtpont.       Például az alábbi C# kód bemutatja, hogyan átirányított adatfolyamból beolvasott, és várja meg a gyermek-folyamat kilép.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```A Kódpélda holtpontra elkerülhető meghívásával `p.StandardOutput.ReadToEnd` előtt `p.WaitForExit`. Holtpontra okozhat, ha a szülő feldolgozási hívások `p.WaitForExit` előtt `p.StandardOutput.ReadToEnd` és a gyermek folyamat ír az átirányított adatfolyam bevitt. A szülő folyamat határozatlan ideig Várakozás volna a gyermekfolyamat való kilépéshez. A gyermekfolyamat határozatlan vár volna olvasni a teljes szülő <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A>       Probléma van, ha a standard kimenet és a standard hiba adatfolyamok olvassa el az összes szöveget. Például az alábbi C#-kódban végez a két adatfolyam egy olvasási művelet.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```A Kódpélda elvégzésével aszinkron olvasási művelet a Ezzel elkerülheti a holtpontra a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> Holtpontra eredménye, ha a szülő feldolgozási hívások `p.StandardOutput.ReadToEnd` követ `p.StandardError.ReadToEnd` és a gyermek folyamat ír a hibafolyam bevitt. A szülő folyamat lenne várakozást a gyermekfolyamat bezárásához a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> A gyermekfolyamat határozatlan vár volna olvasni a teljes szülő <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A>       Aszinkron olvasási műveleteknél használhatja ezeket a függőségeket és azok holtpont lehetséges elkerülése érdekében. Alternatív megoldásként úgy kerülheti el a holtpontra két szálak létrehozása és az egyes adatfolyamokkal külön szálban kimenetének olvasása során."
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_20_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_20_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_20_1.vb)]
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha lehet írni a kimeneti &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a kimeneti hiba történt az alapértelmezett kódolás."
  remarks: "Ha a StandardErrorEncoding tulajdonság értéke `null`, a folyamat használja az alapértelmezett standard hiba kódolást kimeneti hiba. A StandardErrorEncoding tulajdonság a folyamat megkezdése előtt kell beállítani. A tulajdonság beállítása nem garantálja, hogy a folyamat fogja használni, a megadott kódolásnak; a folyamat csak a általa támogatott kódolások fogja használni. Az alkalmazás támogatja-e mely kódolások kell vizsgálni."
  syntax:
    content: public System.Text.Encoding StandardErrorEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "Hiba történt a kimenet a kódolás képviselő objektum. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a szabványos kimeneti az alapértelmezett kódolás."
  remarks: "Ha a StandardOutputEncoding tulajdonság értéke `null`, a folyamat használja az alapértelmezett szabványos kimeneti kódolást a normál a kimenetbe. A StandardOutputEncoding tulajdonság a folyamat megkezdése előtt kell beállítani. A tulajdonság beállítása nem garantálja, hogy a folyamat fogja használni, a megadott kódolásnak. Az alkalmazás mely kódolások, a folyamat támogatja az meghatározásához kell vizsgálni."
  syntax:
    content: public System.Text.Encoding StandardOutputEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "A szabványos kimeneti kódolás képviselő objektum. Az alapértelmezett érték <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UserName
  id: UserName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a felhasználó nevét kell használni, ha a folyamat elindítása."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if UserName and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the UserName property is not `null` or an empty string, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public string UserName { get; set; }
    return:
      type: System.String
      description: "A felhasználó nevét, amikor a folyamat elindítása."
  overload: System.Diagnostics.ProcessStartInfo.UserName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi, hogy az operációs rendszer parancsértelmezőjét segítségével elindíthatja a folyamatot."
  remarks: "Ez a tulajdonság `false` bemeneti, kimeneti és adatfolyamok irányíthatja.      > [!NOTE] > UseShellExecute kell `false` Ha a <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>tulajdonság értéke nem `null` vagy üres karakterlánc, vagy egy <xref:System.InvalidOperationException>fog jelezni, amikor a <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName>metódust.</xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A>       Amikor az operációs rendszer parancsértelmezőjét folyamat elindításához használt, indítsa el a dokumentum (amely bármilyen, amely rendelkezik egy alapértelmezett Megnyitás művelet végrehajtható társított regisztrált fájltípus), és használatával a fájl, nyomtatás, például műveleteket a <xref:System.Diagnostics.Process>objektum.</xref:System.Diagnostics.Process> Ha UseShellExecute van `false`, megkezdheti a csak a végrehajtható fájlok használatával a <xref:System.Diagnostics.Process>objektum.</xref:System.Diagnostics.Process>      > [!NOTE] > UseShellExecute kell `true` Ha bekapcsolja a <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>tulajdonságot `true`.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>       A <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>tulajdonság másképp úgy viselkedik, attól függően, hogy a UseShellExecute tulajdonság értéke.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Ha a UseShellExecute van `true`, a <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>tulajdonság határozza meg a végrehajtható fájl helyét.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Ha <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>üres karakterlánc, feltételezzük, hogy az aktuális könyvtár tartalmazza-e a végrehajtható fájl.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>       Ha a UseShellExecute van `false`, a <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>tulajdonság nem lehet megtalálni a végrehajtható fájl.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Ehelyett használják csak a folyamat elindul, és csak az új folyamat keretében jelentése. Ha a UseShellExecute van `false`, a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság is lehet, vagy a végrehajtható fájl teljes elérési útját, vagy egy egyszerű végrehajtható fájljának nevét, a rendszer megpróbálja belül az elérési út környezeti változóban megadott mappákban található.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_44_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_44_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_44_1.vb)]
  syntax:
    content: public bool UseShellExecute { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a rendszerhéj kell használni, amikor a folyamat; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha a folyamat közvetlenül a végrehajtható fájl kell létrehozni. Az alapértelmezett érték <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verb
  id: Verb
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a művelet az alkalmazás vagy a meghatározott dokumentumra megnyitásakor használandó a <xref:System.Diagnostics.ProcessStartInfo.FileName*>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "Minden egyes kiterjesztésű saját rendelkezik a műveleteket, amelyek segítségével érhető el a <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Például a &quot;`print`&quot; művelet nyomtatás <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> használatával meg Az alapértelmezett művelet adható meg üres karakterláncot használatával (&quot;&quot;). A műveletek többek között a &quot;Szerkesztés&quot;, &quot;Nyílt&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; és &quot;Printto&quot;. Csak azok a műveletek jelennek meg a művelet által visszaadott készletében kell használnia a <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       A művelet tulajdonság használata esetén meg kell adni a fájlnévkiterjesztést, értékének beállításakor a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A fájlnév nem kell kiterjesztéssel rendelkeznek, ha manuálisan egy értéket ad meg a műveletet a tulajdonsághoz."
  example:
  - "The following code example starts a new process by using the specified verb and file name. This code example is part of a larger example provided for the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#4](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_9_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#4](~/add/codesnippet/csharp/p-system.diagnostics.pro_9_1.cs)]"
  syntax:
    content: public string Verb { get; set; }
    return:
      type: System.String
      description: "A fájlt, amely a folyamat végrehajtásakor megnyílik a végrehajtandó műveletet. Az alapértelmezett érték egy üres karakterlánc (&quot;&quot;), amely azt jelzi, hogy semmilyen műveletet."
  overload: System.Diagnostics.ProcessStartInfo.Verb*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  id: Verbs
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A fájl által megadott típushoz tartozó műveletek készletét lekérdezi a <xref:System.Diagnostics.ProcessStartInfo.FileName*>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "A műveletek tulajdonság lehetővé teszi a HTTP-parancsokat által megadott fájl használható a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Beállíthatja a <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>tulajdonság értékét a művelet a készletben.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> A műveletek többek között a &quot;Szerkesztés&quot;, &quot;Nyílt&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; és &quot;Printto&quot;.       A műveletek tulajdonság használata esetén meg kell adni a fájlnévkiterjesztést, értékének beállításakor a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A fájlnévkiterjesztés határozza meg a lehetséges műveleteket."
  example:
  - "The following code example displays the defined verbs for the chosen file name. If the user selects one of the defined verbs, the example starts a new process using the selected verb and the input file name.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_7_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_7_1.cs)]"
  syntax:
    content: public string[] Verbs { get; }
    return:
      type: System.String[]
      description: "A műveletek, a rendszer alkalmazhat a fájl azt a <xref:System.Diagnostics.ProcessStartInfo.FileName*>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  overload: System.Diagnostics.ProcessStartInfo.Verbs*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  id: WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a folyamat indításakor használandó ablakának állapotát."
  remarks: ''
  example:
  - >-
    [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_42_1.vb)]
     [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_42_1.cs)]
     [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_42_1.cpp)]
  syntax:
    content: public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }
    return:
      type: System.Diagnostics.ProcessWindowStyle
      description: "Számbavételi érték, amely jelzi, hogy elindult-e a folyamat egy ablakban, a teljes méretű, kis méretű, normál (egyik sem teljes méretű és kis méretű), vagy nem látható. Az alapértelmezett érték <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.WindowStyle*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Az ablak stílus nem szerepel a <xref href=&quot;System.Diagnostics.ProcessWindowStyle&quot;> </xref> számbavétel tagjainak."
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ha a <> </> *> tulajdonság <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, lekérdezi vagy beállítja a munkakönyvtár kell elindítani a folyamatot. Ha <> </> *> van <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, lekérdezi vagy beállítja a kell elindítani a folyamatot tartalmazó könyvtár."
  remarks: "> [!IMPORTANT]\n>  The WorkingDirectory property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.  \n  \n The WorkingDirectory property behaves differently when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` than when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the WorkingDirectory property specifies the location of the executable. If WorkingDirectory is an empty string, the current directory is understood to contain the executable.  \n  \n> [!NOTE]\n>  When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the working directory of the application that starts the executable is also the working directory of the executable.  \n  \n When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`, the WorkingDirectory property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process."
  syntax:
    content: public string WorkingDirectory { get; set; }
    return:
      type: System.String
      description: "Ha <> </> *> van <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, kell elindítani a folyamatot tartalmazó könyvtár teljes névvel. Ha a <> </> *> tulajdonság <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, a munkakönyvtár kell elindítani a folyamatot. Az alapértelmezett érték egy üres karakterlánc (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessStartInfo.Domain
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IDictionary<String,String>
  nameWithType: IDictionary<String,String>
  fullName: System.Collections.Generic.IDictionary<System.String,System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    nameWithType: IDictionary
    fullName: IDictionary<System.String,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
- uid: System.Collections.Specialized.StringDictionary
  parent: System.Collections.Specialized
  isExternal: false
  name: StringDictionary
  nameWithType: StringDictionary
  fullName: System.Collections.Specialized.StringDictionary
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessStartInfo.FileName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: true
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessWindowStyle
  parent: System.Diagnostics
  isExternal: false
  name: ProcessWindowStyle
  nameWithType: ProcessWindowStyle
  fullName: System.Diagnostics.ProcessWindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
- uid: System.Diagnostics.ProcessStartInfo.#ctor*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo.ProcessStartInfo
- uid: System.Diagnostics.ProcessStartInfo.Arguments*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
- uid: System.Diagnostics.ProcessStartInfo.Domain*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
- uid: System.Diagnostics.ProcessStartInfo.FileName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
