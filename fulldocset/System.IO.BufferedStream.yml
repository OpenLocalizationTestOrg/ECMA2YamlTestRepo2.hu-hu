### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "Olvasási és írási műveleteket végez egy másik adatfolyam a pufferelési réteg hozzáadása. Ez az osztály nem örökölhető."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.BufferedStream&quot;> </xref> 4096 bájtos osztályt a puffer alapértelmezett mérete."
  remarks: "A megosztott olvasási/írási puffer van lefoglalva az első alkalommal egy `BufferedStream` objektum inicializálása során ez a konstruktor. A megosztott pufferből nem használatos, ha minden olvasási és írási nagyobb vagy egyenlő `bufferSize`."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A jelenlegi adatfolyam."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.IO.BufferedStream&quot;> </xref> a megadott pufferméret osztályra."
  remarks: "A megosztott olvasási/írási puffer van lefoglalva az első alkalommal egy `BufferedStream` objektum inicializálása során ez a konstruktor. A megosztott pufferből nem használatos, ha minden olvasási és írási nagyobb vagy egyenlő `bufferSize`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A jelenlegi adatfolyam."
    - id: bufferSize
      type: System.Int32
      description: "A puffer mérete bájtban."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>a rendszer negatív."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy aszinkron olvasási művelet kezdődik. (Érdemes <xref:System.IO.BufferedStream.ReadAsync*>; helyette a Megjegyzés című szakaszában talál.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "A .NET-keretrendszer 4 és korábbi verzióiban, fel kell módszereket használja, mint <xref:System.IO.Stream.BeginRead%2A>és <xref:System.IO.Stream.EndRead%2A>aszinkron fájl műveletek végrehajtásához.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Ezek a módszerek továbbra is elérhetők a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] örökölt kód; támogatásához azonban az új aszinkron metódusok, mint <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, és <xref:System.IO.BufferedStream.FlushAsync%2A>, könnyebben megvalósítása aszinkron fájlműveletek súgó.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>pontosan egyszer hívható a BeginRead minden meghívásához.</xref:System.IO.BufferedStream.EndWrite%2A> Olvasás megkezdése előtt olvassa el folyamat leállítása sikerült nemkívánatos viselkedését, például holtpontot okozhat.      > [!NOTE] > Használja a <xref:System.IO.BufferedStream.CanRead%2A>tulajdonság annak meghatározásához, hogy az aktuális példány támogatja-e olvasási.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>Ennek hívható <xref:System.IAsyncResult>tudja meg, hány bájt beolvasva.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A puffer az adatok olvasására."
    - id: offset
      type: System.Int32
      description: "Az eltolás bájtban `buffer` kezdőpontját az adatfolyamból beolvasott adatok írásakor."
    - id: count
      type: System.Int32
      description: "Olvassa el a bájtok maximális száma."
    - id: callback
      type: System.AsyncCallback
      description: "Egy nem kötelező aszinkron visszahívás, az olvasás befejezésekor hívandó."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron olvasási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Az aszinkron Olvasás, esetleg még függőben lévő képviselő objektum."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Kísérlet történt egy aszinkron olvasás az adatfolyam végén túlra."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A puffer hossza mínusz <code> offset </code> értéke kisebb, mint <code> count </code>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A jelenlegi adatfolyam nem támogatja az olvasási művelet."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy aszinkron írási művelet kezdődik. (Érdemes <xref:System.IO.BufferedStream.WriteAsync*>; helyette a Megjegyzés című szakaszában talál.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "A .NET-keretrendszer 4 és korábbi verzióiban, fel kell módszereket használja, mint <xref:System.IO.Stream.BeginWrite%2A>és <xref:System.IO.Stream.EndWrite%2A>aszinkron fájl műveletek végrehajtásához.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Ezek a módszerek továbbra is elérhetők a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] örökölt kód; támogatásához azonban az új aszinkron metódusok, mint <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, és <xref:System.IO.BufferedStream.FlushAsync%2A>, könnyebben megvalósítása aszinkron fájlműveletek súgó.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>meg kell hívni az pontosan egyszer minden <xref:System.IAsyncResult>a BeginWrite.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>letiltja az i/o-művelet befejezéséig.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A puffer írni a jelenlegi adatfolyam-adatokat tartalmazó."
    - id: offset
      type: System.Int32
      description: "A nulla alapú bájteltolás a `buffer` kezdőpontját bájt másolása a jelenlegi adatfolyam."
    - id: count
      type: System.Int32
      description: "Az írandó bájtok maximális száma."
    - id: callback
      type: System.AsyncCallback
      description: "Az aszinkron írási művelet befejezésekor hívandó metódust."
    - id: state
      type: System.Object
      description: "A felhasználó által megadott objektum, amely az adott aszinkron írási kérelem megkülönbözteti küldött egyéb kérések."
    return:
      type: System.IAsyncResult
      description: "Az aszinkron írás esetleg még függőben lévő hivatkozott objektum."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>minimális hossz <code>offset</code> értéke kisebb, mint <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az írást."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy érték, amely jelzi, hogy a jelenlegi adatfolyam támogatja-e olvasási lekérdezi."
  remarks: "Ha a származtatott osztály <xref:System.IO.Stream>nem támogatja az olvasást, az meghívja a <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, és a `Peek` módszerek <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, és <xref:System.IO.TextReader>kivételt <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       Ha az adatfolyam le van zárva, ez a tulajdonság adja vissza `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az adatfolyam támogatja az olvasást; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> az adatfolyam le van zárva, vagy csak írási hozzáféréssel lett megnyitva."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lekérdezi egy érték, amely jelzi, hogy a jelenlegi adatfolyam támogatja-e a keresést."
  remarks: "Ha a származtatott osztály <xref:System.IO.Stream>nem támogatja a keresést, hívások <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, és <xref:System.IO.BufferedStream.Seek%2A>kivételt <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       Ha az adatfolyam le van zárva, ez a tulajdonság adja vissza `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az adatfolyam támogatja a keresést; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha az adatfolyam le van zárva, vagy ha az adatfolyam operációs rendszer leíróból például cső vagy kimeneti állították össze a konzol."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lekérdezi egy érték, amely jelzi, hogy a jelenlegi adatfolyam támogatja-e az írást."
  remarks: "Ha a származtatott osztály <xref:System.IO.Stream>nem támogatja az írás engedélyezéséhez hívása <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, vagy <xref:System.IO.BufferedStream.WriteByte%2A>egy <xref:System.NotSupportedException>.</xref:System.NotSupportedException> jelez</xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       Ha az adatfolyam le van zárva, ez a tulajdonság adja vissza `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az adatfolyam támogatja az írást; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> az adatfolyam le van zárva, vagy csak olvasási hozzáféréssel lett megnyitva."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "Fel kell venni a párbeszédpanelre."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "A függőben lévő aszinkron olvasási művelet befejeződésére vár. (Érdemes <xref:System.IO.BufferedStream.ReadAsync*>; helyette a Megjegyzés című szakaszában talál.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "A .NET-keretrendszer 4 és korábbi verzióiban, fel kell módszereket használja, mint <xref:System.IO.Stream.BeginRead%2A>és <xref:System.IO.Stream.EndRead%2A>aszinkron fájl műveletek végrehajtásához.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Ezek a módszerek továbbra is elérhetők a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] örökölt kód; támogatásához azonban az új aszinkron metódusok, mint <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, és <xref:System.IO.BufferedStream.FlushAsync%2A>, könnyebben megvalósítása aszinkron fájlműveletek súgó.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       Az EndRead kell hívni a <xref:System.IAsyncResult>tudja meg, hány bájt beolvasva.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Várjon, amíg a folyamatban lévő aszinkron kérés mutató hivatkozást."
    return:
      type: System.Int32
      description: "A bájtok száma olvasható be az adatfolyamból, 0 (nulla) és a kért bájtok száma. Adatfolyamok csak 0 csak az adatfolyam végét adja vissza, egyéb esetben kell letiltják a addig, amíg legalább 1 bájt nem érhető el."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Az <xref:System.IAsyncResult>objektum nem hozta létre <xref:System.IO.BufferedStream.BeginRead*>ezt az osztályt</xref:System.IO.BufferedStream.BeginRead*> hívása</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Karakterlánccal végződik-e egy aszinkron írási művelet és a blokk csak az I/O művelet befejeződése után. (Érdemes <xref:System.IO.BufferedStream.WriteAsync*>; helyette a Megjegyzés című szakaszában talál.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "A .NET-keretrendszer 4 és korábbi verzióiban, fel kell módszereket használja, mint <xref:System.IO.Stream.BeginWrite%2A>és <xref:System.IO.Stream.EndWrite%2A>aszinkron fájl műveletek végrehajtásához.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Ezek a módszerek továbbra is elérhetők a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] örökölt kód; támogatásához azonban az új aszinkron metódusok, mint <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, és <xref:System.IO.BufferedStream.FlushAsync%2A>, könnyebben megvalósítása aszinkron fájlműveletek súgó.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       Minden hívás <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> pontosan egyszer lehet meghívni az EndWrite Megkezdése előtt olvassa el folyamat leállítása sikerült egy másik olvasási művelet okozhat holtpont vagy egyéb nem kívánt viselkedést."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "A függőben lévő aszinkron kérelem."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Az <xref:System.IAsyncResult>objektum nem hozta létre <xref:System.IO.BufferedStream.BeginWrite*>ezt az osztályt</xref:System.IO.BufferedStream.BeginWrite*> hívása</xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Törli az összes puffer adatfolyam, és leállítja a pufferelt adatokat írni az alapul szolgáló eszközt."
  remarks: "Könyvelési az adatfolyam nem kiüríteni az alapul szolgáló kódoló, kivéve, ha explicit módon hívja `Flush` vagy <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       Ha használja a <xref:System.IO.BufferedStream.%23ctor%2A>konstruktor, ezért adja meg a puffer mérete létrehozása során a `BufferedStream` objektum, a tartalom ki van ürítve, amikor eléri a puffer mérete.</xref:System.IO.BufferedStream.%23ctor%2A> Például code például `BufferedStream bs = new BufferedStream(bs, 5)` a tartalom ürítse ki, amikor a puffer mérete eléri 5 bájt.       Minden olvasási és írási módszert `BufferedStream` automatikusan karbantartása a puffer mérete, így nincs szükség a meghívni kívánt `Flush` váltáskor oda-vissza közötti olvasását és írását."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az adatfolyam el lett távolítva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az adatforrás vagy a tárház nincs megnyitva."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aszinkron módon adatfolyam minden pufferek törli, a pufferelt adatokat írni az alapul szolgáló eszköz okozza, és figyeli a megszakítási kérések."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A token megszakítási kérések figyelését."
    return:
      type: System.Threading.Tasks.Task
      description: "Ez a feladat az aszinkron kiürítési művelet jelöli."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az adatfolyam el lett távolítva."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lekérdezi az adatfolyam hossza (bájt)."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Az adatfolyam hossza (bájt)."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az alapul szolgáló folyam <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> vagy lezárt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja a keresést."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lekérdezi a jelenlegi adatfolyam belül pozícióját."
  remarks: "A `get` elérő hív <xref:System.IO.BufferedStream.Seek%2A>beszerzése az aktuális pozíció az alapul szolgáló folyam belül, és ezt az értéket az aktuális pozíciót a pufferen belüli alapján majd módosíthatja.</xref:System.IO.BufferedStream.Seek%2A>       A `set` elérő másolja a korábban a puffer az alapul szolgáló adatfolyamba írt adatok, majd meghívja a <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       Az adatfolyam hossza túl bárhova keresést esetén támogatott."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A jelenlegi adatfolyam belül pozícióját."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Az átadott érték <xref:System.IO.BufferedStream.Seek*>negatív.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba lép fel, például az adatfolyam lezárult."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja a keresést."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Másolja a tömbhöz az aktuális pufferelt adatfolyamból bájt."
  remarks: "A `Read` metódus vissza 0, csak akkor, ha az adatfolyam végének elérésekor. Minden más esetben `Read` , mindig legalább egy bájt be az adatfolyamból való visszaküldés előtt. Definíció, ha nem érhetők el adatok hívása után az adatfolyamból `Read`, a `Read` metódus adja vissza 0 (az adatfolyam végének elérésekor automatikusan). Egy megvalósítási szabad kevesebb, mint a kért bájtok vissza, akkor is, ha még nem érte el az adatfolyam végét.       Használjon <xref:System.IO.BinaryReader>primitív adattípusokat olvasásához.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A puffer, amelyhez bájtok másolandó találhatók."
    - id: offset
      type: System.Int32
      description: "A bájteltolás, amellyel a bájtok olvasását kezdeni a pufferben."
    - id: count
      type: System.Int32
      description: "Az olvasandó bájtok száma."
    return:
      type: System.Int32
      description: "A bájtok száma olvashat be <code> array </code>. Ez lehet kisebb, mint a bájtok száma kért, ha sok bájt még nem állnak rendelkezésre, vagy 0, ha az adatfolyam végét elérte előtt adatokat képes olvasni."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az adatfolyam nincs megnyitva, vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az olvasást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aszinkron módon bájt sorrendjét olvasó az aktuális adatfolyamból belül az adatfolyam pozíciója által olvasott bájtok számát, és a megszakítási kérések figyeli."
  remarks: "Megszakítási jogkivonat létrehozásához példányának létrehozása a <xref:System.Threading.CancellationTokenSource>osztály és a sikeres a <xref:System.Threading.CancellationTokenSource.Token%2A>tulajdonság a `cancellationToken` paraméter.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A puffer az adatokat írni."
    - id: offset
      type: System.Int32
      description: "Az eltolás bájtban `buffer` kezdőpontját adatok írása az adatfolyamból."
    - id: count
      type: System.Int32
      description: "Olvassa el a bájtok maximális száma."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A token megszakítási kérések figyelését."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Egy feladatot, amely jelöli az aszinkron olvasási művelet. Értékét a <code> TResult </code> a paraméter tartalmazza a puffer az olvasott bájtok teljes száma. Az eredmény érték lehet kisebb, mint a bájtok száma kért, ha a jelenleg rendelkezésre álló bájtok száma nem éri el a kért szám vagy 0 (nulla) lehet, ha a rendszer elérte az adatfolyam végét."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Összesített <code> offset </code> és <code> count </code> nagyobb a puffer hosszánál."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az olvasást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az adatfolyam el lett távolítva."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Az adatfolyamot még használja egy előző olvasási művelet."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Egy olyan bájtot olvas az alapul szolgáló folyam és a típusúvá bájtot ad vissza egy <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, vagy&1; értéket ad vissza, ha olvasásakor az adatfolyam végét."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "A byte típusúvá egy <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, vagy a -1, ha olvasásakor az adatfolyam végét."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "I/o-hiba lép fel, például az adatfolyam lezárult."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az olvasást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Az aktuális pufferelt adatfolyam pozíciója állítja be."
  remarks: "Ha `offset` értéke negatív, az új helyre az automatikusan kitöltött által megadott pozíciónál `origin` által a bájtban megadott `offset`. Ha `offset` 0, a helyre lesz a megadott pozíció `origin`. Ha `offset` pozitív, az új helyre követi a megadott pozíció `origin` által a bájtban megadott `offset`.       Ha egy <xref:System.IO.BufferedStream>objektum az alapszintű adatfolyam egy <xref:System.IO.StreamReader>objektum, a keresés metódus hívása okozhat a pozíció az adatfolyam már nem felel meg az olvasó pozíciója a belső puffer számára.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> A belső puffer visszaállításához hívja meg a <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>metódus; azonban ez a módszer csökkenti a teljesítményét, és csak feltétlenül szükség esetén hívható.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       Az adatfolyam hossza túl bárhova keresést esetén támogatott."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "A relatív bájteltolás `origin`."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Típusú érték <xref:System.IO.SeekOrigin>jelző a hivatkozási pont, amelyről az új helyre.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Az aktuális pufferelt adatfolyam belül helyre."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az adatfolyam nincs megnyitva, vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja a keresést."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Beállítja a pufferelt adatfolyam hossza."
  remarks: "A puffer ki van ürítve, az alapul szolgáló adatforrás vagy a tárház hosszának beállítása előtt. Ha a megadott érték kisebb, mint a jelenlegi a pufferelt adatfolyam hossza, a pufferelt adatfolyam függvény egésszé csonkítja. Ha a megadott érték nagyobb, mint a pufferelt adatfolyam aktuális hosszát, a pufferelt adatfolyam ki van bontva. A pufferelt adatfolyam ki van bontva, ha a régi és az új kulcsokkal közötti pufferelt adatfolyam tartalma nem definiálhatók.       `SetLength`Kiüríti bármilyen pufferelt írás, ha szükséges.       Egy adatfolyamnak támogatnia kell mind az írást, és a keresést `SetLength` működéséhez."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "A kívánt bájtban aktuális pufferelt adatfolyam hossza jelző egész számot."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>a rendszer negatív."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az adatfolyam nincs megnyitva, vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az írást, és a keresést."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "A pufferelt adatfolyam bájt másolja, és az aktuális pozíció belül a pufferelt adatfolyam kiadásokban által írt bájtok száma."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A bájttömb, amelynek be kell másolni `count` bájtok aktuális pufferelt adatfolyam."
    - id: offset
      type: System.Int32
      description: "Az eltolás kezdőpontját bájtok aktuális pufferelt adatfolyam másolása a pufferben."
    - id: count
      type: System.Int32
      description: "Az aktuális pufferelt adatfolyam írandó bájtok száma."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Az adatfolyam le van zárva vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az írást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aszinkron módon bájt sorozatát ír a jelenlegi adatfolyam, az aktuális pozíció az adatfolyam belül kiadásokban által írt bájtok száma, és figyeli a megszakítási kérések."
  remarks: "Megszakítási jogkivonat létrehozásához példányának létrehozása a <xref:System.Threading.CancellationTokenSource>osztály és a sikeres a <xref:System.Threading.CancellationTokenSource.Token%2A>tulajdonság a `cancellationToken` paraméter.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A puffer adatokat írni."
    - id: offset
      type: System.Int32
      description: "A nulla alapú bájteltolás a `buffer` kezdőpontjaként bájt az adatfolyamba történő másolását."
    - id: count
      type: System.Int32
      description: "Az írandó bájtok maximális száma."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A token megszakítási kérések figyelését."
    return:
      type: System.Threading.Tasks.Task
      description: "Ez a feladat az aszinkron írási művelet jelöli."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>vagy <code>count</code> negatív."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Összesített <code> offset </code> és <code> count </code> nagyobb a puffer hosszánál."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az írást."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Az adatfolyam el lett távolítva."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Az adatfolyamot még használja az egyik korábbi írási művelet."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Az aktuális pozíciót az adatfolyamban pufferelt ír egy olyan bájtot."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Az adatfolyam írni bájt."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Az adatfolyam nem támogatja az írást."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Módszerek volt hívása után az adatfolyam le lett zárva."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
