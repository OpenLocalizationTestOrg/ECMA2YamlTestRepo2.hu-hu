### YamlMime:ManagedReference
items:
- uid: System.Windows.CoerceValueCallback
  id: CoerceValueCallback
  langs:
  - csharp
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
  type: Delegate
  summary: "A sablon biztosít egy módszert, amelyet nevezzük, amikor a függőség tulajdonság értéke újra kiértékelése megtörténik, vagy a kényszerítési kifejezetten van szükség."
  remarks: "Visszahívások CoerceValueCallback alapján rendelhet egy függőség tulajdonság számos különböző módszert. Az alábbi eljárások igényel, akkor először létre kell hoznia egy új tulajdonság metaadat-objektum (<xref:System.Windows.PropertyMetadata>, vagy egy származtatott osztálynak például <xref:System.Windows.FrameworkPropertyMetadata>).</xref:System.Windows.FrameworkPropertyMetadata> </xref:System.Windows.PropertyMetadata> A metaadat-objektum, amely konstruktor aláírással létrehozása a `coerceValueCallback` paramétert, és rendelje hozzá, hogy a paraméter a visszahívás-kezelő. Vagy összeállítani a metaadatok bármely aláírás és a készlet által a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>tulajdonság előtt használja a metaadatokat és.</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Ha ezeket a metaadatokat, a következőket teheti:-új függőség tulajdonság adja meg egy új osztályt, vagy az aláírás használatával <xref:System.Windows.DependencyProperty.Register%2A>, a metaadatok, amely a `typeMetadata` érték.</xref:System.Windows.DependencyProperty.Register%2A>      -A metaadatainak felülírására (hívja <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) a meglévő függőség tulajdonság, ha Ön a alaposztályból származik, amely a függőség tulajdonság tulajdonosa.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>      – Egy meglévő függőség tulajdonság hozzáadása egy új <xref:System.Windows.DependencyObject>osztályt, új metaadatokkal, <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> meghívásával</xref:System.Windows.DependencyObject>       A visszahívási implementációja ellenőrizze az érték `baseValue` és döntse el, hogy egy érték, amelyet a további kényszeríthető a value vagy a típus alapján.       A <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>függőséget tulajdonság, ha a tulajdonság rendszer vagy bármely más hívó meghívja a meghívott <xref:System.Windows.DependencyObject.CoerceValue%2A>a egy <xref:System.Windows.DependencyObject>példány, adja meg, hogy a tulajdonság azonosítója, mint a `dp`.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.CoerceValue%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Előfordulhat, hogy a tulajdonság értékének módosítása a tulajdonság rendszer lehetséges résztvevője származik. Ez magában foglalja a stílusok, általános érvénytelenítési, eseményindítók, tulajdonság értéke öröklési és helyi érték.       Általában akkor érdemes ne adjon meg egynél több <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>bármely adott függőségi tulajdonság (felülírása vagy új metaadatokkal, amely már függőség tulajdonság hozzáadása egy <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> A visszahívások közül csak egyet fog tudni működni. A működő visszahívási kell figyelembe venni, képest, hogy az öröklési legtávolabbi származtatott osztályt alkalmazott a <xref:System.Windows.DependencyObject>hívó.</xref:System.Windows.DependencyObject> Ha felülbírálja a metaadatok más visszahívások adott nagyobbnak, a tulajdonos hierarchia verzióját a függőség tulajdonság metaadatai rendeli helyett."
  example:
  - "The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value. In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] (not shown) to remove that dropdown from the effective choices.  \n  \n [!code-cs[DPCustom#CoerceValueCallback](~/add/codesnippet/csharp/DPCustom/default.xaml.cs#coercevaluecallback)]\n [!code-vb[DPCustom#CoerceValueCallback](~/add/codesnippet/visualbasic/dpcustom/default.xaml.vb#coercevaluecallback)]"
  syntax:
    content: public delegate object CoerceValueCallback(DependencyObject d, object baseValue);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
