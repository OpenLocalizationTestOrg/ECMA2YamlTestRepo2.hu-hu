### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Hozzáférést biztosít a helyi és távoli folyamatokhoz, és lehetővé teszi a indítása és leállítása a helyi rendszer folyamatok.       Keresse meg a .NET-keretrendszer forráskód ehhez a típushoz, tekintse meg a [hivatkozás forrás](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> osztály."
  remarks: "Ha nem adja meg a <xref:System.Diagnostics.Process.MachineName%2A>tulajdonság, az alapértelmezett értéke a helyi számítógépen (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Egy új társíthatunk kétféle <xref:System.Diagnostics.Process>összetevőt, a folyamat során a számítógépen.</xref:System.Diagnostics.Process> Az első lehetőség a konstruktor használatával történő létrehozásáról a <xref:System.Diagnostics.Process>összetevő, állítsa be a megfelelő tagjai a <xref:System.Diagnostics.Process.StartInfo%2A>tulajdonság és hívás <xref:System.Diagnostics.Process.Start%2A>társítja a <xref:System.Diagnostics.Process>egy új rendszer folyamattal.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> A második beállítás lesz hozzárendelni a <xref:System.Diagnostics.Process>használatával futó rendszer folyamat <xref:System.Diagnostics.Process.GetProcessById%2A>vagy az egyik a <xref:System.Diagnostics.Process.GetProcesses%2A>értéket ad vissza.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Ha egy `static` a túlterhelési a <xref:System.Diagnostics.Process.Start%2A>egy új rendszer folyamat elindításához a a módszerrel hoz létre egy új <xref:System.Diagnostics.Process>összetevő és társítja azt a folyamatot.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Ha a <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>tulajdonság értéke az alapértelmezett értéket, `true`, úgy, hogy hasonló megkezdheti alkalmazások és a dokumentumok a `Run` párbeszédpanel a Windows `Start` menü.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ha <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>van `false`, csak a végrehajtható fájlokat is elindítható.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       A végrehajtható fájlt a parancssorból hívható indíthatók el az alábbi két módszer egyikével: úgy, hogy a megfelelő tagjai a <xref:System.Diagnostics.Process.StartInfo%2A>tulajdonság és hívása a <xref:System.Diagnostics.Process.Start%2A>metódus paraméter nélkül, vagy úgy, hogy a megfelelő paramétert a `static` <xref:System.Diagnostics.Process.Start%2A>tag.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Létrehozhat egy <xref:System.Diagnostics.Process>összetevőt a konstruktort, a statikus egyik használatával <xref:System.Diagnostics.Process.Start%2A>túlterhelések, sem annak a <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, vagy <xref:System.Diagnostics.Process.GetProcessesByName%2A>módszerek.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Miután ezt megtette, így a társított folyamat megtekintésében kell. Ez nem egy dinamikus nézetét, amely automatikusan frissíti magát az a folyamat tulajdonságai megváltoztak a memóriában. Ehelyett meg kell hívnia <xref:System.Diagnostics.Process.Refresh%2A>a frissítendő összetevő a <xref:System.Diagnostics.Process>tulajdonság adatait az alkalmazás.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A társított folyamat alapprioritás-szintjének beolvasása."
  remarks: "A folyamat BasePriority a társított folyamat belül létrehozott szálak kezdési prioritását. A Rendszerfigyelő prioritás alapszámláló keresztül alapprioritás-szintjének kapcsolatos információk is megtekinthetők.       Eltelt vagy más növekedhet, az operációs rendszer módosíthatja az alapprioritás, ha a folyamat mások előre kell helyezni ideje alapján.       A BasePriority tulajdonság lehetővé teszi egy folyamat kezdési prioritásuk megtekintését. Azonban mivel csak olvasható, nem használható a BasePriority prioritása beállítható a a folyamat. A prioritás módosításához használja a <xref:System.Diagnostics.Process.PriorityClass%2A>tulajdonság.</xref:System.Diagnostics.Process.PriorityClass%2A> A BasePriority megtekinthető a figyelő segítségével, miközben a <xref:System.Diagnostics.Process.PriorityClass%2A>nem.</xref:System.Diagnostics.Process.PriorityClass%2A> Mindkét a BasePriority és a <xref:System.Diagnostics.Process.PriorityClass%2A>programozott módon lehet megtekinteni.</xref:System.Diagnostics.Process.PriorityClass%2A> Az alábbi táblázat a BasePriority értékek közötti kapcsolat és <xref:System.Diagnostics.Process.PriorityClass%2A>értékek.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority |} PriorityClass |}   |------------------|-------------------|   |}&4; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&8; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&13; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&24; |} <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Az alapprioritás, amelyek alapján kiszámított a <xref:System.Diagnostics.Process.PriorityClass*>a társított folyamat.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be a &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; tulajdonságot <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat már kilépett.       – vagy – a folyamat nem indult el, így nincs folyamat."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Az átirányított aszinkron olvasási műveletek megkezdése <xref:System.Diagnostics.Process.StandardError*>az alkalmazás adatfolyam.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "A <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam olvasható szinkron vagy aszinkron.</xref:System.Diagnostics.Process.StandardError%2A> Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a folyamat a hiba kimeneti adatfolyam.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>ír a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamként, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Ezzel szemben BeginErrorReadLine indítása aszinkron olvasási a műveletek a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A> Ez a módszer lehetővé teszi, hogy a kijelölt eseménykezelő az adatfolyam-kimenetét, és azonnal visszaadja a hívónak, amely más feladatok is hajtható végre, amíg az eseménykezelő irányul, az adatfolyam-kimenetét.       Kövesse az alábbi lépéseket az aszinkron olvasási műveleteknél végre <xref:System.Diagnostics.Process.StandardError%2A>az egy <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Az eseménykezelő hozzáadása a <xref:System.Diagnostics.Process.ErrorDataReceived>esemény.</xref:System.Diagnostics.Process.ErrorDataReceived> Az eseménykezelő meg kell egyeznie a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>delegált aláírás.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Indítsa el a <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  A <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> BeginErrorReadLine meghívása Ez a hívás elindítja a <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> aszinkron olvasási műveleteknél       Aszinkron olvasási műveleteknél start, az eseménykezelő metódus meghívásakor minden alkalommal, amikor a társított <xref:System.Diagnostics.Process>ír egy sor szöveget a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Egy aszinkron olvasási művelet megszakíthatja <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> meghívásával Az olvasási művelet lehet megszakítani, vagy az eseménykezelő a hívó által. Újra folytatja a aszinkron olvasási műveleteknél BeginErrorReadLine hívása után visszavonás.      > [!NOTE] > Nem keverhetők a szinkron és aszinkron olvasási műveleteknél átirányított adatfolyamon. Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Például ne hajtsa végre BeginErrorReadLine hívja <xref:System.IO.StreamReader.ReadLine%2A>a a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam, vagy fordítva.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> Két különböző adatfolyamokba különböző módokban érheti el. Például BeginErrorReadLine hívja, és ezután hívja meg <xref:System.IO.StreamReader.ReadLine%2A>a a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Az átirányított aszinkron olvasási műveletek megkezdése <xref:System.Diagnostics.Process.StandardOutput*>az alkalmazás az adatfolyam.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "A <xref:System.Diagnostics.Process.StandardOutput%2A>szinkron vagy aszinkron módon olvasható adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a kimeneti adatfolyamba, a folyamat.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>ír a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Ezzel szemben BeginOutputReadLine indítása aszinkron olvasási a műveletek a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> Ez a módszer lehetővé teszi, hogy az adatfolyam-kimenetét a megadott eseménykezelőt, és azonnal visszaadja a hívónak, amely más feladatok is hajtható végre, amíg az eseménykezelő irányul, az adatfolyam-kimenetét.       Kövesse az alábbi lépéseket az aszinkron olvasási műveleteknél végre <xref:System.Diagnostics.Process.StandardOutput%2A>az egy <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Az eseménykezelő hozzáadása a <xref:System.Diagnostics.Process.OutputDataReceived>esemény.</xref:System.Diagnostics.Process.OutputDataReceived> Az eseménykezelő meg kell egyeznie a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>delegált aláírás.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Indítsa el a <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  A <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> BeginOutputReadLine meghívása Ez a hívás elindítja a <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> aszinkron olvasási műveleteknél       Aszinkron olvasási műveleteknél start, az eseménykezelő metódus meghívásakor minden alkalommal, amikor a társított <xref:System.Diagnostics.Process>ír egy sor szöveget a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Egy aszinkron olvasási művelet megszakíthatja <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> meghívásával Az olvasási művelet lehet megszakítani, vagy az eseménykezelő a hívó által. Újra folytatja a aszinkron olvasási műveleteknél BeginOutputReadLine hívása után visszavonás.      > [!NOTE] > Nem keverhetők a szinkron és aszinkron olvasási műveleteknél átirányított adatfolyamon. Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Például ne hajtsa végre BeginOutputReadLine hívja <xref:System.IO.StreamReader.ReadLine%2A>a a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam, vagy fordítva.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> Két különböző adatfolyamokba különböző módokban érheti el. Például BeginOutputReadLine hívja, és ezután hívja meg <xref:System.IO.StreamReader.ReadLine%2A>a a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Megszakítja az aszinkron olvasási művelet az átirányított <xref:System.Diagnostics.Process.StandardError*>alkalmazás adatfolyamot.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>egy aszinkron olvasási művelete a elindul a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead az aszinkron olvasási művelet véget ér.       Visszavonás, után folytathatja az aszinkron olvasási művelet hívása <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>újra.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       CancelErrorRead hívásakor minden folyamatban lévő olvasási műveletek <xref:System.Diagnostics.Process.StandardError%2A>elvégzése, és ezután az eseménykezelő le van tiltva.</xref:System.Diagnostics.Process.StandardError%2A> Az összes további átirányítva kimenet <xref:System.Diagnostics.Process.StandardError%2A>puffer mentett.</xref:System.Diagnostics.Process.StandardError%2A> Ha újra engedélyezi az eseménykezelő hívja <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, a mentett kimeneti a rendszer elküldi az eseménykezelő, és aszinkron olvasási műveleteknél folytatni.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Ha szeretné módosítani az eseménykezelő aszinkron olvasási műveleteknél folytatása előtt, el kell távolítania a meglévő eseménykezelő az új eseménykezelőt hozzáadása előtt: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > nem keverhetők a szinkron és aszinkron olvasási műveletek az átirányított <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A> Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Ha megszakítja az aszinkron olvasási művelete a <xref:System.Diagnostics.Process.StandardError%2A>, és olvassa be az adatfolyamból, használnia kell majd kell <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>aszinkron olvasási műveleteknél folytatni.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Ne hajtsa végre a CancelErrorRead szinkron olvasási módszereit hívja <xref:System.Diagnostics.Process.StandardError%2A>például <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, vagy <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref:System.Diagnostics.Process.StandardError*>az aszinkron olvasási műveleteknél nincs engedélyezve a adatfolyam.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Megszakítja az aszinkron olvasási művelet az átirányított <xref:System.Diagnostics.Process.StandardOutput*>alkalmazás adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>egy aszinkron olvasási művelete a elindul a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead az aszinkron olvasási művelet véget ér.       Visszavonás, után folytathatja aszinkron olvasási műveleteknél meghívásával <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>újra.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       CancelOutputRead hívásakor minden folyamatban lévő olvasási műveletek <xref:System.Diagnostics.Process.StandardOutput%2A>elvégzése, és ezután az eseménykezelő le van tiltva.</xref:System.Diagnostics.Process.StandardOutput%2A> Az összes további átirányítva kimenet <xref:System.Diagnostics.Process.StandardOutput%2A>puffer mentett.</xref:System.Diagnostics.Process.StandardOutput%2A> Ha újra engedélyezi az eseménykezelő hívja <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a mentett kimeneti a rendszer elküldi az eseménykezelő, és aszinkron olvasási műveleteknél folytatni.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Ha szeretné módosítani az eseménykezelő aszinkron olvasási műveleteknél folytatása előtt, el kell távolítania a meglévő eseménykezelő az új eseménykezelőt hozzáadása előtt: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > nem keverhetők a szinkron és aszinkron olvasási műveletek az átirányított <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Ha megszakítja az aszinkron olvasási művelete a <xref:System.Diagnostics.Process.StandardOutput%2A>, és olvassa be az adatfolyamból, használnia kell majd kell <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>aszinkron olvasási műveleteknél folytatni.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Ne hajtsa végre a CancelOutputRead szinkron olvasási módszereit hívja <xref:System.Diagnostics.Process.StandardOutput%2A>például <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, vagy <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A <xref:System.Diagnostics.Process.StandardOutput*>az aszinkron olvasási műveleteknél nincs engedélyezve a adatfolyam.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ez az összetevő társított összes erőforrás felszabadul."
  remarks: "A Close metódus azt eredményezi, ha várakozási, bezárja a folyamatot leíró, és törli a folyamatokra vonatkozó tulajdonságok kilépési Várakozás folyamata. Zárja be nem zárja be a szabványos kimeneti, a bemeneti és a hiba olvasók és írók abban az esetben, ha azok külsőleg hivatkoznak.      > [!NOTE] > A <xref:System.Diagnostics.Process.Dispose%2A>metódus meghívja a Bezárás gombra.</xref:System.Diagnostics.Process.Dispose%2A> Helyezi el a <xref:System.Diagnostics.Process>objektum egy `using` blokk megválik erőforrásokhoz Bezárás hívása nélkül.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A folyamat, amely rendelkezik a felhasználói felület bezárási üzenetet küld a fő ablak bezárása."
  remarks: "A folyamat végrehajtásakor a üzenetkezelő ciklus várakozási állapotban van. Az üzenetkezelő ciklus minden alkalommal, amikor egy Windows üzenetet küld a folyamat által az operációs rendszer hajtja végre. A fő ablakban, amelyet egy megfelelően formázott alkalmazásban gyermekablakok bezárja, és visszavonja az alkalmazás összes futó üzenet hurkok megközelíti CloseMainWindow hívja egy kérést küld. A folyamat kilép CloseMainWindow meghívásával a kérelem nem kényszeríti az alkalmazás bezárásához. Az alkalmazás felhasználói ellenőrzés Kilépés előtt kérje meg, vagy visszautasíthatja a való kilépéshez. Az alkalmazás bezárásának kényszerítése, használja a <xref:System.Diagnostics.Process.Kill%2A>metódus.</xref:System.Diagnostics.Process.Kill%2A> A CloseMainWindow működése megegyezik-e a felhasználó egy alkalmazást a rendszer menü segítségével fő ablak bezárása. Ezért a kérelem a kilépéshez a folyamat által a fő ablak bezárása nem alkalmazásának a kényszerítéséhez azonnali bezárásához.       A folyamat szerkesztett adatok vagy az erőforrások vannak rendelve a folyamat elvesznek, ha meghívja a <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>egy rendellenes folyamat futása okozza, és csak szükség esetén használandó.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow lehetővé teszi, hogy a folyamat egy szabályos megszüntetése, és bezárja az összes windows, érdemes az illesztőfelület-alkalmazások. Ha CloseMainWindow nem sikerül, akkor használhatja <xref:System.Diagnostics.Process.Kill%2A>a folyamatot le kell állítanunk.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>Ez az egyetlen módja, amely nem rendelkezik grafikus felületek folyamatok leáll.</xref:System.Diagnostics.Process.Kill%2A>       Hívása <xref:System.Diagnostics.Process.Kill%2A>és csak a helyi számítógépen futó folyamatok CloseMainWindow.</xref:System.Diagnostics.Process.Kill%2A> Folyamatok nem okozhat a távoli számítógépeken való kilépéshez. Csak a távoli számítógépeken futó folyamatok információk is megtekinthetők."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a Bezárás üzenet elküldése megtörtént; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha a társított folyamat nem rendelkezik a fő ablakot, vagy ha a fő ablak (például ha egy modális párbeszédpanel megjelenik) le van tiltva."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be a &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; tulajdonságot <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat már kilépett.       – vagy – egyetlen folyamat sem tartozik a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Szabadítsa fel a folyamat által használt erőforrások."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a kibocsátási felügyelt és a nem felügyelt erőforrások; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> csak a nem felügyelt erőforrások kijelölése."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a hogy a <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> esemény kell jelenik meg, ha a folyamat leáll."
  remarks: "A EnableRaisingEvents a tulajdonság azt jelzi, hogy az összetevő értesíteni kell, amikor az operációs rendszer a folyamat le lett állítva. A EnableRaisingEvents tulajdonság szerepel aszinkron feldolgozási értesíteni az alkalmazáshoz, amely a folyamat már kilépett. Az alkalmazás egy kilépési eseményt (amely megszakítja az alkalmazás feldolgozását, addig, amíg a kilépési esemény történt) szinkron módon várni kényszerítéséhez használja a <xref:System.Diagnostics.Process.WaitForExit%2A>metódus.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Ha Visual Studio használ, és kattintson duplán egy <xref:System.Diagnostics.Process>összetevőt a projektben egy <xref:System.Diagnostics.Process.Exited>esemény delegált és eseménykezelő automatikusan jön létre.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Kód értékűre állítja a EnableRaisingEvents tulajdonságot `false`. Ezt a tulajdonságot meg kell változtatnia `true` hajthatnak végre, amikor a társított folyamat kilépésekor a eseménykezelő.       Ha a társított folyamat kilépésekor, állapota után állítja le az operációs rendszer vagy a normál és rendellenes lezárást, az operációs rendszer értesítést küld minden folyamat-összetevőt, amelyhez a folyamat újra lett társítva, mindaddig, amíg a összetevő EnableRaisingEvents értéke `true`. Ha egy összetevő kezdte a folyamatot, az összetevő ezután hozzáférhetnek a társított folyamat, amely továbbra is tárolja az operációs rendszer felügyeleti információkat. Az ilyen információk közé tartozik a <xref:System.Diagnostics.Process.ExitTime%2A>, és a <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       A társított folyamat kilépése után, a <xref:System.Diagnostics.Process.Handle%2A>az összetevő már nem mutat meglévő folyamat erőforrás.</xref:System.Diagnostics.Process.Handle%2A> Ehelyett használat csak a folyamat erőforrás az operációs rendszer adatainak eléréséhez. Az operációs rendszer vegye figyelembe, hogy vannak-e handles, amelyekből kiléptek folyamatokra vonatkozik, amelyek nem által kiadott <xref:System.Diagnostics.Process>összetevők, így tartja a <xref:System.Diagnostics.Process.ExitTime%2A>és <xref:System.Diagnostics.Process.Handle%2A>adatokat a memóriába.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Az egy folyamat leállását figyelése ingyenes van. Ha EnableRaisingEvents `true`, a <xref:System.Diagnostics.Process.Exited>esemény jelenik meg, amikor a társított folyamat leáll.</xref:System.Diagnostics.Process.Exited> A megadott eljárások a <xref:System.Diagnostics.Process.Exited>az esemény akkor futnak.</xref:System.Diagnostics.Process.Exited>       Egyes esetekben az alkalmazás elindítja a folyamatot, de nem kell a megszüntetésre értesíti. Például az alkalmazás is engedélyezhető a felhasználók szöveg szerkesztése végrehajtásához a Jegyzettömb, de akár további nem használja a Jegyzettömb alkalmazást. Ha szeretné, nem értesíti, ha a folyamat kilép, mivel már nem kapcsolódik az alkalmazás folyamatos működését. EnableRaisingEvents beállítást `false` menti a rendszer erőforrásait."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> esemény kell következik be, amikor a társított folyamat befejeződik (Kilépés vagy hívása keresztül <xref:System.Diagnostics.Process.Kill*>); egyéb esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hozzáadja a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő állapota együttműködhet az operációs rendszer feldolgozza a natív tulajdonság engedélyezésével speciális módban futó <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> az aktuális szálon."
  remarks: "Egyes operációs rendszer folyamatokat speciális módban fut. Tulajdonságainak olvasása vagy ezeket a folyamatokat csatolása nincs lehetőség EnterDebugMode összetevőjének hívott. Hívás <xref:System.Diagnostics.Process.LeaveDebugMode%2A>Ha már nem szükséges különleges módban futó folyamatok elérésére.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Akkor következik be, ha egy alkalmazás ír az átirányított <xref:System.Diagnostics.Process.StandardError*>adatfolyamot.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "A ErrorDataReceived esemény azt jelzi, hogy a társított folyamat az átirányított való írás <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A>       Az esemény csak akkor történik meg a <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> aszinkron olvasási műveletek során Indítsa el az aszinkron olvasási műveleteknél, irányítsa át az <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam egy <xref:System.Diagnostics.Process>, a eseménykezelő a ErrorDataReceived eseménynaplójába, és hívja meg <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Ezt követően a ErrorDataReceived esemény jelek minden alkalommal, amikor a folyamat ír egy sor az átirányított <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam, amíg a folyamat kilép, vagy a hívások <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > Az aszinkron kimeneti feldolgozó meg kell hívnia a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer annak biztosítására, hogy a kimeneti puffer ki lettek ürítve.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Amikor megszakadt a társított folyamat a megadott érték beolvasása."
  remarks: "A folyamat kilépett az visszaadott állapotát ExitCode használható. A kilépési kódot használhatja sokkal például egy egész számot ad vissza értéket az egy `main()` eljárásnak.       A ExitCode folyamat azt az adott egyezmény valósítják meg az alkalmazás fejlesztőjének az adott folyamathoz. A kód döntések használatakor a kilépési kód értékét, győződjön meg arról, hogy a kilépési kód egyezmény a alkalmazás által használt.       Fejlesztők általában egy sikeres kilépési ExitCode nulla érték azt jelzi, és jelölje ki a hibák által nulla érték, amely a hívó metódus használatával azonosíthatja az okot, egy rendellenes folyamat befejeződésekor. Nincs szükség a követi ezeket az irányelveket, ugyanakkor az egyezmény.       Ha megpróbálja beolvasni a ExitCode előtt kilépett a folyamat, a kísérlet kivételt jelez. Vizsgálja meg a <xref:System.Diagnostics.Process.HasExited%2A>tulajdonságot először győződjön meg arról, hogy a társított folyamat megszakadt.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Szabványos kimeneti aszinkron eseménykezelők átirányítva, esetén lehetséges, hogy kimeneti feldolgozási fog nem fejeződött be mikor <xref:System.Diagnostics.Process.HasExited%2A>adja vissza `true`.</xref:System.Diagnostics.Process.HasExited%2A> Győződjön meg arról, hogy befejeződött-e aszinkron eseménykezelésnek, hívja meg a <xref:System.Diagnostics.Process.WaitForExit>túlterhelési, amely nem paramétert <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> bejelölése előtt</xref:System.Diagnostics.Process.WaitForExit>       Használhatja a <xref:System.Diagnostics.Process.CloseMainWindow%2A>vagy a <xref:System.Diagnostics.Process.Kill%2A>metódus egy társított folyamat kilépését okozza.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Az értesítést kapjanak, ha a társított folyamat kilépésekor két módja van: szinkron és aszinkron módon. Szinkron értesítési hívása támaszkodik a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer az alkalmazás feldolgozását felfüggeszti, amíg kilép, a társított összetevő.</xref:System.Diagnostics.Process.WaitForExit%2A> Aszinkron értesítési támaszkodik a <xref:System.Diagnostics.Process.Exited>esemény.</xref:System.Diagnostics.Process.Exited> Aszinkron értesítési használatakor <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>értékre kell állítani `true` a a <xref:System.Diagnostics.Process>értesítést kap, hogy a folyamat kilépett az összetevőt.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "Amikor megszakadt a társított folyamat a megadott kód."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nem kilépett a folyamat.       – vagy – a folyamat <xref:System.Diagnostics.Process.Handle*>érvénytelen.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a ExitCode tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Akkor következik be, amikor egy folyamat kilép."
  remarks: "Exited esemény azt jelzi, hogy a társított folyamat kilépésének. Ezt az előfordulást azt jelenti, hogy a folyamat leállítva (megszakítva) vagy sikeresen lezárt. Ez az esemény akkor fordulhat elő, ha csak a értékének a <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>tulajdonság `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Az értesítést kapjanak, ha a társított folyamat kilépésekor két módja van: szinkron és aszinkron módon. Szinkron értesítési azt jelenti, hogy a hívó a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer az aktuális szál letiltása, amíg a folyamat kilép.</xref:System.Diagnostics.Process.WaitForExit%2A> Aszinkron értesítési Exited esemény kiváltásával, amely lehetővé teszi a végrehajtását addig folytatja a hívó szál használja. Az utóbbi esetben <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>értékre kell állítani `true` fogadásához Exited esemény a hívó alkalmazás számára.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Az operációs rendszer egyik folyamat leállítása, ha más folyamatok Exited esemény kiváltásával kezelőkkel regisztrált értesítést küld. Ilyenkor a leíró csak kilépett a folyamat egyes tulajdonságok eléréséhez használt <xref:System.Diagnostics.Process.ExitTime%2A>és <xref:System.Diagnostics.Process.HasExited%2A>, hogy az operációs rendszer kezeli, amíg leíró teljesen felszabadít.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Akkor is, ha van egy amelyekből kiléptek folyamat leírót, nem hívható meg <xref:System.Diagnostics.Process.Start%2A>újra csatlakozni ugyanahhoz a folyamathoz.</xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Start%2A>Automatikusan feloldja a társított folyamat csatlakozik, és ugyanazt a fájlt, de egy teljesen új <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> folyamat</xref:System.Diagnostics.Process.Start%2A> hívása       A Windows Forms-alkalmazásokhoz Exited esemény használatával kapcsolatos további információkért tekintse meg a <xref:System.Diagnostics.Process.SynchronizingObject%2A>tulajdonság.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat kilépésének ideje."
  remarks: "Ha a folyamat nem leállt, megpróbálta beolvasni a ExitTime tulajdonság kivételt. Használjon <xref:System.Diagnostics.Process.HasExited%2A>előtt annak meghatározásához, hogy a társított folyamat megszakítása rendelkezik ExitTime tulajdonság beolvasásakor.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>, amely azt jelzi, ha a társított folyamat meg lett szakítva.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a ExitTime tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő, és a jelenleg aktív folyamatkiszolgálót."
  remarks: "Ezt a módszert használja, hozzon létre egy új <xref:System.Diagnostics.Process>példányt, és rendelje hozzá azt a folyamat erőforrás a helyi számítógépen.</xref:System.Diagnostics.Process>       A hasonló, például <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, és <xref:System.Diagnostics.Process.GetProcesses%2A>módszerek, GetCurrentProcess társítja a meglévő erőforrás egy új <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> az, hogy a hívó alkalmazás fut a folyamat az erőforráshoz hozzárendelt összetevő."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Visszaadja egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevőt, a folyamat azonosítója adni a helyi számítógépen."
  remarks: "Ezt a módszert használja, hozzon létre egy új <xref:System.Diagnostics.Process>összetevő, és rendelje hozzá azt a helyi számítógépen folyamat erőforrás.</xref:System.Diagnostics.Process> A folyamat erőforrás már léteznie kell a számítógépen, mert GetProcessById erőforrás nem hoz létre, de ahelyett, hogy társítja egy erőforrást egy alkalmazás által létrehozott <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> A folyamat <xref:System.Diagnostics.Process.Id%2A>lekérhető csak azon a számítógépen futó folyamat.</xref:System.Diagnostics.Process.Id%2A> A folyamat leáll, miután GetProcessById kivételt jelez, ha át kell neki adni egy lejárt azonosítója.       Bármely adott számítógépen egy adott folyamat azonosító egyedi. GetProcessById legfeljebb adja vissza egy folyamat. Ha le szeretné kérdezni egy adott alkalmazást futtató összes folyamat, használja a <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Ha több folyamatot azon a számítógépen, amelyen a megadott alkalmazás <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>a kapcsolódó folyamatok tartalmazó tömböt ad vissza.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Egyes ezeket a folyamatokat, pedig az annak azonosítója lekérdezhető. A folyamat azonosítójára tekintheti meg a `Processes` a Windows Feladatkezelő panel. A `PID` oszlop megjeleníti a folyamat azonosítója, amelyhez tartozik egy folyamatot."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "A folyamat erőforrás rendszer egyedi azonosítója."
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenst, amely a helyi folyamat erőforrás által azonosított van hozzárendelve a <code> processId </code> paraméter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A folyamat által a <code> processId </code> paraméter nem működik. Előfordulhat, hogy lejárt a azonosítója."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat nem indította el ezt az objektumot."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Visszaadja egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevőt, a folyamat azonosítójára és annak a számítógépnek a nevét a hálózaton megadott."
  remarks: "Ezt a módszert használja, hozzon létre egy új <xref:System.Diagnostics.Process>összetevőt, majd társítsa a hálózat egy távoli számítógépen folyamat erőforrás.</xref:System.Diagnostics.Process> A folyamat erőforrás már léteznie kell a megadott számítógépen, mert GetProcessById erőforrás nem hoz létre, de ahelyett, hogy társítja egy erőforrást egy alkalmazás által létrehozott <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> A folyamat <xref:System.Diagnostics.Process.Id%2A>lekérhető csak azon a számítógépen futó folyamat.</xref:System.Diagnostics.Process.Id%2A> A folyamat leáll, miután GetProcessById kivételt jelez, ha át kell neki adni egy lejárt azonosítója.       Bármely adott számítógépen egy adott folyamat azonosító egyedi. GetProcessById legfeljebb adja vissza egy folyamat. Ha le szeretné kérdezni egy adott alkalmazást futtató összes folyamat, használja a <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Ha több folyamatot azon a számítógépen, amelyen a megadott alkalmazás <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>a kapcsolódó folyamatok tartalmazó tömböt ad vissza.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Egyes ezeket a folyamatokat, pedig az annak azonosítója lekérdezhető. A folyamat azonosítójára tekintheti meg a `Processes` a Windows Feladatkezelő panel. A `PID` oszlop megjeleníti a folyamat azonosítója, amelyhez tartozik egy folyamatot.       Ha nem ad meg egy `machineName`, a helyi számítógépet használja. Másik megoldásként megadhatja a helyi számítógépen úgy, hogy `machineName` az érték &quot;.&quot; vagy üres karakterlánc (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "A folyamat erőforrás rendszer egyedi azonosítója."
    - id: machineName
      type: System.String
      description: "A számítógép neve, a a hálózaton."
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenst, amely a távoli folyamat által azonosított erőforrással társítva van a <code> processId </code> paraméter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A folyamat által a <code> processId </code> paraméter nem működik. Előfordulhat, hogy lejárt a azonosítója.       – vagy – a <code> machineName </code> paraméter szintaxisa érvénytelen. A név hossza nulla (0) lehet."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat nem indította el ezt az objektumot."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Létrehoz egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevőt a helyi számítógépen minden folyamat erőforrás."
  remarks: "Ezt a módszert használja az új létrehozásával tömbje <xref:System.Diagnostics.Process>összetevőket, és rendelje hozzá őket a helyi számítógépen található összes folyamat erőforrások.</xref:System.Diagnostics.Process> A folyamat erőforrások már léteznie kell a helyi számítógépen, mert GetProcesses nem hoz létre a rendszer erőforrásait, de ahelyett, hogy az alkalmazás által létrehozott társítja a erőforrások <xref:System.Diagnostics.Process>összetevők.</xref:System.Diagnostics.Process> Háttérfolyamatok maga az operációs rendszer fut, mert a tömb soha nem üres.       Ha nem szeretné, hogy a számítógépen futó folyamatok beolvasni az összes, az szám használatával korlátozhatja a <xref:System.Diagnostics.Process.GetProcessById%2A>vagy <xref:System.Diagnostics.Process.GetProcessesByName%2A>metódus.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>létrehoz egy <xref:System.Diagnostics.Process>van hozzárendelve a folyamat által a folyamat azonosítója, amelyeket átad a metódus a rendszer azonosított-összetevő.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>létrehoz egy tömbjét <xref:System.Diagnostics.Process>összetevők, amelyek társított folyamat erőforrások megosztása a végrehajtható fájl át a metódusnak.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Több Windows-szolgáltatások tölthetők be a példányt a szolgáltatás gazdafolyamat (svchost.exe) belül. GetProcesses nem határozza meg az egyes szolgáltatások; az adott tekintse meg a <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , amely a helyi számítógépen futó folyamat erőforrások jelöli."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Létrehoz egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponens minden folyamat erőforrás a megadott számítógépen."
  remarks: "Ezt a módszert használja az új létrehozásával tömbje <xref:System.Diagnostics.Process>összetevőket, és rendelje hozzá őket a megadott (általában távoli) számítógépen folyamat-erőforrások.</xref:System.Diagnostics.Process> A folyamat erőforrások már léteznie kell a helyi számítógépen, mert <xref:System.Diagnostics.Process.GetProcesses%2A>nem hoz létre a rendszer erőforrásait, de ahelyett, hogy az alkalmazás által létrehozott társítja a erőforrások <xref:System.Diagnostics.Process>összetevők.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Háttérfolyamatok maga az operációs rendszer fut, mert a tömb soha nem üres.       Ha nem szeretné, hogy a számítógépen futó folyamatok beolvasni az összes, az szám használatával korlátozhatja a <xref:System.Diagnostics.Process.GetProcessById%2A>vagy <xref:System.Diagnostics.Process.GetProcessesByName%2A>metódus.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>létrehoz egy <xref:System.Diagnostics.Process>van hozzárendelve a folyamat által a folyamat azonosítója, amelyeket átad a metódus a rendszer azonosított-összetevő.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>létrehoz egy tömbjét <xref:System.Diagnostics.Process>összetevők, amelyek társított folyamat erőforrások megosztása a végrehajtható fájl át a metódusnak.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Ez túlterhelése a <xref:System.Diagnostics.Process.GetProcesses%2A>módszer általában a hálózat egy távoli számítógépen futó folyamat az erőforrások listájának beolvasásához használt, de úgy, hogy a helyi számítógépen is megadhat &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Több Windows-szolgáltatások tölthetők be a példányt a szolgáltatás gazdafolyamat (svchost.exe) belül. GetProcesses nem határozza meg az egyes szolgáltatások; az adott tekintse meg a <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "A számítógép, amelynek be kell olvasni a folyamatok listáját."
    return:
      type: System.Diagnostics.Process[]
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , amely a megadott számítógépen futó folyamat erőforrásokat jelenti."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <code> machineName </code> paraméter szintaxisa érvénytelen. Előfordulhat, hogy rendelkezik (0) nulla hosszúságú."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Az operációs rendszer platform nem támogatja ezt a műveletet a távoli számítógépeken."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincsenek API folyamatra vonatkozó információ beszerzéséhez használt teljesítményszámláló elérésével kapcsolatos problémák. Ez a kivétel csak Windows NT, a Windows 2000 és a Windows XP elő."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt az alapul szolgáló rendszer API elérése közben."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Új létrehoz egy tömbjét <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevők és az összes a folyamat a helyi számítógépen található erőforrások, amelyek a megadott Folyamatnév társítja őket."
  remarks: "Ezt a módszert használja az új létrehozásával tömbje <xref:System.Diagnostics.Process>összetevőket, és rendelje hozzá őket a folyamat összes olyan erőforrást, ugyanazt a végrehajtható fájlt a helyi számítógépen futó.</xref:System.Diagnostics.Process> A folyamat erőforrások már léteznie kell a számítógépen, mert GetProcessesByName nem hoz létre a rendszer erőforrásait, de ahelyett, hogy az alkalmazás által létrehozott társítja őket <xref:System.Diagnostics.Process>összetevők.</xref:System.Diagnostics.Process> A `processName` adható meg egy végrehajtható fájl, amely jelenleg nem fut. a helyi számítógépen, ezért lehet, hogy a metódus visszaadja a tömb üres.       A folyamat neve egy rövid nevet a folyamat, például az Outlook, amely nem tartalmazza az .exe kiterjesztésű vagy az elérési út. GetProcessesByName akkor hasznos, az első, és ugyanahhoz a végrehajtható fájlhoz társított összes folyamat kezelésére. Például átadhatók egy végrehajtható fájl neve megegyezik a `processName` paramétert, hogy állítsa le a végrehajtható fájlt az összes futó példányát.       Bár a folyamat <xref:System.Diagnostics.Process.Id%2A>értéke egyedi a rendszer a folyamat egyetlen erőforrásra, több folyamatot, a helyi számítógépen futtathatja az alkalmazás által meghatározott a `processName` paraméter.</xref:System.Diagnostics.Process.Id%2A> Ezért <xref:System.Diagnostics.Process.GetProcessById%2A>tömböt ad vissza egy folyamat legfeljebb, de GetProcessesByName értéket ad vissza a kapcsolódó folyamatok tartalmazó.</xref:System.Diagnostics.Process.GetProcessById%2A> Kezelheti a folyamat szabványos API-hívásokkal van szüksége, ha ezeket a folyamatokat, viszont az azonosítója az egyes lekérheti. Folyamat erőforrások nem férhet hozzá, csak a folyamat neve keresztül, de után tömbje beolvasását <xref:System.Diagnostics.Process>összetevők, amelyek a társított folyamat erőforrásokkal start, állítsa le és egyéb kezelheti a rendszererőforrások.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "A folyamat rövid nevét."
    return:
      type: System.Diagnostics.Process[]
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , amely jelzi, hogy a folyamat erőforrásaihoz, a megadott alkalmazáshoz vagy fájlhoz."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincsenek API folyamatra vonatkozó információ beszerzéséhez használt teljesítményszámláló elérésével kapcsolatos problémák. Ez a kivétel csak Windows NT, a Windows 2000 és a Windows XP elő."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Új létrehoz egy tömbjét <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevők és az összes folyamat erőforrást egy távoli számítógépen, amelyek a megadott Folyamatnév társítja őket."
  remarks: "Ezt a módszert használja az új létrehozásával tömbje <xref:System.Diagnostics.Process>összetevőket, és rendelje hozzá őket a azonos végrehajtható fájl a megadott számítógépen futó összes folyamat erőforrás.</xref:System.Diagnostics.Process> A folyamat erőforrások már léteznie kell a számítógépen, mert <xref:System.Diagnostics.Process.GetProcessesByName%2A>nem hoz létre a rendszer erőforrásait, de ahelyett, hogy az alkalmazás által létrehozott társítja őket <xref:System.Diagnostics.Process>összetevők.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> A `processName` adható meg egy végrehajtható fájl, amely jelenleg nem fut. a helyi számítógépen, ezért lehet, hogy a metódus visszaadja a tömb üres.       A folyamat neve egy rövid nevet a folyamat, például az Outlook, amely nem tartalmazza az .exe kiterjesztésű vagy az elérési út. <xref:System.Diagnostics.Process.GetProcessesByName%2A>akkor hasznos, az első, és ugyanahhoz a végrehajtható fájlhoz társított összes folyamat kezelésére.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Például átadhatók egy végrehajtható fájl neve megegyezik a `processName` paramétert, hogy állítsa le a végrehajtható fájlt az összes futó példányát.       Bár a folyamat <xref:System.Diagnostics.Process.Id%2A>értéke egyedi a rendszer a folyamat egyetlen erőforrásra, több folyamatot, a helyi számítógépen futtathatja az alkalmazás által meghatározott a `processName` paraméter.</xref:System.Diagnostics.Process.Id%2A> Ezért <xref:System.Diagnostics.Process.GetProcessById%2A>adja vissza a tartalom legfeljebb egy folyamatot, de <xref:System.Diagnostics.Process.GetProcessesByName%2A>a kapcsolódó folyamatok tartalmazó tömböt ad vissza.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Kezelheti a folyamat szabványos API-hívásokkal van szüksége, ha ezeket a folyamatokat, viszont az azonosítója az egyes lekérheti. Folyamat erőforrások nem férhet hozzá, csak a folyamat neve keresztül, de után tömbje beolvasását <xref:System.Diagnostics.Process>összetevők, amelyek a társított folyamat erőforrásokkal start, állítsa le és egyéb kezelheti a rendszererőforrások.</xref:System.Diagnostics.Process>       Ez a túlterhelés segítségével folyamatok beszerzése a helyi számítógépen, valamint a távoli számítógépen. Használjon &quot;.&quot; a helyi számítógép megadásához. Másik többszörös definíciót, amely alapértelmezés szerint a helyi számítógépet használja létezik.       A távoli számítógépeken csak a vonatkozó információk megtekintése, statisztika, például a folyamatok folyamatok érheti el. Nem zárja be, leállítja (használatával <xref:System.Diagnostics.Process.Kill%2A>), vagy indítsa el a folyamatok távoli számítógépeken.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "A folyamat rövid nevét."
    - id: machineName
      type: System.String
      description: "A számítógép neve, a a hálózaton."
    return:
      type: System.Diagnostics.Process[]
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , amely jelzi, hogy a folyamat erőforrásaihoz, a megadott alkalmazáshoz vagy fájlhoz."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <code> machineName </code> paraméter szintaxisa érvénytelen. Előfordulhat, hogy rendelkezik (0) nulla hosszúságú."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Az operációs rendszer platform nem támogatja ezt a műveletet a távoli számítógépeken."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincsenek API folyamatra vonatkozó információ beszerzéséhez használt teljesítményszámláló elérésével kapcsolatos problémák. Ez a kivétel csak Windows NT, a Windows 2000 és a Windows XP elő."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt az alapul szolgáló rendszer API elérése közben."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat natív leíróját."
  remarks: "Egy alkalmazás szerezhet be egy folyamatot, amely sok-adatok és a vezérlő függvény paramétereként használható leírót. Ez a leíró inicializálására használható egy <xref:System.Threading.WaitHandle>vagy hívni a platformmal natív metódusok meghívása.</xref:System.Threading.WaitHandle>       Ez a folyamat leíró sajátja alkalmazáshoz való – azaz folyamat leírók nem osztható meg. A folyamat is rendelkezik egy folyamat <xref:System.Diagnostics.Process.Id%2A>, a leíró eltérően ez az egyedi, emiatt a rendszerben érvényes.</xref:System.Diagnostics.Process.Id%2A>       Hívása a lépések csak folyamatok <xref:System.Diagnostics.Process.Start%2A>a megfelelő leíró tulajdonságának beállítása <xref:System.Diagnostics.Process>példányok.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Az operációs rendszer rendelt a társított folyamat, amikor a folyamat elindításának leíró. A rendszer a folyamat attribútumok nyomon követheti, hogy ez a leíró használja."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat nem lett elindítva, vagy kilépett. A leíró tulajdonság nem olvasható be, mert nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> példány.       – vagy – a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> példányhoz van csatolva egy futó folyamatot, de nincs teljes hozzáférési jogosultsággal rendelkező leírót eléréséhez szükséges engedélyekkel."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a leíró tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a folyamat által megnyitott leíróinak száma."
  remarks: "Leírók lehetőséget nyújtanak olyan objektumra hivatkozik a folyamatot. A folyamat kezeli a fájlok, erőforrásokhoz, üzenetsorok és sok más operációs rendszer objektumot úgy szerezheti be. Az operációs rendszer úgy szabadít fel a memória, a folyamathoz társított, csak ha az ablakleírók száma nulla."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Nyitotta meg a folyamatot operációs rendszer leírók száma."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be a &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; tulajdonságot <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy érték, amely jelzi, hogy a társított folyamat meg lett szakítva, lekérdezi."
  remarks: "Érték `true` a HasExited jelzi, hogy a társított folyamat, általában vagy rendellenesen. Kérheti, vagy a társított folyamat kilépését vagy <xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> kényszerítése Ha meg van nyitva a folyamat egy leíró, az operációs rendszer a folyamat kilépett, de megtartja a felügyeleti információk a folyamat, például a leíró, kilépési kód és kilépési idő felszabadít a folyamat. Ezek az információk beszerzéséhez használja a <xref:System.Diagnostics.Process.ExitCode%2A>és <xref:System.Diagnostics.Process.ExitTime%2A>Tulajdonságok.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Ezeket a tulajdonságokat a rendszer automatikusan feltölti folyamatok, ez az összetevő által elindított. A felügyeleti információk felszabadul amikor minden a <xref:System.Diagnostics.Process>összetevők, a rendszer folyamat társított megsemmisülnek, és tartsa lenyomva több leírók amelyekből kiléptek folyamatához.</xref:System.Diagnostics.Process>       A folyamat függetlenül a kódot is leáll. Ha ezzel a komponenssel folyamat indult el, a rendszer frissíti a HasExited automatikusan, akkor is, ha a társított folyamat kilépésekor egymástól függetlenül.      > [!NOTE] > Szabványos kimeneti aszinkron eseménykezelők átirányítva, esetén lehetséges, hogy a kimeneti feldolgozása nem befejeződött-e arról, ha a tulajdonság adja vissza `true`. Győződjön meg arról, hogy befejeződött-e a aszinkron eseménykezelésnek, hívja meg a <xref:System.Diagnostics.Process.WaitForExit>HasExited bejelölése előtt nem paraméterrel rendelkező túlterhelést.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az operációs rendszer folyamatának hivatkozik a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő leállt; ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Egyetlen folyamat sem az objektumhoz társított van."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A kilépési kódot, a folyamat nem olvasható be."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a HasExited tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A társított folyamat lekéri az egyedi azonosító."
  remarks: "A folyamat azonosítója nincs érvényes, ha a társított folyamat nem működik. Emiatt biztosítania kell, hogy fut-e a folyamat az Id tulajdonság beolvasására tett kísérlet előtt. Amíg a folyamat véget nem ér, a folyamat azonosítójára egyedileg azonosítja a folyamat során a rendszer.       Csatlakozhat egy új helyi vagy távoli számítógépen futó folyamat <xref:System.Diagnostics.Process>úgy, hogy a folyamat azonosítója a példányt a <xref:System.Diagnostics.Process.GetProcessById%2A>metódus.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>van egy `static` metódus, amely létrehoz egy új összetevő, és az Id tulajdonság beállítása az új <xref:System.Diagnostics.Process>automatikusan példány.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Folyamat azonosítók használható fel újra, a rendszer. Az Id tulajdonság értéke egyedi csak a társított folyamat közben. Miután a folyamat megszakad, a rendszer az Id tulajdonság értéke egy független folyamat is felhasználhatja.       Mivel a rendszer egyedi azonosítója, akkor is adja át azt az más szálak sikeres helyett egy <xref:System.Diagnostics.Process>példány.</xref:System.Diagnostics.Process> Ez a művelet mentése rendszererőforrásokat, mégis garantálja, hogy a folyamat megfelelő azonosítását."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "A rendszer által létrehozott egyedi azonosító a folyamat által hivatkozott <xref href=&quot;System.Diagnostics.Process&quot;> </xref> példány."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat azonosítója tulajdonság nincs beállítva.       - vagy - nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be a &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; tulajdonságot <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A társított folyamat azonnal leáll."
  remarks: "Kill kényszeríti a a folyamat futása közben <xref:System.Diagnostics.Process.CloseMainWindow%2A>egy csak kéri.</xref:System.Diagnostics.Process.CloseMainWindow%2A> A folyamat egy grafikus felülettel végrehajtásakor a üzenetkezelő ciklus várakozási állapotban van. Az üzenetkezelő ciklus minden alkalommal, amikor egy Windows üzenetet küld a folyamat által az operációs rendszer hajtja végre. Hívása <xref:System.Diagnostics.Process.CloseMainWindow%2A>megközelíti a fő ablakban, amelyet egy megfelelően formázott alkalmazásban gyermekablakok bezárja, és az alkalmazás összes futó üzenet hurkok visszavonja a kérést küld.</xref:System.Diagnostics.Process.CloseMainWindow%2A> A kérelem a folyamat kilép meghívásával <xref:System.Diagnostics.Process.CloseMainWindow%2A>nem kényszeríti az alkalmazás kilép.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Az alkalmazás felhasználói ellenőrzés Kilépés előtt kérje meg, vagy visszautasíthatja a való kilépéshez. Az alkalmazás bezárásának kényszerítése, használja a Kill metódust. A viselkedését <xref:System.Diagnostics.Process.CloseMainWindow%2A>megegyezik-e a felhasználó egy alkalmazást a rendszer menü segítségével fő ablak bezárása.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Ezért a kérelem a kilépéshez a folyamat által a fő ablak bezárása nem alkalmazásának a kényszerítéséhez azonnali bezárásához.      > [!NOTE] > A Kill metódus aszinkron módon végrehajtja. A Kill metódus hívása után hívható meg a <xref:System.Diagnostics.Process.WaitForExit%2A>metódus várja meg a folyamat bezárásához, vagy ellenőrizze, hogy a <xref:System.Diagnostics.Process.HasExited%2A>tulajdonság határozza meg, ha a folyamat már kilépett.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       A folyamat szerkesztett adatok vagy az erőforrások vannak rendelve a folyamat elvesznek, ha meghívja a Kill. Kill egy rendellenes folyamat futása okozza, és csak szükség esetén használható. <xref:System.Diagnostics.Process.CloseMainWindow%2A>lehetővé teszi, hogy a folyamat egy szabályos megszüntetése, és bezárja a minden windows, érdemes felülettel alkalmazásokhoz.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Ha <xref:System.Diagnostics.Process.CloseMainWindow%2A>meghiúsul, segítségével Kill a folyamat leáll.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill folyamatok, amelyek nem rendelkeznek grafikus felületek leáll az egyetlen lehetőség.       Kill hívása és <xref:System.Diagnostics.Process.CloseMainWindow%2A>csak a helyi számítógépen futó folyamat.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Folyamatok nem okozhat a távoli számítógépeken való kilépéshez. Csak a távoli számítógépeken futó folyamatok információk is megtekinthetők.      > [!NOTE] > A Kill metódus hívása történik, amíg a folyamat jelenleg leáll, ha egy <xref:System.ComponentModel.Win32Exception>vált ki, a hozzáférés megtagadva.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nem sikerült a társított folyamat megszakítása.       – vagy – a folyamat leáll.       – vagy – a társított folyamat egy Win16 végrehajtható."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Egy távoli számítógépen futó folyamat vonatkozóan hívja meg a Kill próbál. A metódus csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat már kilépett.       - vagy - nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Tart egy <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponens, amely lehetővé teszi, hogy azt a speciális módban futó operációs rendszer folyamataihoz interakciót állapotát."
  remarks: "Egyes operációs rendszer folyamatokat speciális módban fut. Tulajdonságainak olvasása vagy ezeket a folyamatokat csatolása nincs lehetőség hívott <xref:System.Diagnostics.Process.EnterDebugMode%2A>összetevőjének.</xref:System.Diagnostics.Process.EnterDebugMode%2A> LeaveDebugMode hívására már nem szükséges különleges módban futó folyamatok elérésére."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat fut a számítógép nevét."
  remarks: "Statisztikai adatok tekinthetők meg és nem hívható meg, de távoli számítógépeken futó folyamatok folyamat információi <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, vagy <xref:System.Diagnostics.Process.Kill%2A>távoli számítógépeken.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > A társított folyamat végrehajtásakor a helyi gépen ezt a tulajdonságot egy dátumtartományt ad vissza (&quot;.&quot;) a gép neve. Használjon a <xref:System.Environment.MachineName%2A?displayProperty=fullName>tulajdonság használatával beolvassa a megfelelő számítógépnév.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "A társított folyamat futtató számítógép neve."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincs a nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A fő modul lekérdezi a társított folyamat."
  remarks: "A folyamat modul a.dll vagy .exe fájl, amely egy adott folyamat-bA betöltött jelöli. A MainModule tulajdonság lehetővé teszi a végrehajtható fájl, beleértve a modul neve, a fájl neve és a modul memória részleteit a folyamat elindításához használt vonatkozó információk megtekintése."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "A <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> a folyamat elindításához használt."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a MainModule tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Egy 32 bites folyamatként megpróbál hozzáférni egy 64 bites folyamat modulok."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>       – vagy – a folyamat már kilépett."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat főablakának az ablak leíróját."
  remarks: "A főablak a folyamat, amely éppen fókuszban van a ablakban (a <xref:System.Windows.Forms.Form.TopLevel%2A>formában).</xref:System.Windows.Forms.Form.TopLevel%2A> Kell használnia a <xref:System.Diagnostics.Process.Refresh%2A>metódus frissítéséhez a <xref:System.Diagnostics.Process>objektum lekérni az aktuális fő ablak leíróját, amennyiben a változás.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> Az ablak leíróját található a gyorsítótárban, mert használni <xref:System.Diagnostics.Process.Refresh%2A>előre garantálja, hogy be fogja olvasni az aktuális leíró.</xref:System.Diagnostics.Process.Refresh%2A>       Kaphat a MainWindowHandle tulajdonság csak a helyi számítógépen futó folyamat. A MainWindowHandle tulajdonság, amely egyedileg azonosítja a az ablak a folyamat társított értéket.       A folyamat csak akkor, ha a folyamat egy grafikus felülettel rendelkezik, a vele társított egy fő ablak rendelkezik. A társított folyamat nem rendelkezik a fő ablakot, ha a MainWindowHandle értéke nulla. Az érték akkor is nulla folyamatok elrejtett, ez azt jelenti, hogy feldolgozza, amelyek nem láthatók a tálcán. Ez lehet az, hogy az értesítési területen a tálca jobb szélén ikonokkal folyamatok esetében.       Ha most indította el egy folyamatot, és a fő ablakleíró használni szeretne, érdemes lehet a <xref:System.Diagnostics.Process.WaitForInputIdle%2A>lehetővé a folyamat elindul, győződjön meg arról, hogy létrejött-e a fő ablak leíróját.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Ellenkező esetben kivételt fog jelezni."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "A fő ablakot, a társított folyamat a rendszer ablak leíróját."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A MainWindowHandle nincs definiálva, mert a folyamat már kilépett."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a MainWindowHandle tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a folyamat főablakának felirat."
  remarks: "A folyamat csak akkor, ha a folyamat egy grafikus felülettel rendelkezik, a vele társított egy fő ablak rendelkezik. Ha a társított folyamat nem rendelkezik a főablak (így <xref:System.Diagnostics.Process.MainWindowHandle%2A>nulla), MainWindowTitle érték egy üres karakterlánc (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Ha most indította el egy folyamatot, és szeretné használni a fő ablak címe, érdemes lehet a <xref:System.Diagnostics.Process.WaitForInputIdle%2A>lehetővé a folyamat elindul, győződjön meg arról, hogy létrejött-e a fő ablak leíróját.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Ellenkező esetben a rendszer kivételt jelez.      > [!NOTE] > A főablak, az ablak, amely éppen fókuszban van; ez nem lehet a folyamat elsődleges ablakának megjegyzés. Kell használnia a <xref:System.Diagnostics.Process.Refresh%2A>metódus frissítéséhez a <xref:System.Diagnostics.Process>objektum lekérni az aktuális fő ablak leíróját, amennyiben a változás.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "A folyamat főablakának címe."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A MainWindowTitle tulajdonság nincs definiálva, mert a folyamat kilépett a."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a MainWindowTitle tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a processzoridő munkahalmaz maximális mérete, a társított folyamat bájtban."
  remarks: "Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatokat tartalmaz, amely az alkalmazás végrehajtja, beleértve a lapok a DLL-fájlok és a system.dll fájlok összes utasítást tartalmazó összes lapot. A munkakészlet méretének növekedése, memória igény is növekszik.       A folyamatnak a minimális és maximális működő készlet mérete van. Minden alkalommal, amikor a folyamat létrehozása történt meg, a rendszer fenntartja a munkahalmaz minimális mérete a folyamat megegyezik egy memóriamennyiség. A virtuális memória kezelője megkísérli megtarthatják legalább memória minimális mérete rezidens a folyamatban, de soha nem tartja nagyobb a maximális méreténél.       A rendszer használata a készlet méretét alapértelmezett beállítása. Ezen méretét a MaxWorkingSet használatával módosíthatja és <xref:System.Diagnostics.Process.MinWorkingSet%2A>tagok.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Azonban ezek az értékek beállítása nem garantálja, hogy a memória fenntartott vagy tartózkodási helye lesz-e.      > [!NOTE] > Folyamat működő készlet méretének növelésével választja el a rendszer a többi fizikai memória. Győződjön meg arról, hogy nem kér le a minimális vagy maximális működő mérete, amely túl nagy, mivel ezzel a rendszer teljesítménye csökkentheti."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "A munkakészlet maximális mérete engedélyezett memória az a folyamat, bájtban."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Érvénytelen a munkahalmaz maximális méreténél. Kisebb a munkahalmaz minimális méreténél kell lennie."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Működik-e információ nem olvasható be a társított folyamat erőforrás.       – vagy – a folyamatazonosító vagy folyamatleíró nem nulla, mert a folyamat nem lett elindítva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a MaxWorkingSet tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>       – vagy – a folyamat már kilépett."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a minimális megengedett működő mérete, a társított folyamat bájtban."
  remarks: "Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatokat tartalmaz, amely az alkalmazás végrehajtja, beleértve a lapok a DLL-fájlok és a system.dll fájlok összes utasítást tartalmazó összes lapot. A munkakészlet méretének növekedése, memória igény is növekszik.       A folyamatnak a minimális és maximális működő készlet mérete van. Minden alkalommal, amikor a folyamat létrehozása történt meg, a rendszer fenntartja a munkahalmaz minimális mérete a folyamat megegyezik egy memóriamennyiség. A virtuális memória kezelője megkísérli megtarthatják legalább memória minimális mérete rezidens a folyamatban, de soha nem tartja nagyobb a maximális méreténél.       A rendszer használata a készlet méretét alapértelmezett beállítása. Ezek méretek használatával módosíthatja a <xref:System.Diagnostics.Process.MaxWorkingSet%2A>és MinWorkingSet tagok.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Azonban ezek az értékek beállítása nem garantálja, hogy a memória fenntartott vagy tartózkodási helye lesz-e.      > [!NOTE] > Folyamat működő készlet méretének növelésével választja el a rendszer a többi fizikai memória. Győződjön meg arról, hogy nem kér le a minimális vagy maximális működő mérete, amely túl nagy, mivel ezzel a rendszer teljesítménye csökkentheti."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "A minimális munkakészlet mérete szükséges memória az a folyamat, bájtban."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A munkahalmaz minimális mérete érvénytelen. Kisebb vagy egyenlő a munkahalmaz maximális méreténél kell lennie."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Működik-e információ nem olvasható be a társított folyamat erőforrás.       – vagy – a folyamatazonosító vagy folyamatleíró nem nulla, mert a folyamat nem lett elindítva."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a MinWorkingSet tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>       – vagy – a folyamat már kilépett."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat által betöltött modulok."
  remarks: "A folyamat modul a.dll vagy .exe fájl, amely egy adott folyamat-bA betöltött jelöli. A <xref:System.Diagnostics.ProcessModule>példány lehetővé teszi, hogy egy modul, beleértve a modul neve, a fájl neve és a modul memória részleteit vonatkozó információk megtekintése.</xref:System.Diagnostics.ProcessModule>       A folyamat is több modul betölti a memóriába. További .dll fájlt .exe fájlok például több modul rendelkeznek.       A folyamat elindítása után a gyűjtemény nem üres amíg a rendszer betöltötte a folyamat. A folyamat rendelkezik egy fő ablakot, ha hívása <xref:System.Diagnostics.Process.WaitForInputIdle%2A>annak biztosításához, hogy a gyűjtemény nem üres esetén ez a tulajdonság beolvasása előtt listájának lekérdezése.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> , amely a társított folyamat által betöltött modulok jelöli."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a modulok tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A modulok tulajdonság a folyamat vagy az üresjárati folyamat elérni kívánt. Ezek az eljárások nincsenek modulok."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a nem lapozható rendszermemória, mennyisége bájtban megadva, a társított folyamat számára lefoglalt."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Memória (bájt) a rendszer által lefoglalt a társított folyamat, amely a virtuális memória lapozófájlméretének nem írható."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a nem lapozható rendszermemória, mennyisége bájtban megadva, a társított folyamat számára lefoglalt."
  remarks: "Ez a tulajdonság által visszaadott érték pillanatnyi mérete bájtban megadva, a folyamat által használt nem lapozható rendszermemória jelöli. Rendszermemória az operációs rendszer által felhasznált fizikai memória, és lapozható és a nem lapozható készlet van osztva. A nem lapozható memória kiosztásokat rendszermemória maradnak, és nem a virtuális memória lapozófájlméretének kilapozta.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **lapozható készlet** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A rendszer memória mérete, a társított folyamat, amely nem lehet írni a virtuális memória lapozófájlméretének lefoglalt mennyisége."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Kiváltja a <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> esemény."
  remarks: "OnExited az API-metódusra, amely kiváltja a <xref:System.Diagnostics.Process.Exited>esemény.</xref:System.Diagnostics.Process.Exited> OnExited okok hívja a <xref:System.Diagnostics.Process.Exited>esemény bekövetkezzen, és csak úgy kell kiadni az esemény használatával a <xref:System.Diagnostics.Process>összetevő.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited elsősorban az összetevő-osztályok származtatáskor.       OnExited alternatívájaként írhat a saját eseménykezelő. Létrehozhat saját esemény kezelő delegált és saját eseménykezelésnek módszert.      > [!NOTE] > A Visual Studio-környezetet használ, ha egy esemény kezelő delegált (AddOnExited) és egy eseménykezelésnek módszer (Process1_Exited) a rendszer létrehozza a húzásakor egy <xref:System.Diagnostics.Process>űrlapra összetevőt, és kattintson az ikonra.</xref:System.Diagnostics.Process> A kód létrehozása futtatható, ha a <xref:System.Diagnostics.Process.Exited>esemény történik a Process1_Exited eljárás bekerültek.</xref:System.Diagnostics.Process.Exited> Nem létrehozandó OnExited tag, mert meg van valósítva meg.       Az eseménykezelő keresztül egy delegált esemény indítása hív meg. Megtudhatja, [események](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Akkor következik be, minden alkalommal, amikor egy alkalmazás ír egy sor az átirányított <xref:System.Diagnostics.Process.StandardOutput*>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "A OutputDataReceived esemény azt jelzi, hogy a társított <xref:System.Diagnostics.Process>végződő sorvége karaktert, hogy az átirányított sor írás <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Az esemény engedélyezve van a <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> aszinkron olvasási műveletek során Indítsa el az aszinkron olvasási műveleteknél, irányítsa át az <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam egy <xref:System.Diagnostics.Process>, a eseménykezelő OutputDataReceived eseményt, és hívja meg <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Ezt követően a OutputDataReceived esemény jelek minden alkalommal, amikor a folyamat ír egy sor az átirányított <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam, amíg a folyamat kilép, vagy <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> hívások</xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > Az aszinkron kimeneti feldolgozó meg kell hívnia a <xref:System.Diagnostics.Process.WaitForExit%2A>módszer annak biztosítására, hogy a kimeneti puffer ki lettek ürítve.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a lapozható memória mennyisége bájtban a társított folyamat."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "A mennyiségű memória mérete, a társított folyamat, amely a virtuális memória lapozófájlméretének írhatók le van foglalva."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a lapozható memória mennyisége bájtban a társított folyamat."
  remarks: "Ez a tulajdonság által visszaadott érték a virtuális memória lapozófájlméretének bájt, a folyamat által használt memória aktuális méretét adja meg. Az operációs rendszer a virtuális memória lapozófájlméretének együtt a fizikai memória kezeléséhez használt virtuális címtartomány az összes folyamat használja. Lapozható memória nincs használatban, ha azt a virtuális memória lapozófájlméretének lemezen át lehet vinni. A folyamat az operációs rendszer által felhasznált memória mérete beszerzéséhez használja a <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>tulajdonság.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **lap fájl bájt** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Bájt, a virtuális memória lapozófájlméretének a társított folyamat a lefoglalt memória mennyiségét."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a lapozható rendszermemória mérete bájtban a társított folyamat."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Memória (bájt) a rendszer által lefoglalt a társított folyamat, amely a virtuális memória lapozófájlméretének csak írható."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a lapozható rendszermemória mérete bájtban a társított folyamat."
  remarks: "Ez a tulajdonság értéke által visszaadott érték pillanatnyi mérete bájtban megadva, a folyamat által használt lapozható rendszermemória jelöli. Rendszermemória az operációs rendszer által felhasznált fizikai memória, és lapozható és a nem lapozható készlet van osztva. Lapozható memória nincs használatban, ha azt a virtuális memória lapozófájlméretének lemezen át lehet vinni. Az alkalmazás memória, a folyamat által használt beszerzéséhez használja a <xref:System.Diagnostics.Process.PagedMemorySize64%2A>tulajdonság.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **készlet lapozható bájt** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A rendszer memória mérete, a társított folyamat, amely a virtuális memória lapozófájlméretének csak írható lefoglalt mennyisége."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A virtuális memória lapozófájlméretének bájt, a társított folyamat által használt memória maximális mennyisége beolvasása."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Memória mérete, a virtuális memória lapozófájlméretének sikerült írni a társított folyamat által lefoglalt maximális mennyisége."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A virtuális memória lapozófájlméretének bájt, a társított folyamat által használt memória maximális mennyisége beolvasása."
  remarks: "Az e tulajdonság értéke által visszaadott érték azt jelenti, hogy a virtuális memória lapozófájlméretének indítása, bájtban óta a folyamat által használt memória maximális méretét. Az operációs rendszer a virtuális memória lapozófájlméretének együtt a fizikai memória kezeléséhez használt virtuális címtartomány az összes folyamat használja. Lapozható memória nincs használatban, ha azt a virtuális memória lapozófájlméretének lemezen át lehet vinni.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **lap fájl bájtok maximális** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A maximális memóriamennyiség, bájtban a virtuális memória lapozófájlméretének a társított folyamat az indítása óta."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a virtuális memória maximális mennyisége (bájt) a társított folyamat által használt."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Virtuális memória mérete, a társított folyamat által kért maximális mennyisége."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a virtuális memória maximális mennyisége (bájt) a társított folyamat által használt."
  remarks: "Ez a tulajdonság által visszaadott érték indítása, bájtban óta a folyamat által felhasznált virtuális memória maximális méretét jelenti. Az operációs rendszer leképezi a használt virtuális címtartomány az összes folyamat vagy lapok betöltése a fizikai memória, vagy a virtuális memória lapozófájlméretének lemezen tárolt lapra.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **virtuális memória maximális** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Virtuális memória mérete, a társított folyamat az indítása óta lefoglalt maximális mennyisége."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a munkakészlet max. mérete a társított folyamat bájtban."
  remarks: "Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatok tartalmazzák a folyamat végrehajtása során, beleértve a folyamatmodulok és a könyvtár összes utasítást tartalmazó összes lapot."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "A társított folyamat egyszerre, bájtban számára szükséges fizikai memória maximális mennyisége."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a fizikai memória maximális mérete (bájt) a társított folyamat által használt."
  remarks: "A tulajdonság érték azt jelenti, hogy működik-e indítása, bájtban óta a folyamat által használt memória maximális méretét. Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatok közé tartoznak az utasításokat, amely a folyamat végrehajtja, beleértve a folyamatmodulok és a rendszer könyvtárak utasításokat tartalmazó összes lapot.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **munkakészletének** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Fizikai memória mérete, a társított folyamat az indítása óta lefoglalt maximális mennyisége."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi, hogy a társított folyamat prioritású kell ideiglenesen kell súlyozott az operációs rendszer, amikor a fő ablakot van a fókusz."
  remarks: "A szál futtatásakor a folyamat, amelynek a prioritás osztály rendelkezik-e a dinamikus prioritás számbavételi érték (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, vagy <xref:System.Diagnostics.ProcessPriorityClass>), a rendszer átmenetileg boosts a szál prioritását, a várakozási állapotát időpontjában.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Ez a művelet megelőzhető, hogy más folyamatok feldolgozása az aktuális szál megszakítása. A PriorityBoostEnabled beállítás hatással van, a meglévő szálak és bármely ezt követően a folyamat által létrehozott szálak. Ezek normál viselkedése visszaállításához a tulajdonsága PriorityBoostEnabled `false`.      > [!NOTE] > Túl magas prioritású kiemelése is üríthetik erőforrások alapvető operációs rendszer és a hálózati funkciók, a más operációs rendszertől származó tevékenységnek problémát okoz."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a folyamat prioritását dinamikus kiemelése kell végrehajtani a folyamatot a várakozási állapotát; időpontjában Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Az alapértelmezett érték <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nem sikerült beolvasni a társított folyamat erőforrás prioritás program adatait."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot.       – vagy – a folyamatazonosító vagy folyamatleíró értéke nulla. (A folyamat még nem kezdődött.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a PriorityBoostEnabled tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a teljes prioritású kategória a társított folyamat."
  remarks: "A folyamat prioritásosztály szál prioritási szintek számos magában foglalja. A folyamatban futó különböző prioritású szálai képest a folyamat a prioritás osztály. Win32 / osztály hét alapprioritás-szintjének szintű négy prioritás-osztályokat használja. Ezen folyamat prioritás osztályok a rendszer rögzíti a <xref:System.Diagnostics.ProcessPriorityClass>számbavételi, amely lehetővé teszi, hogy a folyamat-prioritás beállítása <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, vagy <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Eltelt vagy más növekedhet, az alapprioritás-szintjének szint az operációs rendszer által módosítható, ha a folyamat kell rendezni előre mások számára a hozzáférés a feldolgozó ideje alapján. Emellett beállíthatja a <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>a prioritási szintet, várjon, amíg állapotát került sor szálak ideiglenesen növelése érdekében.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> A prioritás alaphelyzetbe áll, ha a folyamat a várakozási állapotba tér vissza.       A <xref:System.Diagnostics.Process.BasePriority%2A>tulajdonság lehetővé teszi a kiindulási prioritás, amelyhez tartozik egy folyamat megtekintését.</xref:System.Diagnostics.Process.BasePriority%2A> Mivel csak olvasható, nem használhatja azonban a <xref:System.Diagnostics.Process.BasePriority%2A>prioritást kapjon egy adott folyamat-tulajdonság.</xref:System.Diagnostics.Process.BasePriority%2A> A prioritás módosításához használja a PriorityClass tulajdonság, amely lekérdezi vagy beállítja a folyamat a teljes prioritású kategóriát.       A prioritás osztály Rendszerfigyelő nem lehet megtekinteni. A következő tábla közötti kapcsolatot ábrázolja a <xref:System.Diagnostics.Process.BasePriority%2A>és PriorityClass értékek.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority |} PriorityClass |}   |------------------|-------------------|   |}&4; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&8; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&13; |} <xref:System.Diagnostics.ProcessPriorityClass>|   |}&24; |} <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "A prioritás kategória a társított folyamat, amelyből a <xref:System.Diagnostics.Process.BasePriority*>kiszámítása a folyamat.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Folyamat prioritású virtuális gép adatait nem be vagy nem a társított folyamat erőforrás lekérése.       – vagy – a folyamatazonosító vagy folyamatleíró értéke nulla. (A folyamat még nem kezdődött.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a PriorityClass tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem áll rendelkezésre.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Adott meg a PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> Windows 98 vagy Windows Me (Windows Me) használatakor. Ezek a rendszerek nem támogatják az ezeket az értékeket a azon."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Prioritás osztály nem állítható be, mert nem használ egy érvényes értéket a a <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> enumerálása."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a saját memória mennyisége bájtban megadva, a társított folyamat számára lefoglalt."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "A társított folyamat, amely nem osztható meg más folyamatokkal által lefoglalt bájtok száma."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a saját memória mennyisége bájtban megadva, a társított folyamat számára lefoglalt."
  remarks: "Ez a tulajdonság által visszaadott érték bájt nem osztható meg más folyamatokkal, a folyamat által használt memória aktuális méretét jelenti.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **saját memória** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Bájt nem osztható meg más folyamatokkal a társított folyamat számára lefoglalt memória mennyiségét."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a kiemelt processzoridő folyamat."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>, amely azt jelzi, hogy a folyamat az operációs rendszer magjában kódfuttatásra fordított idő.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a PrivilegedProcessorTime tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a folyamat nevét."
  remarks: "A Folyamatnév tulajdonság egy végrehajtható fájl neve, pl. az Outlook, amely nem tartalmazza az .exe kiterjesztésű vagy az elérési út tartalmazza. Akkor célszerű beolvasására, és ugyanahhoz a végrehajtható fájlhoz társított összes folyamat kezelésére.      > [!NOTE] > A [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] operációs rendszereket, a Folyamatnév tulajdonság lehet, hogy csonkolja 15 karakterből álljon, ha a modul adatok nem olvashatók be.       Hívása <xref:System.Diagnostics.Process.GetProcessesByName%2A>, átadja azt a végrehajtható fájl neve, egy tömb, amely tartalmazza a minden futó példány a megadott számítógépen.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Használhatja a tömb, például a végrehajtható fájl az összes futó példányát le kell állítania."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "A rendszer által a folyamat a felhasználó azonosítására használt név."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat nem rendelkezik azonosítóval, vagy egyetlen folyamat sem társítva van a <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       – vagy – a társított folyamat már kilépett."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A folyamat nincs ezen a számítógépen."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a processzorok, amelyen a folyamat szálai ütemezhető a futtatása."
  remarks: "A Windows 2000 és újabb verziók a szál folyamatban áttelepítheti a processzor a processzor, az egyes áttelepítési újból betölteni a processzor gyorsítótárának. A rendszer túl nagy terhelés esetén megadása, hogy egy bizonyos szálhoz kell futtatnia a jobb teljesítmény érdekében csökkenti a szám, ahányszor a processzor gyorsítótárának van töltve. A processzorra és a szál között a társítás a processzor-affinitás.       Minden processzor képviseli, egy kicsit. Bit 0 valamelyik processzor, a bit 1 két processzor, és így tovább. Ha egy kicsit 1 értéket, a megfelelő feldolgozó szál hozzárendelés van kiválasztva. Ha úgy állítja be a ProcessorAffinity érték, az operációs rendszer ütemezési algoritmusok beállítani a szál affinitását. A ProcessorAffinity értéke nem nulla értéket, ha az érték egy bitmaszk, amely meghatározza az adott jogosult a kijelölés processzorok kerül értelmezésre.       Az alábbi táblázat a kijelölt nyolc processzor rendszer ProcessorAffinity értékeket.      | Bitmaszk |} Bináris érték |} Jogosult feldolgozók |}   |-------------|------------------|-------------------------|   |} 0x0001 |} 00000000 00000001 |} 1 |}   |} 0x0003 |} 00000000 00000011 |} 1. és 2 |}   |} 0x0007 |} 00000000 00000111 |} 1, 2, 3 |}   |} 0x0009 |} 00000000 00001001 |} 1. és 4 |}   |} 0x007F |} 00000000 01111111 |} 1, 2, 3, 4, 5, 6 és 7 |}"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "A processzorok, a társított folyamat szála futtatható képviselő bitmaszk. Az alapértelmezett attól függ, hogy a processzorok számát. Az alapértelmezett érték 2 <sup>n</sup> -1, ahol n az processzorok száma."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "ProcessorAffinity információ nem állítsa be vagy nem a társított folyamat erőforrás lekérése.       – vagy – a folyamatazonosító vagy folyamatleíró értéke nulla. (A folyamat még nem kezdődött.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a ProcessorAffinity tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat <xref:System.Diagnostics.Process.Id*>nem volt elérhető.</xref:System.Diagnostics.Process.Id*>       – vagy – a folyamat már kilépett."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Elveti a társított folyamat, amely a folyamat-összetevőnek belül gyorsítótárazott semmilyen információt."
  remarks: "Frissítési nevezik, miután az első kérésre az egyes tulajdonságok hatására a folyamat-összetevőnek szerezzen be új értéket a társított folyamat.       Ha egy <xref:System.Diagnostics.Process>összetevő társul a folyamat erőforrás tulajdonságainak értékei a <xref:System.Diagnostics.Process>a rendszer azonnal feltölti a társított folyamat állapotának megfelelően.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Ha a társított folyamat információt később változik, ezeket a módosításokat nem jelennek meg a <xref:System.Diagnostics.Process>összetevő gyorsítótárazott értékek.</xref:System.Diagnostics.Process> A <xref:System.Diagnostics.Process>összetevője a folyamat erőforrás pillanatképe társítva időpontjában.</xref:System.Diagnostics.Process> A társított folyamat az aktuális értékek megtekintéséhez a frissítési metódust hívja."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy érték, amely jelzi, hogy válaszol-e a felhasználói felületen a folyamat lekérdezi."
  remarks: "Ha a folyamat egy felhasználói felületet, a válaszoló tulajdonság felveszi a kapcsolatot annak meghatározásához, hogy a folyamat válaszol-e a felhasználói bevitelt a felhasználói felület. Ha az illesztő nem válaszol, azonnal a válaszoló tulajdonság beolvasása `false`. Ez a tulajdonság segítségével határozza meg, hogy a kapcsolat a társított folyamat nem válaszol.       Ha a folyamat nem rendelkezik egy <xref:System.Diagnostics.Process.MainWindowHandle%2A>, ez a tulajdonság adja vissza `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a felhasználói felület, a társított folyamat válaszol-e a rendszer; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincs a nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a válaszoló tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ez a folyamat natív leírójának lekérése."
  remarks: "A leíró csak akkor használható, ha a hívó összetevő kezdte a folyamatot."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "Ez a folyamat natív leírójának."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A Terminálszolgáltatások munkamenet-azonosító lekérése a társított folyamat."
  remarks: "A SessionId tulajdonság a munkamenetet, amelyben az alkalmazás jelenleg fut azonosító."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "A Terminálszolgáltatások munkamenet-azonosító a társított folyamat."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Nincs a folyamathoz társított munkamenet sincs."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincs egyetlen folyamat sem társított a munkamenet-azonosítót.       – vagy – a társított folyamat nincs ezen a számítógépen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A SessionId tulajdonság nem támogatott Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a hiba az alkalmazás kimenete olvasásához használt adatfolyam."
  remarks: "Ha egy <xref:System.Diagnostics.Process>szöveg ír a szabványos hibaadatfolyam, hogy az általában üzenet jelenik meg a konzolon.</xref:System.Diagnostics.Process> Az StandardError adatfolyammal irányítják kezelése céljából, vagy ne jelenjen meg többé a hiba kimenetét a folyamat. Például a szöveg szűrése, másképp formázza, vagy kiírhatja a kimenetet a konzol és a kijelölt naplófájl.      > [!NOTE] > StandardError használatához be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>való `false`, és be kell <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>való `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ellenkező esetben a StandardError adatfolyamból való olvasás kivételt jelez.       Az átirányított StandardError adatfolyammal szinkron vagy aszinkron módon olvasható. Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a folyamat a hiba kimeneti adatfolyam.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>annak StandardError adatfolyammal ír, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process>       Ezzel szemben <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>indítása aszinkron olvasási művelet a az StandardError adatfolyammal.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Ez a módszer lehetővé teszi, hogy az adatfolyam-kimenetét a megadott eseménykezelőt, és azonnal visszaadja a hívónak, amely más feladatok is hajtható végre, amíg az eseménykezelő irányul, az adatfolyam-kimenetét.       Aszinkron olvasási műveleteknél a hívó az StandardError adatfolyammal és a gyermekfolyamat írása az adott adatfolyam olvasásakor közötti függőség vezethet. Ezek a függőségi holtpont feltételek eredményezhet. A hívó olvassa be az egyik gyermekfolyamata átirányított adatfolyamot, esetén a gyermek függ. A hívó megvárja a az olvasási művelet a gyermek a adatfolyamba ír, vagy az adatfolyam bezárása után. Amikor a gyermekfolyamat kevés az adat a töltse ki az átirányított adatfolyam ír, nem a szülő függ. A gyermekfolyamat megvárja a következő írási művelet a teljes adatfolyamból való beolvasása a szülő- vagy bezárja az adatfolyam. A holtpont feltétel ad eredményt, ha a hívó és gyermekfolyamat várjon egymástól elvégezni egy műveletet, és egyik sem lehet folytatni. A hívó és gyermekfolyamat közötti függőségek kiértékelésével elkerülheti a holtpont.       A következő C#-kódban, például szemlélteti a átirányított folyam olvasása, és várja meg a gyermek-folyamat kilép.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```A Kódpélda holtpontra elkerülhető meghívásával `p.StandardError.ReadToEnd` előtt `p.WaitForExit`. Holtpontra okozhat, ha a szülő feldolgozási hívások `p.WaitForExit` előtt `p.StandardError.ReadToEnd` és a gyermek folyamat ír az átirányított adatfolyamot bevitt. A szülő folyamat határozatlan ideig Várakozás volna a gyermekfolyamat való kilépéshez. A gyermek folyamat határozatlan ideig Várakozás volna a teljes StandardError adatfolyammal olvasni a szülő.       Probléma van, ha a standard kimenet és a standard hiba adatfolyamok olvassa el az összes szöveget. A következő C#-kódban, például mindkét adatfolyam egy olvasási műveletet hajtja végre.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```A Kódpélda elvégzésével aszinkron olvasási művelet a Ezzel elkerülheti a holtpontra a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardOutput%2A> Holtpontra eredménye, ha a szülő feldolgozási hívások `p.StandardOutput.ReadToEnd` követ `p.StandardError.ReadToEnd` és a gyermek folyamat ír a hibafolyam bevitt. A szülő folyamat lenne várakozást a gyermekfolyamat bezárásához a <xref:System.Diagnostics.Process.StandardOutput%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardOutput%2A> A gyermek folyamat határozatlan ideig Várakozás volna a teljes StandardError adatfolyammal olvasni a szülő.       Aszinkron olvasási műveleteknél használhatja ezeket a függőségeket és azok holtpont lehetséges elkerülése érdekében. Alternatív megoldásként úgy kerülheti el a holtpontra két szálak létrehozása és az egyes adatfolyamokkal külön szálban kimenetének olvasása során.      > [!NOTE] > Nem keverhetők a szinkron és aszinkron olvasási műveleteknél átirányított adatfolyamon. Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Például ne hajtsa végre <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>hívja <xref:System.IO.StreamReader.ReadLine%2A>a StandardError adatfolyammal, vagy fordítva.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Két különböző adatfolyamokba különböző módokban érheti el. Például hívása <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, majd hívja <xref:System.IO.StreamReader.ReadLine%2A>a az StandardError adatfolyammal.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "A <xref:System.IO.StreamReader>, amelyek segítségével olvassa el az alkalmazás a szabványos hibaadatfolyam.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a bemeneti alkalmazás írásához használt adatfolyam."
  remarks: "A <xref:System.Diagnostics.Process>beviteli olvashatók be a szabványos bemeneti folyama, általában a billentyűzet.</xref:System.Diagnostics.Process> A StandardInput adatfolyam irányítják programozott módon adhatja meg a bemeneti adatok. Például bevitel a billentyűzetről helyett megadhatja a kijelölt fájl tartalmát a szöveg vagy egy másik alkalmazás.      > [!NOTE] > StandardInput használatához be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>való `false`, és be kell <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>való `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ellenkező esetben a StandardInput írása adatfolyam kivételt jelez."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "A <xref:System.IO.StreamWriter>, amely használható a szabványos bemeneti folyama az alkalmazás írása.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A StandardInput az adatfolyam nem volt definiálva mert &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; értéke <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi az alkalmazás a szöveges kimenet olvasásához használt adatfolyam."
  remarks: "Ha egy <xref:System.Diagnostics.Process>szöveg ír a szabványos stream, hogy szöveg általában meg a konzolon.</xref:System.Diagnostics.Process> A StandardOutput adatfolyam irányítják kezelheti, vagy ne jelenjen meg többé a folyamat kimenetét. Például a szöveg szűrése, másképp formázza, vagy kiírhatja a kimenetet a konzol és a kijelölt naplófájl.      > [!NOTE] > StandardOutput használatához be kell <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>való `false`, és be kell <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>való `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ellenkező esetben a StandardOutput adatfolyamból való olvasás kivételt jelez.       Az átirányított StandardOutput adatfolyam szinkron vagy aszinkron módon olvasható. Például módszerek <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, és <xref:System.IO.StreamReader.ReadToEnd%2A>szinkron olvasási műveleteket végez a kimeneti adatfolyamba, a folyamat.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Ezek szinkron olvasási műveletek nem hajtja végre a társított amíg <xref:System.Diagnostics.Process>a StandardOutput adatfolyamhoz ír, vagy bezárja az adatfolyam.</xref:System.Diagnostics.Process>       Ezzel szemben <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>indítása aszinkron olvasási művelet a StandardOutput adatfolyamon.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Ez a módszer lehetővé teszi, hogy az adatfolyam-kimenetét a megadott eseménykezelőt, és azonnal visszaadja a hívónak, amely más feladatok is hajtható végre, amíg az eseménykezelő irányul, az adatfolyam-kimenetét.       Aszinkron olvasási műveleteknél a StandardOutput adatfolyamba és a gyermekfolyamat írása az adott adatfolyam olvasásakor a hívó közötti függőség vezethet. Ezek a függőségi holtpont feltételek eredményezhet. A hívó olvassa be az egyik gyermekfolyamata átirányított adatfolyamot, esetén a gyermek függ. A hívó megvárja a az olvasási művelet a gyermek a adatfolyamba ír, vagy az adatfolyam bezárása után. Amikor a gyermekfolyamat kevés az adat a töltse ki az átirányított adatfolyam ír, nem a szülő függ. A gyermekfolyamat megvárja a következő írási művelet a teljes adatfolyamból való beolvasása a szülő- vagy bezárja az adatfolyam. A holtpont feltétel ad eredményt, ha a hívó és gyermekfolyamat várjon egymástól elvégezni egy műveletet, és egyik sem lehet folytatni. A hívó és gyermekfolyamat közötti függőségek kiértékelésével elkerülheti a holtpont.       A következő C#-kódban, például szemlélteti a átirányított folyam olvasása, és várja meg a gyermek-folyamat kilép.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```A Kódpélda holtpontra elkerülhető meghívásával `p.StandardOutput.ReadToEnd` előtt `p.WaitForExit`. Holtpontra okozhat, ha a szülő feldolgozási hívások `p.WaitForExit` előtt `p.StandardOutput.ReadToEnd` és a gyermek folyamat ír az átirányított adatfolyamot bevitt. A szülő folyamat határozatlan ideig Várakozás volna a gyermekfolyamat való kilépéshez. Az alárendelt folyamat határozatlan ideig Várakozás volna a szülő a a teljes StandardOutput adatfolyamának olvasására.       Probléma van, ha a standard kimenet és a standard hiba adatfolyamok olvassa el az összes szöveget. A következő C#-kódban, például mindkét adatfolyam egy olvasási műveletet hajtja végre.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```A kód például a holtpontra elkerülhető a StandardOutput adatfolyam aszinkron olvasási műveletek elvégzésével. Holtpontra eredménye, ha a szülő feldolgozási hívások `p.StandardOutput.ReadToEnd` követ `p.StandardError.ReadToEnd` és a gyermek folyamat ír a hibafolyam bevitt. A szülő folyamat határozatlan ideig Várakozás volna a gyermekfolyamat a StandardOutput adatfolyam bezárása. A gyermekfolyamat határozatlan vár volna olvasni a teljes szülő <xref:System.Diagnostics.Process.StandardError%2A>adatfolyam.</xref:System.Diagnostics.Process.StandardError%2A>       Aszinkron olvasási műveleteknél használhatja ezeket a függőségeket és azok holtpont lehetséges elkerülése érdekében. Alternatív megoldásként úgy kerülheti el a holtpontra két szálak létrehozása és az egyes adatfolyamokkal külön szálban kimenetének olvasása során.      > [!NOTE] > Nem keverhetők a szinkron és aszinkron olvasási műveleteknél átirányított adatfolyamon. Egyszer átirányított adatfolyamot egy <xref:System.Diagnostics.Process>már meg van nyitva aszinkron vagy szinkron módban, az összes további olvasási műveleteket végez, hogy az adatfolyam a azonos módban kell lennie.</xref:System.Diagnostics.Process> Például ne hajtsa végre <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>hívja <xref:System.IO.StreamReader.ReadLine%2A>a StandardOutput adatfolyamon, vagy fordítva.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Két különböző adatfolyamokba különböző módokban érheti el. Például hívása <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, majd hívja <xref:System.IO.StreamReader.ReadLine%2A>a a <xref:System.Diagnostics.Process.StandardError%2A>adatfolyamot.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "A <xref:System.IO.StreamReader>, amelyek segítségével olvassa el az alkalmazás a szabványos kimeneti adatfolyam.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A folyamat által megadott erőforrás indításakor (vagy a rendszer újból felhasználja) a <xref:System.Diagnostics.Process.StartInfo*>az e tulajdonság <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő és társítja azt az összetevőt.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a folyamat erőforrás indította; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha nincs új folyamat-erőforrás (például ha egy létező folyamat újra) elindult."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fájlnév nem volt megadva a a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő <> </> *>.       – vagy – a &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; tagja a <> </> *> tulajdonság <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> közben &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, vagy &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; van <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A folyamat erőforrás folyamat kezdési adatokat (például a fájl nevét a folyamat elindításához) tartalmazó paraméter által megadott elindul, és hozzárendeli az erőforrás egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "A <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> , amely az ismerteti, amellyel elindíthatja a folyamatot, beleértve a fájlnevet és a parancssori argumentumokat."
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> folyamat erőforrás társított vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha folyamat erőforrást el van indítva. Vegye figyelembe, hogy ugyanazt a folyamatot példánya már fut mellett elindított új folyamat független a többi. Emellett a Start térhetnek vissza egy null értékű folyamatot a <xref:System.Diagnostics.Process.HasExited*>tulajdonsága már <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Ebben az esetben a elindított folyamat lehet aktiválni magát meglévő példányát és majd kilépett."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A fájlnév nem volt megadva a a <code> startInfo </code> paraméter <> </> *> tulajdonság.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       – vagy – a <> </> *> tulajdonsága a <code> startInfo </code> paraméter <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> és a <> </> *> tulajdonság értéke nem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> vagy üres, vagy a <> </> *> tulajdonság értéke nem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A megadott fájl a <code> startInfo </code> paraméter <xref:System.Diagnostics.ProcessStartInfo.FileName*>tulajdonság nem található.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor.       – vagy – a argumentum hossza és a folyamat teljes elérési útja hossza meghaladja a 2080. Ehhez a kivételhez tartozó hibaüzenet a következők egyike lehet: &quot;az adatterületen, a rendszer hívásnak átadott mérete túl kicsi.&quot; vagy a &quot;Hozzáférés megtagadva.&quot;"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A folyamat erőforrás elindul egy dokumentum vagy alkalmazás-fájl nevének megadásával, és hozzárendeli az erőforrás egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "A dokumentum vagy alkalmazás fájl futtatásához a folyamat nevét."
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> folyamat erőforrás társított vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha folyamat erőforrást el van indítva. Vegye figyelembe, hogy ugyanazt a folyamatot példánya már fut mellett elindított új folyamat független a többi. Emellett a Start térhetnek vissza egy null értékű folyamatot a <xref:System.Diagnostics.Process.HasExited*>tulajdonsága már <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Ebben az esetben a elindított folyamat lehet aktiválni magát meglévő példányát és majd kilépett."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A PATH környezeti változóba idézőjelet tartalmazó karakterlánccal rendelkezik."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy folyamat erőforrás elindul az alkalmazás nevét és a parancssori argumentumok készlete megadásával, és az erőforrás társít egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Egy alkalmazás fájl futtatásához a folyamat nevét."
    - id: arguments
      type: System.String
      description: "Parancssori argumentumokat a folyamat indításakor."
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> folyamat erőforrás társított vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha folyamat erőforrást el van indítva. Vegye figyelembe, hogy ugyanazt a folyamatot példánya már fut mellett elindított új folyamat független a többi. Emellett a Start térhetnek vissza egy null értékű folyamatot a <xref:System.Diagnostics.Process.HasExited*>tulajdonsága már <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Ebben az esetben a elindított folyamat lehet aktiválni magát meglévő példányát és majd kilépett."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor.       – vagy – a argumentum hossza és a folyamat teljes elérési útja hossza meghaladja a 2080. Ehhez a kivételhez tartozó hibaüzenet a következők egyike lehet: &quot;az adatterületen, a rendszer hívásnak átadott mérete túl kicsi.&quot; vagy a &quot;Hozzáférés megtagadva.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A PATH környezeti változóba idézőjelet tartalmazó karakterlánccal rendelkezik."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Egy folyamat erőforrás elindul az alkalmazás nevét, a felhasználónév, jelszó és tartomány megadásával, és hozzárendeli az erőforrás egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő."
  remarks: "Ez a túlterhelés használatával hozzon létre egy új folyamatok és az elsődleges szálak fájl nevét, felhasználónév, jelszó és tartomány megadásával. Az új folyamat majd futtatja a megadott végrehajtható fájl a megadott hitelesítő adatok (a felhasználó, a tartományt és a jelszót) biztonsági környezetében.      > [!NOTE] > Egy távoli meghajtón található a végrehajtható fájl, amikor meg kell adnia a hálózati megosztás egy egységes erőforrás-azonosító (URI), nem csatolt meghajtóbetűjel használatával.      > [!NOTE] > Ha a cím elindítani a végrehajtható fájl URL-címet, a folyamat nem indult el és `null` adja vissza.       Ez a túlterhelés lehetővé teszi, hogy a folyamat elindításához először létrehozunk egy új nélkül <xref:System.Diagnostics.Process>példány.</xref:System.Diagnostics.Process> A Túlterhelés egy új létrehozásának explicit lépésein helyett <xref:System.Diagnostics.Process>példány beállítása a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, és <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>tulajdonságainak a <xref:System.Diagnostics.Process.StartInfo%2A>tulajdonság és hívása <xref:System.Diagnostics.Process.Start%2A>a a <xref:System.Diagnostics.Process>példány.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Ehhez hasonlóan az azonos módon, hogy a **futtassa** párbeszédpanel elfogadhatja vagy a .exe kiterjesztésű nélkül végrehajtható fájl neve, az .exe kiterjesztésű nem kötelező megadni a a `fileName` paraméter. Például beállíthatja a `fileName` &quot;Notepad.exe&quot; vagy &quot;Jegyzettömb&quot; paraméter. Ha a `fileName` paraméter jelöli egy végrehajtható fájl, a `arguments` paraméter jelölheti a fájl megfelelően kell eljárnia, például a szövegfájlba `Notepad.exe myfile.txt`.      > [!NOTE] > A fájl nevét kell meghatároznia a végrehajtható fájl a <xref:System.Diagnostics.Process.Start%2A>rendelkező túlterhelések `userName`, `password`, és `domain` paraméterek.</xref:System.Diagnostics.Process.Start%2A>       Amikor használhatja <xref:System.Diagnostics.Process.Start%2A>a folyamat elindításához szükség lehet zárja be, vagy a rendszererőforrások veszhetnek.</xref:System.Diagnostics.Process.Start%2A> Zárja be a folyamatok vagy <xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Ellenőrizheti, hogy a folyamat már be lett zárva használatával a <xref:System.Diagnostics.Process.HasExited%2A>tulajdonság.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Egy alkalmazás fájl futtatásához a folyamat nevét."
    - id: userName
      type: System.String
      description: "A felhasználó nevét, amikor a folyamat elindítása."
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref> , amely tartalmazza a folyamat indításakor használandó jelszó."
    - id: domain
      type: System.String
      description: "A tartomány, a folyamat indításakor használja."
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> folyamat erőforrás társított vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha folyamat erőforrást el van indítva. Vegye figyelembe, hogy ugyanazt a folyamatot példánya már fut mellett elindított új folyamat független a többi. Emellett a Start térhetnek vissza egy null értékű folyamatot a <xref:System.Diagnostics.Process.HasExited*>tulajdonsága már <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Ebben az esetben a elindított folyamat lehet aktiválni magát meglévő példányát és majd kilépett."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincs fájlnév lett megadva."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A folyamat erőforrás egy alkalmazás, parancssori argumentumok készlete, a felhasználónév, jelszó és tartomány nevét megadó és megkeresi az erőforrás társít egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő."
  remarks: "Ez a túlterhelés használatával hozzon létre egy új folyamatok és az elsődleges szálak fájl nevét, parancssori argumentumokat, felhasználónév, jelszó és tartomány megadásával. Az új folyamat majd futtatja a megadott végrehajtható fájl a megadott hitelesítő adatok (a felhasználó, a tartományt és a jelszót) biztonsági környezetében.      > [!NOTE] > Egy távoli meghajtón található a végrehajtható fájl, amikor meg kell adnia a hálózati megosztás egy egységes erőforrás-azonosító (URI), nem csatolt meghajtóbetűjel használatával.      > [!NOTE] > Ha a cím elindítani a végrehajtható fájl URL-címet, a folyamat nem indult el és `null` adja vissza.       Ez a túlterhelés lehetővé teszi, hogy a folyamat elindításához először létrehozunk egy új nélkül <xref:System.Diagnostics.Process>példány.</xref:System.Diagnostics.Process> A Túlterhelés egy új létrehozásának explicit lépésein helyett <xref:System.Diagnostics.Process>példány beállítása a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, és <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>tulajdonságainak a <xref:System.Diagnostics.Process.StartInfo%2A>tulajdonság és hívása <xref:System.Diagnostics.Process.Start%2A>a a <xref:System.Diagnostics.Process>példány.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Ehhez hasonlóan az azonos módon, hogy a **futtassa** párbeszédpanel elfogadhatja vagy a .exe kiterjesztésű nélkül végrehajtható fájl neve, az .exe kiterjesztésű nem kötelező megadni a a `fileName` paraméter. Például beállíthatja a `fileName` &quot;Notepad.exe&quot; vagy &quot;Jegyzettömb&quot; paraméter. Ha a `fileName` paraméter jelöli egy végrehajtható fájl, a `arguments` paraméter jelölheti a fájl megfelelően kell eljárnia, például a szövegfájlba `Notepad.exe myfile.txt`.      > [!NOTE] > A fájl nevét kell meghatároznia a végrehajtható fájl a <xref:System.Diagnostics.Process.Start%2A>rendelkező túlterhelések `userName`, `password`, és `domain` paraméterek.</xref:System.Diagnostics.Process.Start%2A>       Amikor használhatja <xref:System.Diagnostics.Process.Start%2A>a folyamat elindításához szükség lehet zárja be, vagy a rendszererőforrások veszhetnek.</xref:System.Diagnostics.Process.Start%2A> Zárja be a folyamatok vagy <xref:System.Diagnostics.Process.CloseMainWindow%2A> <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Ellenőrizheti, hogy a folyamat már be lett zárva használatával a <xref:System.Diagnostics.Process.HasExited%2A>tulajdonság.</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Egy alkalmazás fájl futtatásához a folyamat nevét."
    - id: arguments
      type: System.String
      description: "Parancssori argumentumokat a folyamat indításakor."
    - id: userName
      type: System.String
      description: "A felhasználó nevét, amikor a folyamat elindítása."
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref> , amely tartalmazza a folyamat indításakor használandó jelszó."
    - id: domain
      type: System.String
      description: "A tartomány, a folyamat indításakor használja."
    return:
      type: System.Diagnostics.Process
      description: "Egy új <xref href=&quot;System.Diagnostics.Process&quot;> </xref> folyamat erőforrás társított vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha folyamat erőforrást el van indítva. Vegye figyelembe, hogy ugyanazt a folyamatot példánya már fut mellett elindított új folyamat független a többi. Emellett a Start térhetnek vissza egy null értékű folyamatot a <xref:System.Diagnostics.Process.HasExited*>tulajdonsága már <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Ebben az esetben a elindított folyamat lehet aktiválni magát meglévő példányát és majd kilépett."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nincs fájlnév lett megadva."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a fájl megnyitásakor.       – vagy – a argumentum hossza és a kapcsolódó fájl teljes elérési útja hossza meghaladja a 2080. Ehhez a kivételhez tartozó hibaüzenet a következők egyike lehet: &quot;az adatterületen, a rendszer hívásnak átadott mérete túl kicsi.&quot; vagy a &quot;Hozzáférés megtagadva.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A process objektum már el lett távolítva."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja, hogy a tulajdonságok a <xref:System.Diagnostics.Process.Start*>metódusában a <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo a folyamat elindításához használt paraméterek készletét jelöli. Ha <xref:System.Diagnostics.Process.Start%2A>van neve, a StartInfo használatával adja meg a folyamat elindításához.</xref:System.Diagnostics.Process.Start%2A> A csak a szükséges StartInfo tag beállítása a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Egy folyamat elindítása megadásával a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság hasonlít írja be az adatokat a **futtassa** párbeszédpanel a Windows **Start** menü.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Ezért a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság nem kell meghatároznia egy végrehajtható fájl.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Lehet, hogy minden fájl típusú, amelynek a bővítmény társítva a rendszerre telepített egy alkalmazással. Ha például a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.txt kiterjesztésű rendelkezhet, ha szövegfájlok társítva van egy szerkesztőt, például a Jegyzettömbben, vagy azt, hogy egy .doc Ha associated.doc fájlt egy szövegszerkesztő eszközzel, például Microsoft Wordből.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Ehhez hasonlóan az azonos módon, hogy a **futtassa** párbeszédpanel elfogadhatja vagy a .exe kiterjesztésű nélkül végrehajtható fájl neve, az .exe kiterjesztésű nem kötelező megadni a a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tag.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Például beállíthatja a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>&quot;Notepad.exe&quot; vagy &quot;Jegyzettömb&quot; tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Olyan ClickOnce alkalmazásokhoz megkezdheti úgy, hogy a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság a helyre (például egy webcímet), ahonnan eredetileg az alkalmazást telepítette.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A ClickOnce alkalmazáshoz nem indulnak el a merevlemez-meghajtón telepítés helyén megadásával.       Ha a fájl neve szerint elindíthatóak fájl, például egy .doc fájl megadhat olyan műveleteket, adja meg a fájlt a végrehajtandó műveletet. Állítsa be például a <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>a &quot;Print&quot; a a .doc kiterjesztésű fájlra vonatkozó.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> A megadott fájl nevét a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság nem kell kiterjesztéssel rendelkeznek, ha manuálisan adja meg egy értéket a <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>tulajdonság.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Azonban ha használja a <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>tulajdonság határozza meg, milyen műveletek érhetők el, meg kell adni a bővítményt.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Meghívja a idejével StartInfo tulajdonságban megadott paraméterek módosíthatja a <xref:System.Diagnostics.Process.Start%2A>folyamat metódus.</xref:System.Diagnostics.Process.Start%2A> A folyamat megkezdése után StartInfo értékeinek módosítása nem érinti, és indítsa újra a társított folyamat. Ha meghívja a a <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>metódust a <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>és <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>Tulajdonságok beállítása, a nem felügyelt `CreateProcessWithLogonW` függvény hívása esetén, amely elindítja a folyamatot új ablak még akkor is, ha a <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>tulajdonság értéke `true` vagy a <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>tulajdonság értéke <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Ha nem használja a <xref:System.Diagnostics.Process.Start%2A>metódus a folyamat elindításához a StartInfo tulajdonság nem tükrözi a folyamat elindításához használt paraméterek.</xref:System.Diagnostics.Process.Start%2A> Ha például <xref:System.Diagnostics.Process.GetProcesses%2A>beolvasni a számítógépen, a StartInfo tulajdonság az egyes futó folyamatok tömbje <xref:System.Diagnostics.Process>nem tartalmaz az eredeti fájlnevet vagy a folyamat elindításához használt argumentumok.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Amikor a folyamat elindul, a fájlnév pedig a fájlt, amely feltölti az (csak olvasható) <xref:System.Diagnostics.Process.MainModule%2A>tulajdonság.</xref:System.Diagnostics.Process.MainModule%2A> Ha azt szeretné, hogy a folyamat társítva, miután megkezdődött a folyamat végrehajtható fájl kéri le, használja a <xref:System.Diagnostics.Process.MainModule%2A>tulajdonság.</xref:System.Diagnostics.Process.MainModule%2A> Ha be szeretné állítani a végrehajtható fájl egy <xref:System.Diagnostics.Process>példányt, amely a társított folyamat nem lett elindítva, akkor a StartInfo tulajdonság <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tag.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Mivel a StartInfo tulajdonság tagjai számára átadott argumentumok a <xref:System.Diagnostics.Process.Start%2A>módosítása folyamatban módszer a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>tulajdonság a társított folyamat megkezdése után nem állítja vissza a <xref:System.Diagnostics.Process.MainModule%2A>tulajdonság.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Ezek a tulajdonságok csak a társított folyamat inicializálása szolgálnak."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "A <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> , amely jelzi, hogy a folyamat elindításához használt adatok. Ezek az argumentumok a végrehajtható fájl vagy a folyamat elindításához használt dokumentum neve is."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Az érték, amely meghatározza a StartInfo <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi az időt, amely a társított folyamat elindítása."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Egy objektum, amely azt jelzi, ha a folyamat elindítása. Kivételt vált ki, ha a folyamat nem működik."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a StartTime tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamat már kilépett.       – vagy – a folyamat nem lett elindítva."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Hiba történt a Windows függvény hívásában."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi vagy beállítja a folyamat kilépési esemény miatt kiadott eseménykezelő-hívások átadásra való előkészítéséhez használt objektum."
  remarks: "Ha <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>van `null`, módszereket, amelyek kezelik a <xref:System.Diagnostics.Process.Exited>esemény nevezzük, a rendszer szálkészlet a szálban.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> A rendszerkészletek szál kapcsolatos további információkért lásd: <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Ha a <xref:System.Diagnostics.Process.Exited>eseményt kezeli visual Windows Forms összetevő, például egy <xref:System.Windows.Forms.Button>, a rendszer szálkészlet általi eléréséhez szükséges az összetevő nem működik, vagy kivétel eredményezhet.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Windows Forms komponens, amely azt eredményezi, a metódusok kezelése SynchronizingObject beállításával elkerüléséhez a <xref:System.Diagnostics.Process.Exited>esemény-összetevő létrehozásának időpontja elemmel azonos szálban kell meghívni.</xref:System.Diagnostics.Process.Exited>       Ha a <xref:System.Diagnostics.Process>belül használt [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Windows Forms-tervezőben, SynchronizingObject értéke automatikusan a <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> tartalmazó vezérlő</xref:System.Diagnostics.Process> Például, ha egy <xref:System.Diagnostics.Process>tervezőjét a `Form1` (amely örökli <xref:System.Windows.Forms.Form>) SynchronizingObject tulajdonságának <xref:System.Diagnostics.Process>példánya értéke `Form1`: [!code-cpp [Process_SynchronizingObject&#2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&#2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&#2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] általában a tulajdonság értéke, ha az összetevő vezérlő vagy a képernyőn belül helyezkedik el, mivel ezek az összetevők vannak kötve egy bizonyos szálhoz.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "A <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> következtében kiadott eseménykezelő-hívások átadásra való előkészítéséhez használt egy <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> folyamat esemény."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamatban futó szálak készletét."
  remarks: "A szál végrehajtja a kód egy folyamatban. Minden folyamat egy szállal, az elsődleges szál elindult. Bármely szálon további szálak hozhat létre. A folyamat szálai megosztás a folyamat címterében.       Használjon <xref:System.Diagnostics.ProcessThread>beolvasni a jelenlegi folyamathoz tartozó összes szálak.</xref:System.Diagnostics.ProcessThread> Az elsődleges szál jelenleg nem feltétlenül nulla index a tömb."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Típusú tömb <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> a társított folyamatban aktuálisan futó operációs rendszert képviselő szálait."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "A folyamat nem rendelkezik egy <xref:System.Diagnostics.Process.Id*>, vagy egyetlen folyamat sem társítva van a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> példány.</xref:System.Diagnostics.Process.Id*>       – vagy – a társított folyamat már kilépett."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me); Állítsa be &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; való <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Windows 98, és folytassa a tulajdonság eléréséhez"
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formázza a folyamat neve karakterláncként, ha van ilyen szülőtípus összetevő együtt."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "A <> </> *>, az alap összetevő együtt <> </> *> ad vissza értéket."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A ToString Windows 98 nem támogatott."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a teljes processzoridő folyamat."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>, amely azt jelzi, hogy a társított folyamat a CPU-t használó fordított idő.</xref:System.TimeSpan> Ez az érték összegét a <> </> *> és a <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a TotalProcessorTime tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a felhasználó processzoridő folyamat."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>, amely azt jelzi, hogy a társított folyamat belül a folyamat (nem az operációs rendszer magjában) alkalmazás része kódfuttatásra fordított idő.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Próbál hozzáférni a UserProcessorTime tulajdonsága egy távoli számítógépen futó folyamat. Ez a tulajdonság csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a folyamat a virtuális memória mérete bájtban."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Virtuális memória mérete, a társított folyamat által kért mennyisége."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "A társított folyamat lefoglalt bájtok beolvasása a virtuális memória."
  remarks: "Ez a tulajdonság által visszaadott értéket bájtban a folyamat által felhasznált virtuális memória jelenlegi mérete jelöli. Az operációs rendszer leképezi a használt virtuális címtartomány az összes folyamat vagy lapok betöltése a fizikai memória, vagy a virtuális memória lapozófájlméretének lemezen tárolt lapra.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **virtuális bájt** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Virtuális memória mérete, a társított folyamat számára lefoglalt mennyisége."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Arra utasítja a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő határozatlan ideig vár a társított folyamat kilépését."
  remarks: "WaitForExit lehetővé teszi, hogy az aktuális szál, várjon, amíg a társított folyamat véget nem ér.  Az összes többi módszert nevezik folyamat után kell meghívni. Az aktuális szál elkerülni, használja a <xref:System.Diagnostics.Process.Exited>esemény.</xref:System.Diagnostics.Process.Exited>       Ez a módszer arra utasítja a <xref:System.Diagnostics.Process>Várakozás egy végtelen ideig való kilépéshez a folyamat, és az esemény kezelők számára az összetevőt.</xref:System.Diagnostics.Process> Emiatt az alkalmazás nem válaszol. Például, ha meghívja a <xref:System.Diagnostics.Process.CloseMainWindow%2A>keres egy folyamatot, amely a felhasználói felülete, a társított folyamat leáll az operációs rendszer a kérelem előfordulhat, hogy nem lehet kezelni, ha a folyamat soha nem adja meg az üzenetkezelő ciklus ír.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > A a [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] és korábbi verziókban a WaitForExit túlterhelési várt <xref:System.Int32.MaxValue>ezredmásodperc (körülbelül 24 napos), nem határozatlan ideig.</xref:System.Int32.MaxValue> Is, korábbi verziók volt nem várja meg a eseménykezelők való kilépéshez, ha a teljes <xref:System.Int32.MaxValue>ideje elérte.</xref:System.Int32.MaxValue>       Ez a túlterhelés biztosítja, hogy minden feldolgozás befejezése után, beleértve a szabványos kimenet aszinkron eseményeket. Ez a túlterhelés hívása után kell használnia a <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>túlterhelés, ha szabványos kimenet aszinkron Eseményleírók átirányítva.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Amikor a társított folyamat kilépésekor (Ez azt jelenti, hogy le, amikor azt által az operációs rendszer egy normál és rendellenes lezárást keresztül), a rendszer a folyamat felügyeleti adatait tárolja, és adja vissza, amely WaitForExit meghívta volna összetevőnek. A <xref:System.Diagnostics.Process>összetevő ezután hozzáférhetnek a információkat, például a <xref:System.Diagnostics.Process.ExitTime%2A>, segítségével a <xref:System.Diagnostics.Process.Handle%2A>amelyekből kiléptek folyamatához.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       A társított folyamat már kilépett, mert a <xref:System.Diagnostics.Process.Handle%2A>tulajdonság az összetevő már nem mutat, meglévő folyamat erőforrás.</xref:System.Diagnostics.Process.Handle%2A> Ehelyett a leíró csak a folyamat erőforrás az operációs rendszer adatainak eléréséhez használható. A rendszer kezeli, amelyekből kiléptek folyamatokra vonatkozik, amelyek nem által kiadott tudomást <xref:System.Diagnostics.Process>összetevők, így tartja a <xref:System.Diagnostics.Process.ExitTime%2A>és <xref:System.Diagnostics.Process.Handle%2A>adatokat a memóriába, amíg a <xref:System.Diagnostics.Process>összetevő kifejezetten az erőforrások területet szabadít.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Emiatt bármikor meghívja a <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process>példány, a hívást, <xref:System.Diagnostics.Process.Close%2A>Amikor a társított folyamat megszakítása rendelkezik, és már nem kell az összes felügyeleti információ azt.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>szabadít fel a amelyekből kiléptek folyamat számára fenntartott memória mérete.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nem sikerült a várakozási beállítás elérése."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Egyetlen folyamat sem <> </> *> van beállítva, és egy <> </> *>, amelyből a <xref:System.Diagnostics.Process.Id*>tulajdonság is meg lehet határozni nem létezik.</xref:System.Diagnostics.Process.Id*>       - vagy - nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum.       – vagy – próbál WaitForExit kérjen egy távoli számítógépen futó folyamat. Ez a metódus csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Arra utasítja a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő várja meg a megadott számú a társított folyamat kilépését milliszekundumban megadva."
  remarks: "WaitForExit lehetővé teszi, hogy az aktuális szál, várjon, amíg a társított folyamat véget nem ér. Az összes többi módszert nevezik folyamat után kell meghívni. Az aktuális szál elkerülni, használja a <xref:System.Diagnostics.Process.Exited>esemény.</xref:System.Diagnostics.Process.Exited>       Ez a módszer arra utasítja a <xref:System.Diagnostics.Process>összetevő várakozási időt a folyamat bezárásához véges mennyiségű.</xref:System.Diagnostics.Process> Ha a társított folyamat nem létezik a időszakának a végét által, mert a rendszer megtagadja a kérelmet leáll, `false` a eljárást küld vissza. Megadhat egy negatív szám (<xref:System.Threading.Timeout.Infinite>) a `milliseconds`, és WaitForExit működik ugyanaz, mint a <xref:System.Diagnostics.Process.WaitForExit>túlterhelés.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Ha a metódus átadni 0 (nulla), adja vissza, `true` csak akkor, ha már kilépett a folyamat; ellenkező esetben azt azonnal visszaadja `false`.      > [!NOTE] > A a [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] és korábbi verzióiban, ha `milliseconds` -1, a túlterhelési várt WaitForExit lett <xref:System.Int32.MaxValue>ezredmásodperc (körülbelül 24 napos), nem határozatlan ideig.</xref:System.Int32.MaxValue>       Standard kimenet aszinkron Eseményleírók átirányítva, esetén lehetséges, hogy a kimeneti feldolgozása nem befejeződött-e arról, ha ez a módszer adja vissza. Győződjön meg arról, hogy befejeződött-e a aszinkron eseménykezelésnek, hívja meg a <xref:System.Diagnostics.Process.WaitForExit>fogadását követően nem paraméterrel rendelkező túlterhelést egy `true` a ez túlterhelés.</xref:System.Diagnostics.Process.WaitForExit> Annak biztosítására, hogy a <xref:System.Diagnostics.Process.Exited>esemény megfelelően kezeli a Windows Forms-alkalmazásokhoz, és állítsa a <xref:System.Diagnostics.Process.SynchronizingObject%2A>tulajdonság.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Ha a társított folyamat kilépése (állítja le az operációs rendszer egy normál és rendellenes lezárást keresztül), a rendszer a folyamat felügyeleti adatait tárolja, és visszaadja az összetevő, amely WaitForExit meghívta volna. A <xref:System.Diagnostics.Process>összetevő ezután hozzáférhetnek a információkat, például a <xref:System.Diagnostics.Process.ExitTime%2A>, segítségével a <xref:System.Diagnostics.Process.Handle%2A>amelyekből kiléptek folyamatához.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       A társított folyamat már kilépett, mert a <xref:System.Diagnostics.Process.Handle%2A>tulajdonság az összetevő már nem mutat, meglévő folyamat erőforrás.</xref:System.Diagnostics.Process.Handle%2A> Ehelyett a leíró csak a folyamat erőforrás az operációs rendszer adatainak eléréséhez használható. A rendszer kezeli, amelyekből kiléptek folyamatokra vonatkozik, amelyek nem által kiadott tudomást <xref:System.Diagnostics.Process>összetevők, így tartja a <xref:System.Diagnostics.Process.ExitTime%2A>és <xref:System.Diagnostics.Process.Handle%2A>adatokat a memóriába, amíg a <xref:System.Diagnostics.Process>összetevő kifejezetten az erőforrások területet szabadít.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Emiatt bármikor meghívja a <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process>példány, a hívást, <xref:System.Diagnostics.Process.Close%2A>Amikor a társított folyamat megszakítása rendelkezik, és már nem kell az összes felügyeleti információ azt.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>szabadít fel a amelyekből kiléptek folyamat számára fenntartott memória mérete.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Az időtartam, a várakozási idő milliszekundumban megadva, a társított folyamat kilépését. A maximális érték a 32 bites egész szám, amely képviseli az operációs rendszer végtelen legnagyobb lehetséges értéke."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a társított folyamat kilépett a; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nem sikerült a várakozási beállítás elérése."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Egyetlen folyamat sem <> </> *> van beállítva, és egy <> </> *>, amelyből a <xref:System.Diagnostics.Process.Id*>tulajdonság is meg lehet határozni nem létezik.</xref:System.Diagnostics.Process.Id*>       - vagy - nem a társított folyamat <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum.       – vagy – próbál WaitForExit kérjen egy távoli számítógépen futó folyamat. Ez a metódus csak a helyi számítógépen futó folyamatok érhető el."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hatására a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő határozatlan ideig vár a társított folyamat írja be az inaktív állapotú. Ez a túlterhelés csak egy felhasználói felületet, és ezért üzenetkezelő ciklus folyamatok vonatkozik."
  remarks: "Várjon, amíg az üzenetkezelő ciklus az üresjárati állapotot adott vissza az alkalmazás feldolgozása WaitForInputIdle végrehajtása használja. A felhasználói felületen a folyamat végrehajtásakor a üzenetkezelő ciklus minden alkalommal, amikor egy Windows üzenetet küld a folyamat által az operációs rendszer hajtja végre. A folyamat majd visszatér az üzenetkezelő ciklus. A folyamat, különállónak üresjárati állapotban amikor belül üzenetkezelő ciklus üzenetek vár. Ez az állapot akkor hasznos, például ha az alkalmazás várja meg a kezdési folyamat hozta létre a fő ablakot, mielőtt az alkalmazás az ezt az ablakot.       Ha a folyamatnak nincs üzenetkezelő ciklus, WaitForInputIdle végrehajtása okoz-e egy <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A WaitForInputIdle végrehajtása túlterhelési arra utasítja a <xref:System.Diagnostics.Process>összetevő válik az üzenetkezelő ciklus az üresjárati folyamat határozatlan ideig vár.</xref:System.Diagnostics.Process> Ezeket az utasításokat okozhat az alkalmazás nem válaszol. Például, ha a folyamat mindig írni lépjen ki az üzenetkezelő ciklus azonnal, mint a kódrészlet `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a társított folyamat elérte az inaktív állapotú."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamatnak nincs grafikus felület.       – vagy – ismeretlen hiba történt. A folyamat nem adja meg az inaktív állapotú.       – vagy – a folyamat már kilépett.       – vagy – egyetlen folyamat sem tartozik a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hatására a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> összetevő várakozási ideje (MS) írja be az inaktív állapotú a társított folyamat a megadott szám. Ez a túlterhelés csak egy felhasználói felületet, és ezért üzenetkezelő ciklus folyamatok vonatkozik."
  remarks: "Várjon, amíg az üzenetkezelő ciklus az üresjárati állapotot adott vissza az alkalmazás feldolgozása WaitForInputIdle végrehajtása használja. A felhasználói felületen a folyamat végrehajtásakor a üzenetkezelő ciklus minden alkalommal, amikor egy Windows üzenetet küld a folyamat által az operációs rendszer hajtja végre. A folyamat majd visszatér az üzenetkezelő ciklus. A folyamat, különállónak üresjárati állapotban amikor belül üzenetkezelő ciklus üzenetek vár. Ez az állapot akkor hasznos, például ha az alkalmazás várja meg a kezdési folyamat hozta létre a fő ablakot, mielőtt az alkalmazás az ezt az ablakot.       Ha a folyamatnak nincs üzenetkezelő ciklus, WaitForInputIdle végrehajtása okoz-e egy <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A WaitForInputIdle végrehajtása túlterhelési arra utasítja a <xref:System.Diagnostics.Process>összetevő várakozási időt a folyamat az üzenetkezelő ciklus az üresjáratba hardverkonfigurációtól.</xref:System.Diagnostics.Process> Ha a társított folyamat nem vált üresjárati által a időszakának a végét a hurok van feldolgozása még tart üzenetek, mert `false` a eljárást küld vissza.       Események kezelésére vonatkozó további információkért lásd: [események](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Az 1 érték <xref:System.Int32>, amely ennyi idő, ezredmásodpercben, várja meg a társított folyamat üresjáratba.</xref:System.Int32> A 0 érték meghatározza egy azonnali vissza, és a -1 érték végtelen várakozást határozza meg."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a társított folyamat elérte az inaktív állapotú; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A folyamatnak nincs grafikus felület.       – vagy – ismeretlen hiba történt. A folyamat nem adja meg az inaktív állapotú.       – vagy – a folyamat már kilépett.       – vagy – egyetlen folyamat sem tartozik a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektum."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a társított folyamat fizikai memória használata, bájtban."
  remarks: "A tulajdonság érték azt jelenti, hogy működik-e a folyamat, bájtban által használt memória aktuális méretét. Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatok tartalmazzák a folyamat végrehajtása során, beleértve a folyamatmodulok és a könyvtár összes utasítást tartalmazó összes lapot."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "A teljes fizikai memória mennyisége a társított folyamat által használt, bájtban."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lekérdezi a kiosztható fizikai memória (bájt) a társított folyamat számára lefoglalt."
  remarks: "A tulajdonság érték azt jelenti, hogy működik-e a folyamat, bájtban által használt memória aktuális méretét. Egy adott folyamat munkakészlete a folyamat jelenleg látható memórialapok készlete a fizikai memóriában. Az adott lapok rezidens és a laphibák elindítása nélkül az alkalmazás elérhetővé válnak.       A működő megosztott, mind a személyes adatokat is tartalmaz. A megosztott adatok közé tartoznak az utasításokat, amely a folyamat végrehajtja, beleértve az utasításokat a folyamatmodulok és a rendszer könyvtárakban tartalmazó összes lapot.       Ez a tulajdonság azokon a számítógépeken 32 bites processzorokat vagy 64 bites processzorokat memóriahasználata figyelésére használható. A tulajdonság értéke megegyezik a **munkakészlet** teljesítményszámláló a folyamat."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Fizikai memória mérete, a társított folyamat számára lefoglalt mennyisége."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A platform az Windows 98 vagy Windows Me (Windows Me), amely nem támogatja ezt a tulajdonságot."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
