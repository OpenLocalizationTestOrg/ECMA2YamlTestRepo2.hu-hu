### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingServices
  id: RemotingServices
  children:
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  - System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  - System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  - System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  - System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  - System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  langs:
  - csharp
  name: RemotingServices
  nameWithType: RemotingServices
  fullName: System.Runtime.Remoting.RemotingServices
  type: Class
  summary: "Több módszert biztosít a használatával, és a közzététel a távoli használatú objektumok és proxyk. Ez az osztály nem örökölhető."
  remarks: "Csak egy szolgáltató, amelyek aktiválást, életciklusának kezelését vagy tranzakciók, nem kell megkülönböztetni proxy hivatkozások objektum hivatkozását. A távoli eljáráshívási infrastruktúrában átlátszó proxyt, amelyek a benyomást, hogy a távoli objektumok találhatók-e az ügyfél területet használ. Proxyk megvalósítása átirányító hívások távoli helyeken valós objektumokhoz rajtuk."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingServices
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  id: Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Létrehoz egy jól ismert objektum esetén a proxy kap a <xref:System.Type>és URL-címet.</xref:System.Type>"
  remarks: "A végpont a megadott jól ismert objektum által kiszolgált visszaadott proxy objektumra mutat. Nincs üzenetküldés a hálózaton keresztül mindaddig, amíg a metódus lehívásra kerül a proxyra."
  example:
  - "The following code example demonstrates how to use the Connect method to create a proxy to a well-known object.  \n  \n [!code-cpp[RemotingServices.BasicSample#1](~/add/codesnippet/cpp/m-system.runtime.remotin_104_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#1](~/add/codesnippet/csharp/m-system.runtime.remotin_104_1.cs)]\n [!code-vb[RemotingServices.BasicSample#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_104_1.vb)]"
  syntax:
    content: public static object Connect (Type classToProxy, string url);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "A <xref:System.Type>egy jól ismert objektum, amelyhez csatlakozni szeretne a kiszolgálón futó.</xref:System.Type>"
    - id: url
      type: System.String
      description: "A kiszolgáló osztály URL-CÍMÉT."
    return:
      type: System.Object
      description: "A proxy és a távoli objektum, amely a megadott jól ismert objektum által kiszolgált végpont mutat."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  id: Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Létrehoz egy jól ismert objektum esetén a proxy kap a <xref:System.Type>, URL-címet, és a csatorna vonatkozó adatokat.</xref:System.Type>"
  remarks: "A végpont a megadott jól ismert objektum által kiszolgált visszaadott proxy objektumra mutat. Nincs üzenetküldés a hálózaton keresztül mindaddig, amíg a metódus lehívásra kerül a proxyra.       A `data` objektum használatával továbbítja az adatokat a csatornára, és számára a <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>metódus.</xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>"
  syntax:
    content: public static object Connect (Type classToProxy, string url, object data);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "A <xref:System.Type>a jól ismert objektum, amelyhez csatlakozni szeretne.</xref:System.Type>"
    - id: url
      type: System.String
      description: "A jól ismert objektum URL-CÍMÉT."
    - id: data
      type: System.Object
      description: "Adott adatok. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "A proxy, amely a végpont a kért jól ismert objektum által kiszolgált mutat."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  id: Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Leállítja a bejegyzett távoli eljáráshívási csatornákon keresztül további üzenetek fogadása egy objektumot."
  remarks: ''
  example:
  - "The following code example demonstrates how to use the Disconnect method to disconnect an object from the remoting channels.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/m-system.runtime.remotin_81_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/m-system.runtime.remotin_81_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/m-system.runtime.remotin_81_1.vb)]"
  syntax:
    content: public static bool Disconnect (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Válassza le a csatorna objektumot."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az objektum megszakadt a bejegyzett távoli eljáráshívási csatornák sikeresen; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.Disconnect*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <code> obj </code> paramétere a proxy."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  id: ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A megadott távoli objektum kapcsolódik, és végrehajtja a megadott <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodCallMessage&quot;> </xref> rajta."
  remarks: "Az aktuális módszer bizonyos esetekben a kiszolgáló továbbítására szolgál egy másik, valószínűleg távoli objektum a megadott metódus hívásakor. Ez a módszer csak akkor, ha a hívó nem a megfelelő környezetben hívható."
  example:
  - "The following code example demonstrates how to use the ExecuteMessage method to forward method calls to remote objects.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/491f5c62-582d-42d8-b526-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/491f5c62-582d-42d8-b526-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/491f5c62-582d-42d8-b526-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
    parameters:
    - id: target
      type: System.MarshalByRefObject
      description: "A távoli objektum amelynek metódus hívása."
    - id: reqMsg
      type: System.Runtime.Remoting.Messaging.IMethodCallMessage
      description: "A megadott távoli objektum metódus metódus hívása üzenetet."
    return:
      type: System.Runtime.Remoting.Messaging.IMethodReturnMessage
      description: "A válasz a távoli metódus."
  overload: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "Az objektum natív keretében eltérő környezetben a metódus lett meghívva."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  id: GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Ügyféloldali mosdók, ha a megadott proxy által meghatározott távoli objektum üzenetküldésre használt láncolata adja vissza."
  remarks: "Ügyféloldali mosdók együtt küldött mosdók a <xref:System.Runtime.Remoting.ObjRef>egy objektum, amely az az objektum nem ad vissza üzenetek.</xref:System.Runtime.Remoting.ObjRef> Az aktuális metódus az ügyféloldali mosdók a proxyt az objektum és az objektum közötti kommunikáció során használt ad vissza."
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "A távoli objektum által kért ügyféloldali mosdók proxy tartoznak."
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "A megadott proxy társított ügyféloldali nyelő láncba kapcsolhatók."
  overload: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  id: GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A vezérlő az élettartam házirend a megadott objektum élettartama szolgáltatás objektumot ad vissza."
  remarks: "Az alapértelmezett élettartam szolgáltatás a visszaadott objektumot <xref:System.Runtime.Remoting.Lifetime.ILease>.</xref:System.Runtime.Remoting.Lifetime.ILease> típusú objektum is Ha a `obj` paraméter `null`, a metódus visszaadja `null`."
  example:
  - "The following code example demonstrates how to use the GetLifetimeService method to get a lifetime lease for the specified object.  \n  \n [!code-cpp[RemotingServices.TimerSample#1](~/add/codesnippet/cpp/a7d2891c-3dad-448c-949c-_1.cpp)]\n [!code-cs[RemotingServices.TimerSample#1](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_1.cs)]\n [!code-vb[RemotingServices.TimerSample#1](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_1.vb)]  \n  \n To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.  \n  \n The source for timerserver.exe follows:  \n  \n [!code-vb[RemotingServices.TimerSample#2](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_2.vb)]\n [!code-cs[RemotingServices.TimerSample#2](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_2.cs)]  \n  \n The source for timerservice.dll follows:  \n  \n [!code-vb[RemotingServices.TimerSample#3](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_3.vb)]\n [!code-cs[RemotingServices.TimerSample#3](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_3.cs)]"
  syntax:
    content: public static object GetLifetimeService (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Az objektum élettartama szolgáltatás az beszerzése."
    return:
      type: System.Object
      description: "Az objektum, amely szabályozza a élettartama <code> obj </code>."
  overload: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A módszer az alap adja vissza a megadott <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>."
  remarks: "Ez a módszer az alap határozza meg a <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, és <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>tulajdonságainak <xref:System.Runtime.Remoting.Messaging.IMethodMessage>és végrehajtási osztályok által használt a <xref:System.Runtime.Remoting.Messaging.IMethodMessage>felületet.</xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A> A fogyasztók <xref:System.Runtime.Remoting.Messaging.IMethodMessage>osztályok hivatkoznia kell a <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName>tulajdonság.</xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.IMethodMessage>"
  syntax:
    content: public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "Bontsa ki az alap metódus a metódus üzenet."
    return:
      type: System.Reflection.MethodBase
      description: "A metódus alábbi kinyert a <code> msg </code> paraméter."
  overload: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra vagy magasabb a hívási verem a hívók legalább egy felhasználónak nincs engedélye a tagok nem nyilvános típus adatainak beolvasása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A megadott átadásra előkészített által referenciaobjektum be a megadott rendezi sorba <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>."
  syntax:
    content: public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: obj
      type: System.Object
      description: "Az objektum szerializálása."
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> be az objektum tartozik."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A forrás- és a szerializálásnak."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> or <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  id: GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A megadott objektum URI-JÁNAK beolvasása."
  remarks: ''
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/visualbasic/318892c3-7b62-40bd-9e3b-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/csharp/318892c3-7b62-40bd-9e3b-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/cpp/318892c3-7b62-40bd-9e3b-_1.cpp)]
  syntax:
    content: public static string GetObjectUri (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "A <xref href=&quot;System.MarshalByRefObject&quot;> </xref> az URI kérik."
    return:
      type: System.String
      description: "Ha van egy, a megadott objektum URI vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha az objektum nem még átadásra lett előkészítve."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  id: GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Vissza a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , amely a távoli az objektumot határozza meg a megadott proxy."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert. Során unmarshaling, a <xref:System.Runtime.Remoting.ObjRef>a metódus-információkat a távoli objektum és a transzparens proxy elemzi és <xref:System.Runtime.Remoting.Proxies.RealProxy>objektumok létrehozásakor.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos adatokat a távoli alkalmazások elérésével, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.  \n  \n [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/cpp/d6ce9a9a-8ec9-4559-9b2d-_1.cpp)]\n [!code-vb[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/visualbasic/d6ce9a9a-8ec9-4559-9b2d-_1.vb)]\n [!code-cs[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/csharp/d6ce9a9a-8ec9-4559-9b2d-_1.cs)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "A proxy szeretne létrehozni az objektumhoz csatlakozik egy <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> számára."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , amely jelöli, hogy a távoli objektum a megadott proxy csatlakozik-e, vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Ha az objektum vagy a proxy rendelkezik nem előkészítették az átadásra."
  overload: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  id: GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A megadott proxy biztonsági a valódi proxy adja vissza."
  remarks: "Az objektum között távoli eljáráshívás határ bármilyen típusú objektum használó ügyfél ténylegesen használ transzparens proxyra. A transzparens proxy biztosítja a benyomást, hogy a tényleges objektum található, az ügyfél területen. Ez a funkció a valódi objektum használata a távoli eljáráshívási infrastruktúrában intézett hívások továbbít.       A transzparens proxy típusú <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> a felügyelt futásidejű osztály egy példánya által támogatott A <xref:System.Runtime.Remoting.Proxies.RealProxy>valósítja meg a szükséges műveletek továbbítása a transzparens proxy funkciók egy részét.</xref:System.Runtime.Remoting.Proxies.RealProxy>       A proxy objektum örökli a felügyelt objektumok, például a szemétgyűjtés, a tagok és módszerek támogatása társított szemantikáját, és annak űrlap új osztályok. A proxy ugyanahhoz az osztályhoz tartozik, mint a távoli objektum (transzparens proxy) objektum funkcionál, és egyben egy felügyelt objektum."
  syntax:
    content: public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "Transzparens proxyra."
    return:
      type: System.Runtime.Remoting.Proxies.RealProxy
      description: "A transzparens proxy biztonsági valódi proxy-példány."
  overload: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  id: GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Vissza a <xref:System.Type>a megadott URI-azonosítójú objektum.</xref:System.Type>"
  remarks: "Távoli eljáráshívás végpont URI-k segítségével azonosítja, mert a GetServerTypeForUri metódus nagyban elősegíti a moduláris részei a távoli eljáráshívási infrastruktúrában (például csatorna mosdók, dinamikus mosdók és környezet mosdók) használó <xref:System.Runtime.Remoting.Messaging.IMessage>objektumot, mert az aktuális módszer visszatér a társított típusú objektum a URI.</xref:System.Runtime.Remoting.Messaging.IMessage>"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/visualbasic/m-system.runtime.remotin_84_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/csharp/m-system.runtime.remotin_84_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/cpp/m-system.runtime.remotin_84_1.cpp)]
  syntax:
    content: public static Type GetServerTypeForUri (string URI);
    parameters:
    - id: URI
      type: System.String
      description: "Az objektum URI amelynek <xref:System.Type>van szükség.</xref:System.Type>"
    return:
      type: System.Type
      description: "A <xref:System.Type>a megadott URI-azonosítójú objektum.</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra vagy magasabb a hívási verem a hívók legalább egy felhasználónak nincs engedélye a tagok nem nyilvános típus adatainak beolvasása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Egy munkamenet-Azonosítót, üzenet kéri le."
  remarks: "Ugyanahhoz a munkamenet-azonosító esetleg visszaadott objektumok ugyanabban az alkalmazásban, de ez a módszer soha nem adja vissza a két objektumhoz ugyanaz munkamenet-azonosító különböző távoli alkalmazásokban.       Munkamenetek és munkamenet-azonosítók azonosításával kapcsolatos további információkért lásd: ASP.Net [ASP.NET munkamenet-állapot – áttekintés](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to get the session ID string for the current session.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/b83444fc-48c3-47e9-b264-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/b83444fc-48c3-47e9-b264-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/b83444fc-48c3-47e9-b264-_1.vb)]"
  syntax:
    content: public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "A <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref> a munkamenet-azonosító kérik."
    return:
      type: System.String
      description: "A munkamenet karakterlánccal, amely egyedileg azonosítja az aktuális munkamenet."
  overload: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Egy logikai értéket, amely jelzi, hogy az adott üzenethez metódust túlterhelt ad vissza."
  syntax:
    content: public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "Az üzenet, amely tartalmazza az adott metódus hívásakor."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a metódus hívása <code> msg </code> túlterhelt; egyéb, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  id: IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Visszaad egy logikai értéket, amely jelzi, hogy a megadott proxy által meghatározott objektum szerepel egy másik alkalmazás tartományhoz, mint az objektum, amely az aktuális metódus hívása."
  remarks: "Alkalmazástartományok kapcsolatos információkért lásd: [alkalmazástartományok](http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1)."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_103_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_103_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_103_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfAppDomain (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "Az objektum kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az objektum nincs a jelenlegi alkalmazástartomány; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  id: IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Visszaad egy logikai értéket, amely jelzi, hogy a megadott proxy által meghatározott objektum szerepel egy másik környezetet, mint az objektum, amely az aktuális metódus hívása."
  remarks: "A környezet egy rendezett sorozata az találhatók benne lévő objektumokat környezetet meghatározó tulajdonságok biztosítása. Környezet automatikus szolgáltatások ilyen szinkronizálási, tranzakciók, just-in-time aktiválás, biztonsági és így tovább szükség konfigurált objektumok az aktiválási folyamat során jönnek létre. Több objektum is élő belül a környezetben."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_37_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_37_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_37_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfContext (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "Az objektum kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az objektum nincs a jelenlegi kontextusban; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  id: IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Logikai érték, amely jelzi, hogy az ügyfélnek, amelyik a metódus hívása megadva az adott üzenethez arra vár, hogy a kiszolgáló befejezi feldolgozását a metódus végrehajtása a folytatás előtt adja vissza."
  remarks: "Egy egyirányú metódus meghívásakor, az ügyfél nem várja meg a kiszolgáló befejezi az üzenet feldolgozását. Az ügyfél metódus ad vissza, nincsenek saját ismeretei az alkalmazásnak az-e a kiszolgáló sikeresen feldolgozza az üzenetet. Módszerek fel van tüntetve a <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</xref:System.Runtime.Remoting.Messaging.OneWayAttribute> használatával egyik módja       Egyirányú metódusok nem rendelkezhetnek, a visszatérési érték vagy kimeneti paraméterei."
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/visualbasic/e9c4a9fc-d92a-4e43-97a5-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/csharp/e9c4a9fc-d92a-4e43-97a5-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/cpp/e9c4a9fc-d92a-4e43-97a5-_1.cpp)]
  syntax:
    content: public static bool IsOneWay (System.Reflection.MethodBase method);
    parameters:
    - id: method
      type: System.Reflection.MethodBase
      description: "A szóban forgó metódust."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a metódus egyirányú; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsOneWay*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A közvetlen hívónak nincs engedélye infrastruktúra."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  id: IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Jelzi, hogy a megadott objektumnak transzparens proxyra vagy egy valódi objektum logikai érték beolvasása."
  remarks: "Egy objektum a távoli eljáráshívás határ bármilyen keresztül használó ügyfél ténylegesen átlátszó proxyt használ az objektum. A transzparens proxy biztosítja a benyomást, hogy a tényleges objektum található, az ügyfél területen. Ez a funkció a valódi objektum használata a távoli eljáráshívási infrastruktúrában intézett hívások továbbít.       A transzparens proxy maga a fájlban található <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> típusú felügyelt futásidejű osztály egy példánya A <xref:System.Runtime.Remoting.Proxies.RealProxy>valósítja meg a szükséges műveletek továbbítása a transzparens proxy funkciók egy részét.</xref:System.Runtime.Remoting.Proxies.RealProxy> A proxy objektum örökli a felügyelt objektumok, például a szemétgyűjtés, a tagok és módszerek támogatása társított szemantikáját, és annak űrlap új osztályok. Így a proxy van-e a kettős jellegű; egyrészről ugyanahhoz az osztályhoz tartozik, mint a távoli objektum (transzparens proxy) objektum összekötőként kell, és a felügyelt objektum saját magát.       A proxy objektum a távoli eljáráshívás szervezetében <xref:System.AppDomain>.</xref:System.AppDomain> függetlenül használható Alkalmazások nem kell különbséget proxy hivatkozás és objektum hivatkozását. Azonban például az aktiválási problémákkal foglalkozó szolgáltatók, életciklusának kezelését és a tranzakciókkal kapcsolatban kell ilyen különbséget kell tenni."
  example:
  - "The following code example demonstrates the use of the IsTransparentProxy method to determine whether an object is a proxy or a real object. For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.  \n  \n [!code-cpp[AsyncResult.NewExamples#6](~/add/codesnippet/cpp/m-system.runtime.remotin_47_1.cpp)]\n [!code-vb[AsyncResult.NewExamples#6](~/add/codesnippet/visualbasic/m-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncResult.NewExamples#6](~/add/codesnippet/csharp/m-system.runtime.remotin_47_1.cs)]"
  syntax:
    content: public static bool IsTransparentProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "Ellenőrizze objektumra mutató hivatkozást."
    return:
      type: System.Boolean
      description: "Logikai érték, amely jelzi, hogy az objektum szerepel a <code> proxy </code> paraméter értéke transzparens proxyra vagy egy valódi objektum."
  overload: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  id: LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A szakasz egy távoli eljáráshívás exchange egy külső hibakereső naplózza."
  remarks: "A `&quot;REMOTING_PERF&quot;` előfeldolgozási szimbólum vonatkozik, az a módszer használatával a <xref:System.Diagnostics.ConditionalAttribute>attribútum.</xref:System.Diagnostics.ConditionalAttribute>"
  syntax:
    content: public static void LogRemotingStage (int stage);
    parameters:
    - id: stage
      type: System.Int32
      description: "Belső meghatározott konstans, amely azonosítja az egy távoli eljáráshívás exchange szakasza."
  overload: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  id: Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Tart egy <xref href=&quot;System.MarshalByRefObject&quot;> </xref>, regisztrálja azt a távoli eljáráshívási infrastruktúrában, és konvertálja azt egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> osztály."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert.       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos információ a elérni a távoli eljáráshívás felosztása, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Átadás-előkészítési, során az aktuális szál környezetét használja, nem a környezetben, amely már aktív volt az objektum létrehozásakor. Ha egy URI-t nem kifejezetten megadta a <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>metódus, automatikusan hozza létre, a távoli eljáráshívás identitás-infrastruktúra.</xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>       Nem társítható URI azonosítónak egy proxyval két okai: vagy az URI jött létre az objektum, amely a kiszolgáló oldalán, vagy az objektum jól ismert ebben az esetben az URI azonosító is ismert. Ezért ha a `Obj` paraméter esetében a proxy, egy kivételt fog jelezni. Egyéni proxykhoz Ez a korlátozás van enyhíteni, mert a rendszer a transzparens proxy a server objektum."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Alakítsa át az objektumot."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> osztály, amely a megadott objektumot határozza meg a <code> Obj </code> paraméter."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "A <code> Obj </code> paraméter egy objektum proxy."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  id: Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Alakítja át a megadott <xref href=&quot;System.MarshalByRefObject&quot;> </xref> be egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> a megadott URI-azonosítójú osztály."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert.       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos információ a elérni a távoli eljáráshívás felosztása, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Átadás-előkészítési, során az aktuális szál környezetét használja, nem a környezetben, amely már aktív volt az objektum létrehozásakor.       Nem társítható URI azonosítónak egy proxyval két okai: vagy az URI jött létre az objektum, amely a kiszolgáló oldalán, vagy az objektum jól ismert ebben az esetben az URI azonosító is ismert. Ezért ha a `Obj` paraméter esetében a proxy, egy kivételt fog jelezni. Egyéni proxykhoz Ez a korlátozás van enyhíteni, mert a rendszer a transzparens proxy a server objektum."
  example:
  - "The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/01236a8e-f8c3-4b7b-875d-_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/01236a8e-f8c3-4b7b-875d-_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/01236a8e-f8c3-4b7b-875d-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Alakítsa át az objektumot."
    - id: URI
      type: System.String
      description: "A megadott URI azonosító, amelyhez az új inicializálása <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> osztály, amely a megadott objektumot határozza meg a <code> Obj </code> paraméter."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>az objektum proxy van, és a <code>URI</code> paraméter nem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  id: Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Tart egy <xref href=&quot;System.MarshalByRefObject&quot;> </xref> és konvertálja azt egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> osztály és a megadott URI és a megadott <xref:System.Type>.</xref:System.Type>"
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert.       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos információ a elérni a távoli eljáráshívás felosztása, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       A megadott <xref:System.Type>szolgál a távelérési infrastruktúrában kitett típushierarchiában hatókörének korlátozása.</xref:System.Type> Például ha objektum A B, C objektum származik, amely objektum származik, és <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>nevezik, majd az ügyfél tud konvertálni a proxy C és B közötti, de nem felé.       Átadás-előkészítési, során a környezetét az aktuális szál használja, nem a környezetben, amely már aktív volt az objektum létrehozásakor.</xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>       Nem társítható URI azonosítónak egy proxyval két okai: vagy az URI jött létre az objektum, amely a kiszolgáló oldalán, vagy az objektum jól ismert ebben az esetben az URI azonosító is ismert. Ezért ha a `Obj` paraméter esetében a proxy, egy kivételt fog jelezni. Egyéni proxykhoz Ez a korlátozás van enyhíteni, mert a rendszer a transzparens proxy a server objektum."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Az objektum alakítani egy <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>."
    - id: ObjURI
      type: System.String
      description: "A megadott objektum URI a `Obj` paraméter át végrehajtásra, a. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: RequestedType
      type: System.Type
      description: "A <xref:System.Type> `Obj` van elő átadásra.</xref:System.Type> Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Egy példányát a <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> osztály, amely a megadott objektumot határozza meg a <code> Obj </code> paraméter."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>a távoli objektumok egy olyan proxy, és a <code>ObjUri</code> paraméter nem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  id: SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "A következő hívást URI-JÁNAK beállítja a <xref:System.Runtime.Remoting.RemotingServices.Marshal*>metódus.</xref:System.Runtime.Remoting.RemotingServices.Marshal*>"
  remarks: "The URI set by the current method is used when marshaling the given object.  \n  \n After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.  \n  \n If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object. For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\\<appdomainguid>/objectUri route to the object specified in the `obj` parameter."
  example:
  - "The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.  \n  \n [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/cpp/2ed6d271-806d-4778-95aa-_1.cpp)]\n [!code-cs[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/csharp/2ed6d271-806d-4778-95aa-_1.cs)]\n [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/visualbasic/2ed6d271-806d-4778-95aa-_1.vb)]"
  syntax:
    content: public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Az objektumon egy URI-Azonosítóját."
    - id: uri
      type: System.String
      description: "Az URI-hozzárendelése a megadott objektum."
  overload: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>obj</code>értéke nem egy helyi objektumot már előkészítették az átadásra, vagy a jelenlegi metódust már meghívták a."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  id: Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Tart egy <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> és belőle a proxy-objektumot hoz létre."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert. Során unmarshaling, a <xref:System.Runtime.Remoting.ObjRef>a metódus-információkat a távoli objektum és a transzparens proxy elemzi és <xref:System.Runtime.Remoting.Proxies.RealProxy>objektumok létrehozásakor.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> Az elemzett tartalmának <xref:System.Runtime.Remoting.ObjRef>kerül a transzparens proxy előtt a transzparens proxy regisztrálva van a közös nyelvi futtatókörnyezet.</xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos információ a elérni a távoli eljáráshívás felosztása, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to unmarshal an object.  \n  \n [!code-vb[RemotingServices.Unmarshal#2](~/add/codesnippet/visualbasic/b4be8871-533a-4641-8763-_1.vb)]\n [!code-cpp[RemotingServices.Unmarshal#2](~/add/codesnippet/cpp/b4be8871-533a-4641-8763-_1.cpp)]\n [!code-cs[RemotingServices.Unmarshal#2](~/add/codesnippet/csharp/b4be8871-533a-4641-8763-_1.cs)]"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , amely jelöli, hogy a távoli objektum, amelynek a proxy létrehozása folyamatban van."
    return:
      type: System.Object
      description: "A proxy objektumhoz, amely a megadott <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> jelöli."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> a megadott példány a <code> objectRef </code> paraméter formátuma hibás."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  id: Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Tart egy <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> és a proxy-objektumot hoz létre belőle, szűkebbé tenni azt a típusnak a kiszolgálón."
  remarks: "A <xref:System.Runtime.Remoting.ObjRef>objektumhivatkozást továbbíthat között egy alkalmazás tartományhatárt objektum szerializálható ábrázolása.</xref:System.Runtime.Remoting.ObjRef> Létrehozása egy <xref:System.Runtime.Remoting.ObjRef>az objektum az úgynevezett átadás-előkészítési.</xref:System.Runtime.Remoting.ObjRef> A <xref:System.Runtime.Remoting.ObjRef>át lehet vinni egy csatornán keresztül egy másik alkalmazás tartományába (valószínűleg a másik folyamat vagy egy számítógép).</xref:System.Runtime.Remoting.ObjRef> Egyszer a tartományban más alkalmazást a <xref:System.Runtime.Remoting.ObjRef>proxy általában a valós objektumhoz csatlakozik, az objektumok létrehozására kell elemezni.</xref:System.Runtime.Remoting.ObjRef> Ez a művelet unmarshaling néven ismert. Során unmarshaling, a <xref:System.Runtime.Remoting.ObjRef>a metódus-információkat a távoli objektum és a transzparens proxy elemzi és <xref:System.Runtime.Remoting.Proxies.RealProxy>objektumok létrehozásakor.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> Az elemzett tartalmának <xref:System.Runtime.Remoting.ObjRef>kerül a transzparens proxy előtt a transzparens proxy regisztrálva van a közös nyelvi futtatókörnyezet.</xref:System.Runtime.Remoting.ObjRef>       A <xref:System.Runtime.Remoting.ObjRef>leíró adatokat tartalmaz a <xref:System.Type>és átadni kívánt objektumot osztályát, URI, amely egyedileg azonosítja az adott példányt, és kommunikációs kapcsolatos információ a elérni a távoli eljáráshívás felosztása, ahol az objektum.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Első létrehozásakor, a proxy típusa <xref:System.MarshalByRefObject>.</xref:System.MarshalByRefObject> nem Különböző típusainak konvertálni, mint a távoli eljáráshívási infrastruktúrában nyomon követi az a típus betöltése feleslegesen elkerülése érdekében a leggyakrabban használt típus."
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , amely jelöli, hogy a távoli objektum, amelynek a proxy létrehozása folyamatban van."
    - id: fRefine
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Pontosítsa a proxy a típusnak a kiszolgálón. Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Object
      description: "A proxy objektumhoz, amely a megadott <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> jelöli."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> a megadott példány a <code> objectRef </code> paraméter formátuma hibás."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívási verem feljebb hívók legalább egy nincs engedélye a távoli eljáráshívás típusok és csatornák beállítása."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Runtime.Remoting.RemotingException
  parent: System.Runtime.Remoting
  isExternal: false
  name: RemotingException
  nameWithType: RemotingException
  fullName: System.Runtime.Remoting.RemotingException
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.MarshalByRefObject
  parent: System
  isExternal: false
  name: MarshalByRefObject
  nameWithType: MarshalByRefObject
  fullName: System.MarshalByRefObject
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
- uid: System.Runtime.Remoting.Messaging.IMethodReturnMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodReturnMessage
  nameWithType: IMethodReturnMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodReturnMessage
- uid: System.Runtime.Remoting.Messaging.IMethodCallMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodCallMessage
  nameWithType: IMethodCallMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodCallMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: true
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Runtime.Remoting.Messaging.IMethodMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodMessage
  nameWithType: IMethodMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.ObjRef
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjRef
  nameWithType: ObjRef
  fullName: System.Runtime.Remoting.ObjRef
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
- uid: System.Runtime.Remoting.Proxies.RealProxy
  parent: System.Runtime.Remoting.Proxies
  isExternal: false
  name: RealProxy
  nameWithType: RealProxy
  fullName: System.Runtime.Remoting.Proxies.RealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
- uid: System.Runtime.Remoting.RemotingServices.Connect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect
  nameWithType: RemotingServices.Connect
- uid: System.Runtime.Remoting.RemotingServices.Disconnect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect
  nameWithType: RemotingServices.Disconnect
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage
  nameWithType: RemotingServices.ExecuteMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy
  nameWithType: RemotingServices.GetEnvoyChainForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService
  nameWithType: RemotingServices.GetLifetimeService
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData
  nameWithType: RemotingServices.GetObjectData
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri
  nameWithType: RemotingServices.GetObjectUri
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy
  nameWithType: RemotingServices.GetObjRefForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy
  nameWithType: RemotingServices.GetRealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri
  nameWithType: RemotingServices.GetServerTypeForUri
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage
  nameWithType: RemotingServices.GetSessionIdForMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded
  nameWithType: RemotingServices.IsMethodOverloaded
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain
  nameWithType: RemotingServices.IsObjectOutOfAppDomain
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext
  nameWithType: RemotingServices.IsObjectOutOfContext
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay
  nameWithType: RemotingServices.IsOneWay
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy
  nameWithType: RemotingServices.IsTransparentProxy
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage
  nameWithType: RemotingServices.LogRemotingStage
- uid: System.Runtime.Remoting.RemotingServices.Marshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal
  nameWithType: RemotingServices.Marshal
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal
  nameWithType: RemotingServices.SetObjectUriForMarshal
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal
  nameWithType: RemotingServices.Unmarshal
