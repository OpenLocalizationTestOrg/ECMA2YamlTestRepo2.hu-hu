### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "A <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modul fájl, a könyvtár vagy a mappát és a rendszer műveletek végrehajtásához használt eljárásokat tartalmazza. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek használnak, mint a <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modul. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Ez a modul támogatja a Visual Basic nyelvi kulcsszavak és futásidejű kódtár – tagok, amelyek a fájlok vagy mappák elérését."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Módosítja az aktuális könyvtárhoz vagy a mappát. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítmény mint fájl i/o-műveletek a <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>függvény. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "A `ChDir` függvény megváltoztatja az alapértelmezett mappát, de nem az alapértelmezett meghajtón. Például akkor, ha az alapértelmezett meghajtó C, a következő utasítás módosítja az alapértelmezett könyvtár a D meghajtó C marad az alapértelmezett meghajtón: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] biztosíthatja, hogy a relatív változások van írja be a két időszak az alábbiak szerint: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > a `ChDir` függvény csak a nem felügyelt kód engedéllyel, ami hatással lehet a részlegesen megbízható helyzetekben végrehajtása. További információkért lásd: <xref:System.Security.Permissions.SecurityPermission>és.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kötelező. A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> kifejezést, amely azonosítja a melyik könyvtár vagy a mappa válik az új alapértelmezett könyvtár vagy mappa. `Path`a meghajtó is tartalmazhat. Ha nincs meghajtó van megadva, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> módosítja az alapértelmezett címtár vagy az aktuális meghajtó mappájában."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>Nincs megadva."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Érvénytelen meghajtó van megadva, vagy a meghajtó nem érhető el."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Az aktuális meghajtó változik."
  remarks: "A `ChDrive` függvény csak a nem felügyelt kód engedéllyel, ami hatással lehet a részlegesen megbízható helyzetekben végrehajtása során. További információkért lásd: <xref:System.Security.Permissions.SecurityPermission>és [kódelérési engedélyeik](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Kötelező. A karakterlánc-kifejezés, amely megadja egy meglévő meghajtó. Ha ad meg a nulla hosszúságú karakterlánc (&quot;&quot;), az aktuális meghajtó nem változik. Ha a `Drive` argumentum egy több karaktert tartalmazó karakterlánc, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> használ, csak az első betűjét."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Érvénytelen meghajtó van megadva, vagy a meghajtó nem érhető el."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Az aktuális meghajtó változik."
  remarks: "A `ChDrive` függvény csak a nem felügyelt kód engedéllyel, ami hatással lehet a részlegesen megbízható helyzetekben végrehajtása során. További információkért lásd: <xref:System.Security.Permissions.SecurityPermission>és [kódelérési engedélyeik](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Kötelező. A karakterlánc-kifejezés, amely megadja egy meglévő meghajtó. Ha ad meg a nulla hosszúságú karakterlánc (&quot;&quot;), az aktuális meghajtó nem változik. Ha a `Drive` argumentum egy több karaktert tartalmazó karakterlánc, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> használ, csak az első betűjét."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Érvénytelen meghajtó van megadva, vagy a meghajtó nem érhető el."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Az aktuális útvonalon képviselő karakterláncot ad vissza. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Egy karakterlánc, amely az aktuális útvonalon."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Az aktuális útvonalon képviselő karakterláncot ad vissza. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Nem kötelező. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>egy meglévő meghajtó meghatározó kifejezés. Ha nincs meghajtó van megadva, vagy ha `Drive` egy nulla hosszúságú karakterlánc (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> az aktuális meghajtó elérési útját adja vissza."
    return:
      type: System.String
      description: "Egy karakterlánc, amely az aktuális útvonalon."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy fájl, a könyvtár vagy a mappát, amely megfelel a megadott minta vagy a fájl attribútumának neve vagy a kötetcímke meghajtó képviselő karakterláncot ad vissza. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az jobb hatékonyságot és teljesítmény mint fájl i/o-műveletek a <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> függvény. Lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>További információt.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "A `Dir` funkció támogatja a többszörös karakteres (`*`) és karaktert (`?`) helyettesítő karakterrel több fájl megadásához.       `VbVolume`a kötet címkéje a meghajtót egy meghatározott fájl neve helyett adja vissza.       Meg kell adnia egy `PathName` az első alkalommal meghívja a `Dir` függvény. A következő elem beolvasása, hogy ezt a `Dir` függvény paraméterek nélkül.      > [!IMPORTANT] > Működéséhez, a `Dir` függvény csak a <xref:System.Security.Permissions.FileIOPermissionAccess>és <xref:System.Security.Permissions.FileIOPermissionAccess>jelzőit <xref:System.Security.Permissions.FileIOPermission>engedélyezhető a végrehajtás alatt álló kódot.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> További információkért lásd: <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, és [kódelérési engedélyeik](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       A `Attributes` argumentum számbavételi értékek a következők: |||   |-|-|-|   | Érték |} Állandó |} Leírás |}   | `Normal`|`vbnormal`| Alapértelmezés szerint. Attribútumok nélkül fájlokat adja meg. |}   | `ReadOnly`|`vbReadOnly`| Adja meg a csak olvasható fájlokat, valamint a fájlok attribútumok nélkül. |}   | `Hidden`|`vbHidden`| Meghatározza a rejtett fájlok, valamint a fájlok attribútumok nélkül. |}   | `System`|`vbSystem`| Megadja a rendszerfájlok, valamint a fájlok attribútumok nélkül. |}   | `Volume`|`vbVolume`| Adja meg a kötetcímkét; Ha attribútum meg van adva, `vbVolume` figyelmen kívül hagyja. |}   | `Directory`|`vbDirectory`| Meghatározza a címtárak vagy mappákat, és még fájlok attribútumok nélkül. |}   | `Archive`|`vbArchive`| Utolsó biztonsági mentés óta módosult a fájl. |}   | `Alias`|`vbAlias`| A fájl rendelkezik egy másik nevet. |}      > [!NOTE] > Ezeket az enumerálások vannak megadva, a Visual Basic nyelv, és a tényleges értékek helyett a kódban bárhol használható."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Egy karakterlánc, amely egy fájl, a könyvtár vagy a mappát, amely megfelel a megadott minta vagy a fájl attribútumának neve vagy a kötetcímke-meghajtó."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy fájl, a könyvtár vagy a mappát, amely megfelel a megadott minta vagy a fájl attribútumának neve vagy a kötetcímke meghajtó képviselő karakterláncot ad vissza. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az jobb hatékonyságot és teljesítmény mint fájl i/o-műveletek a <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> függvény. Lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>További információt.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "A `Dir` funkció támogatja a többszörös karakteres (`*`) és karaktert (`?`) helyettesítő karakterrel több fájl megadásához.       `VbVolume`a kötet címkéje a meghajtót egy meghatározott fájl neve helyett adja vissza.       Meg kell adnia egy `PathName` az első alkalommal meghívja a `Dir` függvény. A következő elem beolvasása, hogy ezt a `Dir` nincs paraméterekkel rendelkező függvény.      > [!IMPORTANT] > Működéséhez, a `Dir` függvény csak a <xref:System.Security.Permissions.FileIOPermissionAccess>és <xref:System.Security.Permissions.FileIOPermissionAccess>jelzőit <xref:System.Security.Permissions.FileIOPermission>engedélyezhető a végrehajtás alatt álló kódot.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> További információkért lásd: <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, és [kódelérési engedélyeik](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       A `Attributes` argumentum számbavételi értékek a következők: |||   |-|-|-|   | Érték |} Állandó |} Leírás |}   | `Normal`|`vbnormal`| Alapértelmezés szerint. Adja meg a fájlra, amely nem attribútum. |}   | `ReadOnly`|`vbReadOnly`| Adja meg a csak olvasható fájlokat, fájlok, amelyek nincsenek attribútumai mellett. |}   | `Hidden`|`vbHidden`| Meghatározza a rejtett fájlok, fájlok, amelyek nincsenek attribútumai mellett. |}   | `System`|`vbSystem`| Adja meg a rendszerfájlok, fájlok, amelyek nincsenek attribútumai mellett. |}   | `Volume`|`vbVolume`| Adja meg a kötetcímkét; Ha attribútum meg van adva, `vbVolume` figyelmen kívül hagyja. |}   | `Directory`|`vbDirectory`| Határozza meg, könyvtárak és mappák, továbbá olyan fájlra, amely nem attribútum. |}   | `Archive`|`vbArchive`| Utolsó biztonsági mentés óta módosult a fájl. |}   | `Alias`|`vbAlias`| A fájl rendelkezik egy másik nevet. |}      > [!NOTE] > Ezeket az enumerálások vannak megadva, a Visual Basic nyelv, és a tényleges értékek helyett a kódban bárhol használható."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Nem kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>egy fájl neve, könyvtár-vagy mappanév vagy kötetcímke meghajtó meghatározó kifejezés. Egy nulla hosszúságú karakterlánc (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) ad vissza, ha `PathName` nem található."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Nem kötelező. Számbavételi vagy numerikus kifejezés, amelynek az értéke határozza meg a fájl attribútumainak. Ha nincs megadva, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> értéket ad vissza, amely eleget fájlok `PathName` azonban nem attribútum."
    return:
      type: System.String
      description: "Egy karakterlánc, amely egy fájl, a könyvtár vagy a mappát, amely megfelel a megadott minta vagy a fájl attribútumának neve vagy a kötetcímke-meghajtó."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy logikai értéket ad vissza <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> a fájl megnyitásakor a <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> vagy egymást követő <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> el lett érve."
  remarks: "Használjon `EOF` megpróbálja beolvasni adjon meg egy fájl végén túlra állítja elő hiba elkerülése érdekében.       A `EOF` értéket ad vissza működéséhez `False` mindaddig, amíg a rendszer elérte a fájl végét. A megnyitott fájlokkal `Random` vagy `Binary` hozzáférés, `EOF` adja vissza `False` csak az utolsó végrehajtott `FileGet` függvény nem tudja olvasni a teljes rekord.       A megnyitott fájlokkal `Binary` fér hozzá, a fájl használatával keresztül olvasási kísérlet történt a `Input` működni, amíg `EOF` adja vissza `True` hibát generál. Használja a `LOF` és `Loc` ahelyett, hogy működik `EOF` olvasásakor a bináris fájlok `Input`, vagy használjon `Get` használata esetén a `EOF` függvény. A megnyitott fájlokkal `Output`, `EOF` mindig vissza `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , amely bármilyen érvényes fájl számát tartalmazza."
    return:
      type: System.Boolean
      description: "Egy logikai értéket ad vissza <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> a fájl megnyitásakor a <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> vagy egymást követő <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> el lett érve."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "A megnyitott fájlok fájl mód képviselő enumerálást ad vissza a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az jobb hatékonyságot és teljesítmény mint fájl i/o-műveletek a <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>függvény. Lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>További információt.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Ez a funkció a megnyitott fájlok fájl mód képviselő enumerálást ad vissza a `FileOpen` függvény."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Bármilyen érvényes szám."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "A következő számbavételi értékek azt jelzik, hogy a fájl hozzáférési mód:       <table><tbody><tr><td> Érték       </td><td> Mód       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Megjelenik a bemeneti/kimeneti (I/O) megnyitniuk fájlba a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek. Lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> további információt."
  remarks: "A `FileClose` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [hogyan: olvasási szöveg és a StreamReader osztályra fájlokból](~/add/includes/ajax-current-ext-md.md),[hogyan: egy StreamWriter fájlok szöveg írása](~/add/includes/ajax-current-ext-md.md), és [forgatókönyv: kezelésére szolgáló fájlok és könyvtárak a Visual Basic](~/add/includes/ajax-current-ext-md.md).       Ha nincs megadva `FileNumbers`, minden aktív fájlok megnyitotta a `FileOpen` funkció be van zárva.       A megnyitott fájlokból lezárásakor `Output` vagy `Append`, a végső kimenetet puffer az operációs rendszer pufferbe, hogy a fájl írása. A lezárt társított hely puffer összes fájl megjelenik.       Ha a `FileClose` függvény végrehajtása, a fájl fájl társítását number végződik."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Nem kötelező. A paramétertömb 0 vagy több csatorna bezárására készül."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Másolja át a fájlt. A <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>További információt.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Ha próbálja használni a `FileCopy` működnek a jelenleg megnyitott fájl hiba történik.       `FileCopy`a helyi meghajtón működéséhez teljes megbízható kapcsolatot igényel."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>az kifejezés, amely meghatározza a másolandó fájl nevét. `Source`a könyvtár vagy a mappát és a meghajtóra, a forrásfájl tartalmazhatnak."
    - id: Destination
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a célfájl neve meghatározó kifejezés. `Destination`a könyvtár vagy a mappa és a meghajtóra, a célfájl tartalmazhatnak."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>vagy <code>Destination</code> érvénytelen vagy nincs megadva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl már meg nyitva."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Fájl nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> érték, amely jelzi a dátum és idő, a fájl írása megtörtént. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. További információkért lásd:<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a fájl nevét meghatározó kifejezés. `PathName`Előfordulhat, hogy tartalmazza a könyvtárban vagy mappában, és a meghajtó."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>érték, amely azt jelzi, a dátumot és időpontot, egy fájl létrehozott vagy utolsó módosítás."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>Érvénytelen, vagy helyettesítő karaktereket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Célfájl nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd:<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Boolean
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Byte
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Char
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.DateTime
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Decimal
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Double
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int16
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int32
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int64
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Single
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.ValueType
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.String
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Nem kötelező. Csak egy karakterlánc írásakor vonatkozik. Megadja, hogy a karakterlánc, amely a hossz a kétbájtos leírója írni. Az alapértelmezett érték <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Array
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Nem kötelező. Csak egy tömb írásakor vonatkozik. Meghatározza, hogy a tömb kell kezelni, a dinamikus és szükség-e egy tömb leíró leíró méretének és a tömb határain kívülre mutat."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Nem kötelező. Csak egy karakterlánc írásakor vonatkozik. Megadja, hogy a karakterlánc, amely a hossz a kétbájtos leírója írni. Az alapértelmezett érték <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy nyitott fájlhoz egy változóba olvassa be az adatokat.  A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Object
      description: "Kötelező. Érvényes változónevet ahová adatolvasás."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely olvasási kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> érték, amely a fájl hosszát határozza meg bájtban. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Ha a megadott fájl nyitva, ha a `FileLen` függvény hívása esetén, a visszaadott érték a fájl mérete a megnyitása során.      > [!NOTE] > A jelenlegi hossza nyitott fájlok beszerzéséhez használja a `LOF` függvény."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a fájl meghatározó kifejezés. `PathName`Előfordulhat, hogy tartalmazza a könyvtárban vagy mappában, és a meghajtó."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>érték, amely a fájl hosszát határozza meg bájtban."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Fájl nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "A bemeneti vagy kimeneti fájlt nyit meg. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `FileOpen` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A bármely i/o-művelet végrehajtása előtt meg kell nyitnia egy fájlt. `FileOpen`a puffer i/o fájl foglal le, majd határozza meg a használandó puffer hozzáférési mód.      > [!IMPORTANT] > Fájlba ír, amikor egy alkalmazás lehet, hogy hozzon létre egy fájlt, ha a fájl, amelyhez írási tett kísérlet nem létezik. Ehhez szükséges engedélyt a könyvtárat, amelyben a fájl hozható létre. Azonban ha a fájl által megadott `FileName` létezik, az alkalmazások igényeihez `Write` engedély csak magát a fájlt. Ahol csak lehetséges, a biztonság javítása érdekében hozzon létre a fájl során üzembe helyezési és támogatás `Write` engedélyt a fájlhoz csak, ahelyett, hogy a teljes könyvtárba. A biztonság növelése érdekében a gyökérkönyvtár vagy a Program Files könyvtár ahelyett, hogy a felhasználó könyvtárak adatokat írni.       A csatorna megnyitása található használatával a `FreeFile()` függvény.      > [!IMPORTANT] > A `FileOpen` függvény csak `Read` elérje a `FileIOPermissionAccess` számbavételi, ami hatással lehet a részlegesen megbízható kapcsolat helyzetekben végrehajtása során. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám. Használja a <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> működnek, szerezze be a következő elérhető fájlok számát."
    - id: FileName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a fájl nevét megadó kifejezés – előfordulhat, hogy tartalmazza a könyvtárban vagy mappában, és a meghajtó."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Kötelező. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Nem kötelező. A nyitott fájlok engedélyezett számbavételi műveletek megadása: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, vagy <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Az alapértelmezett <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Nem kötelező. Adja meg a művelet nem engedélyezett a megnyitott fájlt másik folyamat felsorolása: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, és <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Az alapértelmezett <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Nem kötelező. Szám kisebb vagy egyenlő, mint 32 767 (bájt). Közvetlen elérésű a megnyitott fájlok az értéke a rekord hossza. Szekvenciális fájlok esetében az értéke a pufferelt karakterek száma."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Rekord hossza negatív (és nem egyenlő -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>már meg nyitva, vagy <code>FileName</code> érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékának a `FileOpen`függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Boolean
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Byte
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Char
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.DateTime
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Decimal
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Double
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a`VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int16
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int32
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int64
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékának a `FileOpen`függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Single
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a`RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.ValueType
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Object
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Object
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.String
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Nem kötelező. Csak egy karakterlánc írásakor vonatkozik. Megadja, hogy a karakterlánc a kétbájtos karakterlánc hossza leíró írni a fájlt. Az alapértelmezett érték <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePut` általában olvasható fájlból használatával `FileGet`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, a következő rekord vagy után utolsó bájtig eltelt `FileGet` vagy `FilePut` működik, vagy az utolsó által hivatkozott `Seek` függvény írása.       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePut`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePut`, meg kell nyitnia azonos az `FileGet`, és győződjön meg arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePut` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatmennyiség bármely biztosan nem határozható meg, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivételt fog jelezni.      -Ha a változó ír egy karakterlánc `FilePut` ír a kétbájtos leíró karakterlánchosszát tartalmazza, amely ezután ír az adatokat, ez a változó be. Ezért a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvény legalább két bájt a tényleges a karakterlánc hossza nagyobb lehet.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePut` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePut` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePut` ír egy két bájthoz leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, megválaszthatja, hogy-e a leíró, és a dimenziók a tömb írni. Visual Basic 6.0-s és régebbi írni a fájlleíró egy rögzített méretű array dinamikus tömb azonban nem. Visual Basic 2005 alapértelmezés szerint a leíró nincs írás. A leíró írása, állítsa be a `ArrayIsDynamic` paramétert `True`. A tömb írásakor, a tömb fogja beolvasni; módjának rendelkezik Ha a leíróval fogja beolvasni, hogy a leíró írási. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions). A megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. Például a következő tömb deklaráció szükséges-e 218 bájt a tömb írásakor lemezre.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] – Ha a változó írása változó (nem egy változó hosszúságú karakterlánc vagy objektum), bármilyen más típusú `FilePut` csak a változó adatokat. A megadott rekord hossza a `RecordLength` záradékot a `FileOpen` függvény kisebb, mint az adatok írása hosszának egyenlőnek kell lennie..      - `FilePut` ír elemek struktúrák, mintha csak az egyes készültek egyenként, azzal a különbséggel, hogy nincs elem közötti térközt. A `VBFixedString` attribútum alkalmazhatja a struktúrákat, hogy utalhat, hogy ha a karakterlánc mérete sztringek mezőinek lemezre.          > [!NOTE] > Karakterlánc, amelyek több bájt által megadott mezőket a `VBFixedString` attribútum csak írásakor lemezre, ## bináris mód a fájlok megnyitása a `Binary` módban, a legtöbb a `Random` mód szabályokat alkalmazni, néhány kivétellel. A megnyitott fájlok a következő szabályok `Binary` mód eltér a vonatkozó szabályok `Random` mód: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePut`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt.      -A a tömb nem tömb a struktúrában `FilePut` csak az adatokat. Nincs leíró írása.      - `FilePut` ír, amelyek nincsenek a kétbájtos hossza leíró nélkül struktúrák elemek változó hosszúságú karakterláncok. Az írt bájtok száma egyenlő a karakterláncban szereplő karakterek számát. Például a következő utasításokat írni 11 bájt 1-es számú fájl: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - használatával fájlba írása a `FilePut` függvény csak `Write` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Array
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Nem kötelező. Csak egy tömb írásakor vonatkozik. Megadja, hogy a tömb dinamikus kell kezelni, és hogy a egy a karakterlánc, amely a hossz a tömb leírója."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Nem kötelező. Csak egy karakterlánc írásakor vonatkozik. Megadja, hogy a karakterlánc a kétbájtos karakterlánc hossza leíró írni a fájlt. Az alapértelmezett érték <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 és -1-nem egyenlő."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írja az adatokat a változót egy lemezen levő fájlra.  A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `FilePutObject` függvény használata helyett `FilePut` elkerülésére kétértelműséget a fordítás során, ha a típus `Object` , mint a más típusú helyett átadott `Integer`, `Long`, `Short`, és így tovább.       `FilePutObject`naplózza, és beolvassa a leírót, hogy az objektum leírására. Ha az írható ki a `Variant` típusa, `FilePutObject` szükséges. A kétségei vannak, ha egy objektumot használ a második paraméterhez, azt javasoljuk, hogy mindig használjon `FilePutObject` és `FileGetObject`.       `FilePutObject`csak érvényes `Random` és `Binary` mód.       Az írt adatok `FilePutObject` általában olvasható fájlból használatával `FileGetObject`.       Az első rekord vagy egy fájlban bájt 1 helyén, a második rekord vagy bájt van 2 pozíciója, és így tovább. Ha nincs megadva `RecordNumber`, `FilePutObject` a következő rekord vagy bájt írása után utolsó `FileGetObject` vagy `FilePutObject` függvény (vagy az utolsó által hivatkozott azokat a byte `Seek` függvény).       A `StringIsFixedLength` argumentum meghatározza, hogy a függvény, változó vagy rögzített hosszúságú karakterláncok értelmezi. `FilePutObject`nem írja a hossza leíró, ha az argumentum `True`. Használatakor `StringIsFixedLength`  =  `True` rendelkező `FilePutObject`, meg kell nyitnia azonos az `FileGetObject`, és is meg kell győződnie arról, hogy a karakterlánc várt hosszra inicializálva van.      ## Véletlenszerű mód a fájlok megnyitása a `Random` módban, a következő szabályok lépnek érvénybe: – Ha az adatok írása hossza kisebb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, `FilePutObject` írja a következő rekordokat hosszúságú rekord határokon belül. A fájl puffer meglévő tartalma egy rekord vége és a következő rekordjának közötti van kiegészítve. Kitöltési adatok mennyisége nem határozható meg pontosan, mert akkor általában érdemes a rekord hossza a írt adatok hosszának egyeznie kell. Ha az adatok írása hossza nagyobb, mint a megadott hossz a `RecordLength` záradékában a `FileOpen` függvény, kivétel történik.      -Ha a változó írása, amely tartalmaz egy numerikus típusú objektum `FilePutObject` azonosító két bájtot ír a `VarType` az objektum, majd létrehoz a változót. Például történő írásakor, az objektum, amely tartalmazza egy egész számot, `FilePutObject` hat bájt ír: két bájtot, mint az objektum azonosítására `VarType(`3`)` (`Integer`) és az adatokat tartalmazó négy bájt. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvénynek kell lennie legalább két bájtot nagyobb, mint a tényleges változó tárolásához szükséges bájtok száma.      -Ha a változó ír egy karakterláncot tartalmazó objektum `FilePutObject` ír egy kétbájtos leíró azonosítása a `VarType(`8`)` az objektum, a kétbájtos leíró jelző a karakterláncot, és írás a karakterlánc típusú adatok hossza. A megadott rekord hossza a `RecordLength` paramétere a `FileOpen` függvény legalább négy bájtnak nagyobb, mint a karakterlánc a tényleges hosszúság kell lennie. Ha el szeretné helyezni a leíró nélküli egy karakterláncot, át kell `True` számára a `StringIsFixedLength` paraméter, és olvassa el a kell a megfelelő hosszúságú karakterlánc.      -Ha a változó ír egy tömb, akkor a megadott rekord hossza a `RecordLength` záradék a következő a `FileOpen` függvénynek kell lennie, nagyobb vagy egyenlő a tömb adatok és a tömb leíró írása szükséges összes bájt számának összege. A leíró rangsorolását a tömb mérete és az alsó határértékét az egyes indulva számított rangját adja meg. A hossz egyenlő 2 és 8 alkalommal fordult elő a dimenziók száma: (2 + 8 * NumberOfDimensions).      ## Bináris mód a fájlok megnyitása a `Binary` mód, minden a `Random` mód szabályok vonatkoznak, kivéve: - a `RecordLength` záradék a következő a `FileOpen` függvény nincs hatása. `FilePutObject`Írja az összes változó lemezre jelleggel, ez azt jelenti, hogy nélkül rekordok közötti térközt."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Object
      description: "Kötelező. Érvényes változónevet írt adatokat tartalmazó lemezre."
    - id: RecordNumber
      type: System.Int64
      description: "Nem kötelező. Rögzíti a számát (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> módban fájlok) vagy bájt szám (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> módban fájlok), mely írás kezdődik."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hozzárendel egy kimeneti vonalvastagság használatával megnyitott fájl a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: RecordWidth
      type: System.Int32
      description: "Kötelező. Numerikus kifejezés 0 – 255 közötti, a határokat is beleértve, amely azt jelzi, hogy hány karakter sorban jelenik meg, új sor megkezdése előtt. Ha `RecordWidth` értéke 0, egy sor hosszának korlátozva van. Az alapértelmezett érték `RecordWidth` 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> által használható a következő fájl számot jelölő értéket a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény."
  remarks: "Használjon `FreeFile` adja meg egy fájl szám, amely már nem használja."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> által használható a következő fájl számot jelölő értéket a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "255-nél több fájl használatban van."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> érték, amely a fájl, a könyvtár vagy a mappa attribútumait tartalmazza. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Határozhatja meg, hogy mely attribútumok vannak beállítva, a `And` üzemeltető által visszaadott érték bitenkénti összehasonlítása végrehajtásához a `GetAttr` függvény, értéke pedig a kívánt egyéni attribútumot. Ha az eredmény nem nulla, ez az attribútum be van állítva a nevű fájlba. Például a visszatérési érték a következő `And` kifejezés nulla, ha a `Archive` attribútum nincs beállítva: ```vb#   Result = GetAttr(FName) And vbArchive   ``` nullától eltérő értéket ad vissza, ha a `Archive` attribútum van beállítva."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>az kifejezés, amely a fájl, a könyvtár vagy a mappa nevét határozza meg. `PathName`a könyvtárban vagy mappában, és a meghajtó tartalmazhatnak."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "Által visszaadott érték <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> a következő számbavételi értékek összegét:       <table><tbody><tr><td> Érték       </td><td> Állandó leírása       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normál.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Csak olvasható.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Rejtett.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Rendszer-fájl.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Könyvtárban vagy mappában.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Utolsó biztonsági mentés óta módosult a fájl.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>A fájl rendelkezik egy másik nevet.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Ezek az enumerálások meg van adva, a Visual Basic nyelv. A nevei bárhol használhatók a kódban a tényleges értékek helyett.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>Érvénytelen, vagy helyettesítő karaktereket tartalmaz."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Célfájl nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Boolean
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Byte
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Char
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.DateTime
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Decimal
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Double
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int16
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mivel a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int32
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Int64
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Object
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.Single
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Nyissa meg a soros fájlból olvassa be az adatokat, és hozzárendeli az adatok változók."
  remarks: "A `Input` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `Input` általában beíródik egy fájl segítségével `Write`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne a fájlnévkiterjesztés alapján a fájl tartalma döntéseket. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic 2005 forrásfájl.       Ha olvasni, szabványos karakterlánc- vagy numerikus adatokat hozzá van rendelve változók módosítás nélkül. A következő táblázat bemutatja, hogyan kezelje a más bemeneti adatok.      |||   |-|-|   | Adatok |} Változójához rendelt értéket |}   | Vesszővel vagy üres sor határoló |} Üres |}   |} #NULL # |} `DBNull`|   |} TRUE # vagy FALSE # |} `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A dátumot és/vagy a kifejezés által meghatározott időt |}   |#ERROR `errornumber` #| `errornumber` (változó megjelölve, a hiba egy objektum) |}       Ha a fájl végét éri el, amíg vannak bevitel, adatelemet, a bemeneti leáll, és hiba történik.      > [!NOTE] > A `Input` függvény nem honosítva van. Például német nyelvű 3,14159, ha adja vissza, csak 3, mert a vesszővel decimális pontként változó elválasztó ahelyett, hogy a rendszer.      > [!IMPORTANT] > Használatával Fájlolvasási a `Input` függvény csak `Read` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Value
      type: System.String
      description: "Kötelező. Változó, amely hozzá van rendelve az értékeket a következő fájl olvasásának – egy tömb vagy objektum változó értéke nem lehet."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Beolvasása <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> fájlból származó karaktereket tartalmazó megnyitott <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> mód. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `InputString` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok a `InputString` függvény általában beíródik egy fájl segítségével `Print` vagy `FilePut`. Ez a funkció használata csak a megnyitott fájlok `Input` vagy `Binary` mód.       Ellentétben a `Input` funkció, a `InputString` függvény olvassa be az összes karakter. Ez magában foglalja, vesszővel válassza el egymástól, kocsivissza, soremelés, idézőjelek és szóközök.       A megnyitott fájlokkal `Binary` fér hozzá, a fájl használatával olvasási kísérlet történt a `InputString` működni, amíg `EOF` adja vissza `True` hibát generál. Használja a `LOF` és `Loc` ahelyett, hogy működik `EOF` ha elolvasta bináris fájlok használatával `InputString`, vagy használjon `FileGet` használata esetén a `EOF` függvény.      > [!NOTE] > Fájlokból olvasásakor ne biztonsági döntéseket hozzanak arról, hogy a tartalmát a fájl a fájlnévkiterjesztés alapján. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic forrásfájl."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: CharCount
      type: System.Int32
      description: "Kötelező. Egy érvényes numerikus kifejezést, olvasható karakterek számát."
    return:
      type: System.String
      description: "Beolvasása <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> fájlból származó karaktereket tartalmazó megnyitott <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> mód. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>nem létezik."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Törli a fájlokat egy lemezről. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`támogatja a többszörös karakteres (`*`) és karaktert (`?`) helyettesítő karakterrel több fájl megadásához.       **Biztonsági megjegyzés** végrehajtásához, a `Kill` függvény csak `Read` és `PathDiscovery` jelzőit <xref:System.Security.Permissions.FileIOPermission>engedélyezhető a végrehajtás alatt álló kódot.</xref:System.Security.Permissions.FileIOPermission> További információkért lásd: <xref:System.Security.SecurityException> [kódelérési engedélyeik](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>egy vagy több fájl neve a törlendő meghatározó kifejezés. `PathName`a könyvtárban vagy mappában, és a meghajtó tartalmazhatnak."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nyissa meg a cél (oka) t."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Cél-fájl nem található."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Az engedély megtagadva."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Olvassa be az egysoros szekvenciális fájl megnyitása, és úgy, hogy hozzárendel egy <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> változó."
  remarks: "A `LineInput` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A beolvasott adatok `LineInput` általában beíródik egy fájl segítségével `Print`.      > [!IMPORTANT] > Történő olvasásakor fájlokat, ne egy fájl a fájlnévkiterjesztés alapján döntéseket hozzanak arról, hogy a tartalom. Például egy Form1.vb nevű fájlt nem lehet olyan Visual Basic forrásfájl.       A `LineInput` függvény, amíg a kocsivissza ütközik beolvassa a fájl egy karakter (`Chr(`13`)`) vagy a kocsivissza/üres sor hírcsatorna (`Chr(`13`)` + `Chr(`10`)`) feladatütemezési. Kocsivissza/üres sor adatcsatorna sorozatok kimarad ahelyett, hogy a karakterlánccal lesz hozzáfűzve.      > [!IMPORTANT] > Használatával Fájlolvasási a `LineInput` függvény csak `Read` elérje a <xref:System.Security.Permissions.FileIOPermissionAccess>számbavételi.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    return:
      type: System.String
      description: "Olvassa be az egysoros szekvenciális fájl megnyitása, és úgy, hogy hozzárendel egy <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> változó."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Elérte a fájl végét."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> érték, amely megadja az aktuális olvasási/írási a fájl megnyitása."
  remarks: "A `Loc` függvény nulla alapú; használja a fájlban az első bájt beolvasása visszatér a 0.       A `Loc` függvény előző verziókkal való kompatibilitás, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       A következő szakasz ismerteti az eredményül kapott értéket a minden fájl hozzáférési mód: |||   |-|-|   | Mód |} Visszatérési érték |}   | `Random`| A legutóbbi rekordot írni vagy olvasni a fájlt. |}   | `Sequential`| A 128 osztva fájl aktuális bájt pozíciója. Azonban az adatokat által visszaadott `Loc` a szekvenciális fájlok használt sem szükséges. |}   | `Binary`| Az utolsó bájt nem írható és olvasható helyzete. |}"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> fájl számát."
    return:
      type: System.Int64
      description: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> érték, amely megadja az aktuális olvasási/írási a fájl megnyitása."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Record
      type: System.Int64
      description: "Nem kötelező. Az egyetlen számú rekordot vagy bezárni vagy kinyitni byte"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: FromRecord
      type: System.Int64
      description: "Nem kötelező. Az első rekord vagy bezárni vagy kinyitni byte száma."
    - id: ToRecord
      type: System.Int64
      description: "Nem kötelező. Az utolsó rekord vagy bezárni vagy kinyitni byte száma."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> használatával képviselő a mérete, a fájl megnyitása a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Használja a `FileLen` függvény egy nem megnyitott fájl hosszát beszerzése."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , amely tartalmazza egy érvényes számot."
    return:
      type: System.Int64
      description: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> használatával képviselő a mérete, a fájl megnyitása a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Létrehoz egy új könyvtárat. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Ez a funkció létrehoz egy új könyvtárat."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a könyvtár hozható létre kifejezés. A `Path` előfordulhat, hogy a meghajtó tartalmazza. Ha nincs meghajtó van megadva, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> hoz létre az új könyvtár az aktuális meghajtó."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>Nincs megadva, vagy üres."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Az engedély megtagadva."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Könyvtár már létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írás megjelenítési formázott adatok szekvenciális fájlba."
  remarks: "A `Print` és `PrintLine` funkciók a visszamenőleges kompatibilitás érdekében kapnak, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`nem tartalmaz egy sort; végén soremelés azonban `PrintLine` egy soremelés tartalmaz.       Az írt adatok `Print` általában olvasható fájlból használatával `LineInput` vagy `Input`.       Ha nincs megadva `Output` a `PrintLine`, egy üres sort, a fájl nyomtatása `Print`, semmi nem egy kimenet. Több kifejezések vesszővel elválasztva kell összhangba hozni lapon határokat, de keverési vesszővel válassza el egymástól, és `TAB` inkonzisztens eredményeket okozhat.       A `Boolean` adatok, vagy `True` vagy `False` nyomtatása. A `True` és `False` kulcsszavak le nem fordított, függetlenül a területi beállítás.       Dátum adatokat írni a fájlt a szabványos rövid dátumformátumra ismeri fel a rendszer használatával. A dátum vagy idő összetevőjének hiányzik vagy nulla, csak a része, feltéve ha a fájl írása.       Semmi íródik a fájlt, ha `Output` adatok értéke üres. Azonban ha `Output` lista adatok `DBNull`, `Null` a fájlba.       A `Error` adatok, az eredmény jelenik meg `Error errorcode`. A `Error` kulcsszó nem lefordítani a területi beállítás függetlenül.       A fájl használatával írt minden adat `Print` nemzetközi kompatibilis; Ez azt jelenti, hogy az adatok megfelelően van formázva a megfelelő tizedesjel használatával. Ha a felhasználó által a kimeneti adatok több nyelv, amelyet használhat `Write` kell használni.       Használatával a fájl írása a `Print` vagy `PrintLine` funkciók szükséges `Write` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Output
      type: System.Object[]
      description: "Nem kötelező. Nulla vagy több vesszővel tagolt kifejezések fájlba írni.       A `Output` argumentum értékei: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: fájl mód érvénytelen.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` nem létezik."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Írás megjelenítési formázott adatok szekvenciális fájlba."
  remarks: "A `Print` és `PrintLine` funkciók a visszamenőleges kompatibilitás érdekében kapnak, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`nem tartalmaz egy sort; végén soremelés azonban`PrintLine` egy soremelés tartalmaz.       Az írt adatok `Print` általában olvasható fájlból használatával `LineInput` vagy `Input`.       Ha nincs megadva `Output` a `PrintLine`, egy üres sort, a fájl nyomtatása `Print`, semmi nem egy kimenet. Több kifejezések vesszővel elválasztva kell összhangba hozni lapon határokat, de keverési vesszővel válassza el egymástól, és `TAB` inkonzisztens eredményeket okozhat.       A `Boolean` adatok, vagy `True` vagy `False` nyomtatása. A `True` és `False` kulcsszavak le nem fordított, függetlenül a területi beállítás.       Dátum adatokat írni a fájlt a szabványos rövid dátumformátumra ismeri fel a rendszer használatával. A dátum vagy idő összetevőjének hiányzik vagy nulla, csak a része, feltéve ha a fájl írása.       Semmi íródik a fájlt, ha `Output` adatok értéke üres. Azonban ha `Output` lista adatok `DBNull`, `Null` a fájlba.       A `Error` adatok, az eredmény jelenik meg `Error errorcode`. A `Error` kulcsszó nem lefordítani a területi beállítás függetlenül.       A fájl használatával írt minden adat `Print` nemzetközi kompatibilis; Ez azt jelenti, hogy az adatok megfelelően van formázva a megfelelő tizedesjel használatával. Ha a felhasználó által a kimeneti adatok több nyelv, amelyet használhat `Write` kell használni.       Használatával a fájl írása a `Print` vagy `PrintLine` funkciók szükséges `Write` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Output
      type: System.Object[]
      description: "Nem kötelező. Nulla vagy több vesszővel tagolt kifejezések fájlba írni.       A `Output` argumentum értékei: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: fájl mód érvénytelen.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` nem létezik."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Egy fájl vagy könyvtár átnevezése. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A`Rename` függvény átnevezi a fájlt, és áthelyezi másik címtárat, ha szükséges. A `Rename` függvény meghajtókon áthelyezheti egy fájlt, de csak a meglévő címtárhoz át lehet nevezni amikor mindkét `NewPath` és `OldPath` ugyanazon a meghajtón található. `Rename`nem hozható létre egy új fájl vagy könyvtár.       Használja a `Rename` függvény a nyitott fájlok hibát eredményez. Nyitott fájlok átnevezése előtt zárja be. `Rename`argumentum nem tartalmazhat több karaktert (*) és (?) karaktert helyettesítő karaktereket.      > [!IMPORTANT] > Használatakor `Rename` fájlt átmásolni egy nem védett helyre védett helyre, a fájl megőrzi a kisebb korlátozott jogok. Ellenőrizze, hogy győződjön meg arról, hogy nem vezetnek be lehetséges biztonsági kockázatnak tekint."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a meglévő nevét és helyét meghatározó kifejezés. `OldPath`a könyvtár, és a meghajtóra, a fájl tartalmazhat."
    - id: NewPath
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>Új fájl nevét és helyét meghatározó kifejezés. `NewPath`a rendeltetési hely meghajtót és tartalmazhatják. A megadott fájlnév `NewPath` már nem létezik."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Elérési út érvénytelen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>fájl nem létezik."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nem nevezhető át másik eszközt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Az összes lemezes a megnyitott fájlok bezárása a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Reset` függvény által megnyitott összes aktív fájlok bezárja a `FileOpen` funkciót, és rendelkezik a azonos funkciót `FileClose()` paraméter nélkül."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Eltávolít egy létező könyvtár. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "A hiba akkor fordul elő, ha próbálja használni a `RmDir` fájlokat tartalmazó könyvtárban. Használja a `Kill` függvény összes fájl törlésére, mielőtt újból könyvtár eltávolítása."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>az kifejezés, amely azonosítja a könyvtár vagy a mappa távolíthatók el. `Path`a meghajtó tartalmazhatnak. Ha nincs meghajtó van megadva, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> az aktuális meghajtó könyvtár eltávolítása."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>Nincs megadva, vagy üres."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Célkönyvtár fájlokat tartalmazza."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Könyvtár nem létezik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> használatával adja meg az aktuális olvasási/írási helyezi a fájlt megnyitni a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény, vagy beállítja azt a fájlban a következő olvasási/írási művelet a helyét nyitható meg a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`1 és 2 147 483 647 közötti értéket ad vissza (egyenértékű 2 ^ 31 – 1.), beleértve a határértékeket.       A következő szakasz ismerteti a minden fájl hozzáférési mód visszatérési értékei: |||   |-|-|   | Mód |} Visszatérési érték |}   | `Random`| A következő rekord olvasása vagy írása száma |}   | `Binary`, `Input`, `Output`, `Append`| Bájt pozícióját a következő művelet következik be. Egy fájlban az első bájt 1 pozícióban, a második bájtot, 2, és adott stb. |}"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , amely tartalmazza egy érvényes számot."
    return:
      type: System.Int64
      description: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> használatával adja meg az aktuális olvasási/írási helyezi a fájlt megnyitni a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény, vagy beállítja azt a fájlban a következő olvasási/írási művelet a helyét nyitható meg a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Értéket ad vissza egy <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> használatával adja meg az aktuális olvasási/írási helyezi a fájlt megnyitni a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény, vagy beállítja azt a fájlban a következő olvasási/írási művelet a helyét nyitható meg a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`1 és 2 147 483 647 közötti értéket ad vissza (egyenértékű 2 ^ 31 – 1.), beleértve a határértékeket.       A következő szakasz ismerteti a minden fájl hozzáférési mód visszatérési értékei: |||   |-|-|   | Mód |} Visszatérési érték |}   | `Random`| A következő rekord olvasása vagy írása száma |}   | `Binary`, `Input`, `Output`, `Append`| Bájt pozícióját a következő művelet következik be. Egy fájlban az első bájt 1 pozícióban, a második bájtot, 2, és adott stb. |}"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , amely tartalmazza egy érvényes számot."
    - id: Position
      type: System.Int64
      description: "Kötelező. A tartomány 1 – 2 147 483 647, a határokat is beleértve, szám, amely jelzi, ha a következő olvasási/írási műveletet kell végrehajtani."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Beállítja egy fájl attribútum. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az termelékenységét és a teljesítmény a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A futásidejű hiba akkor fordul elő, ha a nyitott fájlok attribútumainak beállítása.       A `Attributes` argumentum számbavételi értékek a következők: |||   |-|-|-|   | Érték |} Állandó |} Leírás |}   | `Normal`|`vbNormal`| (Alapértelmezett). |}   | `ReadOnly`|`vbReadOnly`| Csak olvasható. |}   | `Hidden`|`vbHidden`| Rejtett. |}   | `System`|`vbSystem`| Rendszerfájlt. |}   | `Volume`|`vbVolume`| Kötet címkéje |}   | `Directory`|`vbDirectory`| Könyvtárban vagy mappában. |}   | `Archive`|`vbArchive`| Utolsó biztonsági mentés óta módosult a fájl. |}   | `Alias`|`vbAlias`| A fájl rendelkezik egy másik nevet. |}      > [!NOTE] > Ezek enumerálások a Visual Basic nyelvi vannak megadva. A nevei bárhol használhatók a kódban a tényleges értékek helyett."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Kötelező. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>a fájl nevét meghatározó kifejezés. `PathName`tartalmazhatnak könyvtár vagy mappa, és a meghajtó."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Kötelező. Konstans- vagy numerikus kifejezés, amelynek összege határozza meg a fájl attribútumainak."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>a típus érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> függvény kimeneti helyezze."
  remarks: "Ha `Count` kisebb, mint a kimeneti vonalvastagság, azonnal a következő nyomtatási pozíció nyomtatott szóközök számát követi. Ha`Count` nagyobb, mint a kimeneti vonalvastagság `SPC` kiszámítja a képlet szerint a következő nyomtatási pozíció: `currentprintposition`(+ (`Count``Mod``width`)) például, ha az aktuális nyomtatási pozíció: 24, a kimeneti vonalvastagság 80-as, és megadva `SPC(`90`)`, a következő nyomtatás pozíciója (aktuális nyomtatási pozíció + a maradékot 90/80-as) 34 időpontban fog elindulni. Ha az aktuális nyomtatási pozíciót és a kimeneti vonalvastagság közötti különbség kisebb, mint `Count` (vagy `Count` `Mod` *szélesség*), a `SPC` függvény kihagyja a következő sor elejére, és állít elő, annál szóközöket `Count` – (*szélesség* – *currentprintposition*).      > [!NOTE] > Gondoskodjon arról, hogy a táblázatos oszlopok elég széles széles betűk lehetővé."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Kötelező. A szóközök megjelenítése, vagy a következő kifejezés listaként nyomtatás előtt száma."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> függvény kimeneti helyezze."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funkciók kimeneti helyezze."
  remarks: "Ha az aktuális nyomtatási pozíció az aktuális sor mérete nagyobb, mint `Column`, `TAB` ugrik az oszlop értéke, annál `Column` a következő kimeneti sorban. Ha `Column` kisebb, mint 1 `TAB` lép a nyomtatási. az 1. oszlop. Ha `Column` nagyobb, mint a kimeneti vonalvastagság `TAB` számítja ki a következő nyomtatási pozíció, a következő képlettel: oszlop Mod szélesség például, ha *szélessége* 80-as és adja meg `TAB(`90`)`, a következő nyomtatás oszlop 10 (a maradékot 90/80-as) időpontban fog elindulni. Ha `Column` kisebb, mint az aktuális nyomtatási pozíció, a kiszámított nyomtatási pozícióban a következő sorban nyomtatási elindul. Ha a számított nyomtatási pozíció nagyobb, mint az aktuális nyomtatási pozíció, nyomtatási kezdődik, és a számított pozíció ugyanazon nyomtassa ki.       A bal szélső nyomtatási pozíciójának egy kimeneti sor a következő mindig 1. Használatakor a `Print` vagy `PrintLine` funkciók fájl, nyomtatás nyomtatási jobb oldali pozícióját a kimeneti fájl, amely segítségével állíthatja be a jelenlegi szélessége a `FileWidth` függvény.       A `TAB` függvény is használható, a `WriteLine` függvény. Nem használható vagy <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Gondoskodjon arról, hogy a táblázatos oszlopok számos elég nagy betűket."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funkciók kimeneti helyezze."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funkciók kimeneti helyezze."
  remarks: "Ha az aktuális nyomtatási pozíció az aktuális sor érték nagyobb, mint `Column`, `TAB` ugrik az oszlop értéke, annál `Column` a következő kimeneti sorban. Ha `Column` kisebb, mint 1 `TAB` lép a nyomtatási. az 1. oszlop. Ha `Column` nagyobb, mint a kimeneti vonalvastagság `TAB` számítja ki a következő nyomtatási pozíció, a következő képlettel: oszlop Mod szélesség például, ha *szélessége* 80-as és adja meg `TAB(`90`)`, a következő nyomtatás oszlop 10 (a maradékot 90/80-as) időpontban fog elindulni. Ha `Column` kisebb, mint az aktuális nyomtatási pozíció, a kiszámított nyomtatási pozícióban a következő sorban nyomtatási elindul. Ha a számított nyomtatási pozíció nagyobb, mint az aktuális nyomtatási pozíció, nyomtatási kezdődik, és a számított pozíció ugyanazon nyomtassa ki.       A bal szélső nyomtatási pozíciójának egy kimeneti sor a következő mindig 1. Használatakor a `Print` vagy `PrintLine` funkciók fájl, nyomtatás nyomtatási jobb oldali pozícióját a kimeneti fájl, amely segítségével állíthatja be a jelenlegi szélessége a `FileWidth` függvény.       A `TAB` függvény is használható, a `WriteLine` függvény. Nem használható vagy <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName> <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Gondoskodjon arról, hogy a táblázatos oszlopok számos elég nagy betűket."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Nem kötelező. Az oszlop számát áthelyezése a megjelenítése, vagy a következő kifejezés listaként nyomtatás előtt. Ha nincs megadva, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> a kurzor átállítása a következő nyomtatási zóna."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Együtt a <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> vagy <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funkciók kimeneti helyezze."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: Record
      type: System.Int64
      description: "Nem kötelező. Az egyetlen számú rekordot vagy bezárni vagy kinyitni byte"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szabályozza a hozzáférést, más folyamatokkal való részben vagy egészben használatával megnyitott fájl által a <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> függvény. A <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funkció lehetővé teszi az jobb hatékonyságot és teljesítményének a fájl i/o-műveletek mint <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> és <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. További információkért lásd: <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "A `Lock` és `Unlock` funkciók környezetben használják ahol több folyamatok módosítania kell ugyanazt a fájlt a hozzáférést.       `Lock`és `Unlock` funkciók párok mindig szerepel. Az argumentumok `Lock` és `Unlock` azonosnak kell lennie.       Ha `Record`, vagy `FromRecord` és `ToRecord` vannak nincs megadva, a zárolás lesz a teljes fájlt. Ha `Record` különálló van megadva a egyetlen rekordot kell-e a zárolt vagy feloldott legyen.       Ha a fájl már megnyitották a szekvenciális bemenete vagy kimenete, `Lock` és `Unlock` befolyásolják a teljes fájlt, függetlenül a megadott tartomány `FromRecord` és`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Bármilyen érvényes szám."
    - id: FromRecord
      type: System.Int64
      description: "Nem kötelező. Az első rekord vagy bezárni vagy kinyitni byte száma."
    - id: ToRecord
      type: System.Int64
      description: "Nem kötelező. Az utolsó rekord vagy bezárni vagy kinyitni byte száma."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szekvenciális fájlba írja az adatokat. Az írt adatok <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> általában olvasható fájlból használatával <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "A `Write` és `WriteLine` funkciók a visszamenőleges kompatibilitás érdekében kapnak, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       Ha nincs megadva `Output`, egy üres sort a fájl nyomtatása. Több kifejezések vesszővel választhatók el egymástól.       Ellentétben a `Print` funkció, a `Write` függvény beszúrása vesszővel válassza el egymástól elemek és karakterláncokat idézőjelek között, a fájlt írás. Nincs explicit határolójelek elhelyezése a listában. Ha `Write` szolgál az adatok írása egy fájlt, csak numerikus `Boolean`, dátum, null, és `Error` adatok formátum támogatott. Így az mindig el tudják olvasni, és megfelelően értelmezi a használatával a következő univerzális feltételezéseket követi `Input`, függetlenül attól, területi beállítás:-numerikus adatokat mindig íródik a időszak használja, mint a tizedesjel.      -A `Boolean` adatok, vagy `#TRUE#` vagy `#FALSE#` nyomtatása. A `True` és `False` kulcsszavak le nem fordított, függetlenül attól, területi beállítás.      -Date adatot ír a fájl, a univerzális dátum formátum használatával. A dátum vagy idő összetevőjének hiányzik vagy nulla, csak a része, feltéve ha a fájl írása.      -Semmi íródik a fájlt, ha `Output` adatok értéke üres. Azonban a NULL értékű adatok `#NULL#` írása.      -A `Error` adatok, az eredmény jelenik meg `#ERROR errorcode#`. A `Error` kulcsszó nem lefordították, függetlenül attól, területi beállítás.       `WriteLine`soremelés karakter beszúrása (Ez azt jelenti, hogy a kocsivissza/üres sor hírcsatornát, vagy `Chr(13) + Chr(10)`), miután az utolsó karakterének írás `Output` a fájlhoz.       Beágyazása idézőjelek között egy karakterláncban a dupla idézőjelek között, vagy &quot;&quot;. Például [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] értékét egy karakterláncot ad vissza, `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Használatával a fájl írása a `Write` vagy `WriteLine` funkciók szükséges `Append` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> kifejezés, amely bármilyen érvényes fájl számát tartalmazza."
    - id: Output
      type: System.Object[]
      description: "Nem kötelező. Egy vagy több vesszővel tagolt kifejezések fájlba írni."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fájl mód érvénytelen."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Szekvenciális fájlba írja az adatokat. Az írt adatok <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> általában olvasható fájlból használatával <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "A `Write` és `WriteLine` funkciók a visszamenőleges kompatibilitás érdekében kapnak, és befolyásolhatja a teljesítményt. Nem örökölt alkalmazások esetén a `My.Computer.FileSystem` objektum jobb teljesítményt nyújt. További információkért lásd: [férhessen hozzá a fájlhoz a Visual Basic](~/add/includes/ajax-current-ext-md.md).       Ha nincs megadva `Output`, egy üres sort a fájl nyomtatása. Több kifejezések vesszővel választhatók el egymástól.       Ellentétben a `Print` funkció, a `Write` függvény beszúrása vesszővel válassza el egymástól elemek és karakterláncokat idézőjelek között, a fájlt írás. Nincs explicit határolójelek elhelyezése a listában. Ha `Write` szolgál az adatok írása egy fájlt, csak numerikus `Boolean`, dátum, null, és `Error` adatok formátum támogatott. Így az mindig el tudják olvasni, és megfelelően értelmezi a használatával a következő univerzális feltételezéseket követi `Input`, függetlenül attól, területi beállítás:-numerikus adatokat mindig íródik a időszak használja, mint a tizedesjel.      -A `Boolean` adatok, vagy `#TRUE#` vagy `#FALSE#` nyomtatása. A `True` és `False` kulcsszavak le nem fordított, függetlenül attól, területi beállítás.      -Date adatot ír a fájl, a univerzális dátum formátum használatával. A dátum vagy idő összetevőjének hiányzik vagy nulla, csak a része, feltéve ha a fájl írása.      -Semmi íródik a fájlt, ha `Output` adatok értéke üres. Azonban a NULL értékű adatok `#NULL#` írása.      -A `Error` adatok, az eredmény jelenik meg `#ERROR errorcode#`. A `Error` kulcsszó nem lefordították, függetlenül attól, területi beállítás.       `WriteLine`soremelés karakter beszúrása (Ez azt jelenti, hogy a kocsivissza/üres sor hírcsatornát, vagy `Chr(13) + Chr(10)`), miután az utolsó karakterének írás `Output` a fájlhoz.       Beágyazása idézőjelek között egy karakterláncban a dupla idézőjelek között, vagy &quot;&quot;. Például [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] értékét egy karakterláncot ad vissza, `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Használatával a fájl írása a `Write` vagy `WriteLine` funkciók szükséges `Append` elérje a `FileIOPermissionAccess` enumerálása. További információkért lásd: <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kötelező. Egy <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> kifejezés, amely bármilyen érvényes fájl számát tartalmazza."
    - id: Output
      type: System.Object[]
      description: "Nem kötelező. Egy vagy több vesszővel tagolt kifejezések fájlba írni."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
