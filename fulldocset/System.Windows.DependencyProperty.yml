### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "A tulajdonság esetében, mint módszerrel beállítható, stíluselemekkel, adatkötés, animáció és öröklési jelöli."
  remarks: "A DependencyProperty támogatja az alábbi képességek állnak a [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-a tulajdonság egy stílusban állítható be. További információkért lásd: [Stíluselemekkel és Templating](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság az adatkötés keresztül állítható be. Adatok kötési függőségi tulajdonságok kapcsolatos további információkért lásd: [hogyan: a két vezérlők tulajdonságok kötése](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság beállítható dinamikus erőforrás hivatkozással. További információkért lásd: [XAML erőforrások](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság örökölhet értéke automatikusan szülőelem elem fájában. További információkért lásd: [érték tulajdonságöröklés](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság animált is lehet. További információkért lásd: [animáció – áttekintés](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság is jelentés küldése, ha az előző érték a tulajdonság megváltozott, és a tulajdonság értékének is kényszeríthető. További információkért lásd: [függőség tulajdonság visszahívások és az érvényesítés](~/add/includes/ajax-current-ext-md.md).      -A tulajdonság jelentések információkat [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], például hogy egy tulajdonság értékének módosítása elvégzéséhez szükséges az elrendezés rendszer billentyűkombináció elem látványelemeket.      -A tulajdonság kap támogatást a [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Például a tulajdonság a szerkeszthető-e a **tulajdonságok** ablak.       A függőségi tulajdonságok kapcsolatos további információkért lásd: [függőségi tulajdonságok áttekintése](~/add/includes/ajax-current-ext-md.md). Ha az egyéni típusokon támogatásához a lehetőségeket a fenti listán szereplő tulajdonságok, egy függőségi tulajdonság kell létrehoznia.  Egyéni függőségi tulajdonságok létrehozásával kapcsolatban lásd: [egyéni függőségi tulajdonságok](~/add/includes/ajax-current-ext-md.md).       Egy csatolt tulajdonság egy tulajdonság, amely lehetővé teszi a jelentések adatainak határozza meg a csatolt tulajdonság típusának bármely objektum. A [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], örököl típussal <xref:System.Windows.DependencyObject>egy csatolt tulajdonság, függetlenül attól, hogy a típus, amely meghatározza a tulajdonság típusát örököl.</xref:System.Windows.DependencyObject> Egy csatolt tulajdonság csak a a [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] nyelv.  Egy csatolt tulajdonság beállításához [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], használja a *ownerType*.* a propertyName* szintaxist. Példa egy csatolt tulajdonság a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>tulajdonság.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Ha egy tulajdonság, amely használható a létrehozni kívánt <xref:System.Windows.DependencyObject>típusokat, akkor létre kell hoznia egy csatolt tulajdonság.</xref:System.Windows.DependencyObject> További információt a csatolt tulajdonságok figyeléséről, hozza létre a címzetteket, lásd: [csatolt tulajdonságok áttekintése](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a>## XAML attribútumok használata ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> ## XAML értékek `dependencyPropertyName` karakterlánc, amely meghatározza a <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>a kívánt függőségi tulajdonság.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       Ez is szerepelnie egy XML-névtérelőtag Ha tulajdonság nem szerepel az alapértelmezett XML-névtérhez (további információkért lásd: [XAML-névterek és -Namespace leképezése WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    A függőség tulajdonság, egy pontot (.), majd a <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> tulajdonos típusú meghatározó karakterlánc `ownerType`is is megelőzi egy XML-névtérelőtag. A használati adott késői kötésű stílusok és sablonok, ahol a függőség tulajdonság tulajdonosának meg kell adni, a elemzése a környezetben, mert a `TargetType` még nem ismert. További információkért lásd: [Stíluselemekkel és Templating](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Egy olyan karakterlánc, amely meghatározza egy csatolt tulajdonság, egy pontot (.), majd a csatolt tulajdonság neve tulajdonosa. `attachedPropertyOwnerType`is is megelőzi egy XML-névtérelőtag."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hozzáadja a más típusú tulajdonos egyik függőség tulajdonság már regisztrálva van."
  remarks: "Ez a módszer lehetővé teszi, hogy a tulajdonság rendszer ismeri fel a függőség tulajdonság egy típus, amely nem igazolta, hogy az adott függőségi tulajdonság kezdetben.       Általában AddOwner függőségi tulajdonságok hozzáadása, amely már nem teszik ki adott függőségi tulajdonság felügyelt osztály örökléssel osztályok használatos (osztályöröklődést okozna a származtatott osztály örökli a burkoló tulajdonságait, és így lenne általános tagok-tábla hozzáférést biztosítanak a függőség tulajdonság már). AddOwner lehetővé teszi, hogy a tulajdonság rendszer olyan típusú, amely nem igazolta, hogy függőség tulajdonság kezdetben a ismeri fel a függőség tulajdonság.       Az aláírás nem engedélyezi a metaadatokat megadó.  Ha ezt a módszert használja, a metaadatok automatikusan létrejön az új <xref:System.Windows.DependencyProperty>és a tulajdonos típus.</xref:System.Windows.DependencyProperty> Az automatikusan létrehozott metaadatai nem az összes definiált-e tulajdonsággal rendelkező alaptípusában egyesített metaadatok eredményét. Ha nincsenek egyesített metaadatok érhető el, a tulajdonság alapértelmezett metaadatainak szolgál. Ha a tulajdonság használatával van regisztrálva a <xref:System.Windows.DependencyProperty.RegisterAttached%2A>módszer, majd az alapértelmezett metaadatok megegyezik a metaadatokat, amelyek jön létre, amikor <xref:System.Windows.DependencyProperty.RegisterAttached%2A>lett meghívva.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> Ellenkező esetben a <xref:System.Windows.PropertyMetadata>objektum jön létre a <xref:System.Windows.PropertyMetadata.DefaultValue%2A>tulajdonságának beállítása a tulajdonság típusa alapértelmezett és minden egyéb tulajdonságait a <xref:System.Windows.PropertyMetadata>értéke `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Használja a <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>aláírás, ha lehetővé szeretné tenni a függőség tulajdonság verziójának metaadatok, megegyezik a megadott típushoz.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Ez a metódus visszatérési értéke általában segítségével deklarálhatja, és tegye elérhetővé a függőség tulajdonság függőségi tulajdonságazonosító elhelyezésével. Az azonosító a függőség tulajdonság hozzáférést biztosít, ha felhívja a tulajdonság rendszer [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] szemben a függőség tulajdonság, különösen, mert létezik a felvenni a tulajdonos osztály. Az eredeti tulajdonos és a hozzáadott tulajdonos tulajdonságnév használatával jelezheti a hasonló funkciókat. Használjon a <xref:System.Windows.DependencyProperty>visszatérési érték a AddOwner módszer meghatározásához a függőség tulajdonság azonosítója és deklarálnia [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tulajdonság csomagolást függőségi tulajdonságok AddOwner használó hozzáadott.</xref:System.Windows.DependencyProperty>       Az ajánlott AddOwner módszer létrehozásához használható a függőségi tulajdonságok belül deklarált [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Például mindkét <xref:System.Windows.Controls.Border>és <xref:System.Windows.Controls.Control>megadása egy `BorderBrush` függőség tulajdonság, amely hasonló funkciót látja el.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Meghatározza a `BorderBrush` a tulajdonság rendszer AddOwner meghívásával tulajdonságot az eredeti tulajdonost alapján <xref:System.Windows.Controls.Border>és a regisztrált <xref:System.Windows.Controls.Border.BorderBrushProperty>függőség tulajdonság azonosítóját.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> A AddOwner visszatérési érték majd létrehozására szolgál egy új statikus <xref:System.Windows.DependencyProperty>mező (<xref:System.Windows.Controls.Control.BorderBrushProperty>) az adott tulajdonságnál a hozzáadott tulajdonosa, és egy `BorderBrush` tulajdonság burkoló deklarálva van.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Adja hozzá a függőség tulajdonság tulajdonos típusa."
    return:
      type: System.Windows.DependencyProperty
      description: "Az eredeti mutató hivatkozás <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> , amely azonosítja a függőség tulajdonság azonosítója. Ez az azonosító a kell felvenni a osztályhoz tartozik, mint által elérhetővé tett egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Ad hozzá egy másik típus már regisztrálva van a függőség tulajdonság tulajdonos, – a függőség tulajdonság metaadata a függőség tulajdonság, akkor lesznek megtalálhatók, a megadott tulajdonos típusát."
  remarks: "Ez a módszer lehetővé teszi, hogy a tulajdonság rendszer ismeri fel a függőség tulajdonság egy típus, amely nem igazolta, hogy az adott függőségi tulajdonság kezdetben.       Ez a metódus visszatérési értéke szolgál a deklarál, és tegye elérhetővé a függőség tulajdonság különösen megtalálható a felvétele a tulajdonos osztály. Általában a eredeti tulajdonosa és a hozzáadott tulajdonos tulajdonságnév használatával jelzi a hasonló funkciókat. Jó gyakorlat tenni azonosítók, valamint új [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tulajdonság csomagolást <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A> használatával típusok hozzáadott függőségi tulajdonságok       A <xref:System.Windows.DependencyProperty.AddOwner%2A>ajánlott módszer létrehozásához használható [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] található [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Például mindkét <xref:System.Windows.Controls.Border>és <xref:System.Windows.Controls.Control>megadása egy `BorderBrush` függőség tulajdonság, amely hasonló funkciót látja el.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Meghatározza a `BorderBrush` tulajdonság a tulajdonság rendszer meghívásával <xref:System.Windows.DependencyProperty.AddOwner%2A>az eredeti tulajdonost <xref:System.Windows.Controls.Border>és a regisztrált <xref:System.Windows.Controls.Border.BorderBrushProperty>függőség tulajdonság azonosítóját.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> A <xref:System.Windows.DependencyProperty.AddOwner%2A>visszatérési érték majd létrehozására szolgál a statikus <xref:System.Windows.DependencyProperty>mező (<xref:System.Windows.Controls.Control.BorderBrushProperty>) az adott tulajdonságnál a hozzáadott tulajdonosa, és egy `BorderBrush` tulajdonság burkoló deklarálva van.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       A hozzáadott tulajdonos függőségi tulajdonságazonosító műveletek, például a <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> használható Azonban típusok vagy a tulajdonos különböző metaadatokkal végez, továbbra is fel lett osztály példányai érintő típusra vonatkozó műveletek térjen vissza a várt eredményt, még akkor is, ha az eredeti (nem a hozzáadott tulajdonosának) az például <xref:System.Windows.DependencyObject.GetValue%2A>vagy <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> metódusok megadott függőségi tulajdonságazonosító érvénytelen A metaadatok a hozzáadott tulajdonosa által a AddOwner van perpetuated hívhatja saját magát, nem feltétlenül hivatkozik kizárólag a tulajdonos osztály azonosítója mező hozzáadásakor. Ennek ellenére ajánlott teszi közzé az azonosítót, valamint új [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] tulajdonság csomagolást függőségi tulajdonságok hozzáadott használó AddOwner, mert ha ezt elmulasztja, közötti különbség a [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] és [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] a Tulajdonságok ábrázolásai.       A megadott metaadatok egyesített a tulajdonság metaadata a függőségi tulajdonság esetében, mert az alap tulajdonosa létezik. Minden jellemző, amelyek meg lettek adva a eredeti alapmetaadatoknak egészen addig megmarad. Csak a kifejezetten az új metaadatokkal módosított jellemzők felül fogja írni a alapmetaadatoknak jellemzőit. Bizonyos jellemzőkkel rendelkezik, mint például <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, váltják, ha az új metaadatok vannak megadva.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Mások, mint például <xref:System.Windows.PropertyChangedCallback>, a rendszer kombinálja.</xref:System.Windows.PropertyChangedCallback> Végső soron az egyesítési viselkedés attól függ, az itt leírt a rendszer nem a meglévő tulajdonság metaadatainak osztályok által használt a felülbíráláshoz használt metaadatok tulajdonságtípus [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] függőségi tulajdonságok. További információkért lásd: [függőség tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md) és [keretrendszer tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "A típus a függőség tulajdonság tulajdonosa hozzá."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A metaadatok, amely megfelel a függőség tulajdonság, mert a megadott típus létezik."
    return:
      type: System.Windows.DependencyProperty
      description: "Az eredeti mutató hivatkozás <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> , amely azonosítja a függőség tulajdonság azonosítója. Ez az azonosító a kell felvenni a osztályhoz tartozik, mint által elérhetővé tett egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a függőség tulajdonság alapértelmezett metaadatait."
  remarks: "Az alapértelmezett metaadatai nem érhető el az adott objektum vagy egy származtatott típusú objektum nem alternatív metaadatok explicit által biztosított ahol tulajdonság metaadatok <xref:System.Windows.DependencyProperty.Register%2A>vagy <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>hívása.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Ha az eredeti tulajdonost metaadatok vonatkozik. az első <xref:System.Windows.DependencyProperty.Register%2A>hívás, amely a függőség tulajdonság létrehozva, majd, hogy metaadatai DefaultMetadata adja vissza a rendszer.</xref:System.Windows.DependencyProperty.Register%2A>       Ha nincsenek metaadatok volt alkalmazva az eredeti <xref:System.Windows.DependencyProperty.Register%2A>hívja, akkor az alapértelmezett metaadatok belül jön létre a <xref:System.Windows.DependencyProperty.Register%2A>hívás, és ezt az értéket adja vissza a rendszer a DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       A fő célja, hogy a társított alapértelmezett metaadatokat egy <xref:System.Windows.DependencyProperty>ezt a tulajdonságot, egy alapértelmezett értéket annak <xref:System.Windows.DependencyObject>vagy egy származtatott típus.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       Nonattached tulajdonságok esetén ez a tulajdonság által visszaadott metaadatok típus nem konvertálható származtatott típusú <xref:System.Windows.PropertyMetadata>Írja be, akkor is, ha a tulajdonság eredetileg egy származtatott metaadattípus való regisztrációja.</xref:System.Windows.PropertyMetadata> Ha azt szeretné, hogy a eredetileg regisztrált metaadatok, többek között az eredeti valószínűleg származtatott metaadattípus, <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>ehelyett paraméterként átadja az eredeti regisztrálása írja.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       A csatolt tulajdonságok a tulajdonság által visszaadott metaadatok típusú fog egyezni az eredeti megadott típus <xref:System.Windows.DependencyProperty.RegisterAttached%2A>regisztrációs eljárását.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság alapértelmezett metaadatait."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy kivonatoló kódot ad vissza a <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "A tulajdonság rendszer saját egyedi azonosítót használ <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, és ez a tulajdonság értékének GetHashCode ad vissza.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Ehhez a kivonatoló kódot <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Visszaadja a metaadatok a függőség tulajdonság, mert a megadott meglévő típus létezik."
  remarks: "Adja meg a típus vagy a objektumhivatkozást használatára, mert a típus szükség, mert a metaadatok eltérhetnek az eredeti regisztráció miatt közül csak az egyiket <xref:System.Windows.DependencyProperty.AddOwner%2A>vagy <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>a függőség tulajdonság metaadatainak módosítható, mert létezik egy típus hívások.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "A függőség tulajdonság metaadatok lekérése céljából, amelyből típusát."
    return:
      type: System.Windows.PropertyMetadata
      description: "Egy tulajdonság metaadat-objektum."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A metaadatokat, a függőség tulajdonság adja vissza, a megadott objektum példányán található."
  remarks: "Adja meg a típus vagy a objektumhivatkozást szükség, mert a metaadatok bármely adott függőségi tulajdonság változnak az eredeti regisztráció miatt közül csak az egyiket <xref:System.Windows.DependencyProperty.AddOwner%2A>vagy <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>pontosíthatja a tulajdonság metaadatai, mert létezik egy típus hívások.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Amikor egy példány tulajdonság metaadatok kér le, csupán átadott a példány, hogy a típus belső kiértékelése. Függőség tulajdonság metaadata nem változnak az egy példány; a rendszer mindig konzisztens bármely adott zónatípusokkal kombinációjához."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "A függőségi objektum, amely be van jelölve típushoz a metaadatok a függőség tulajdonság típusra vonatkozó verziójának kell származnia meghatározásához."
    return:
      type: System.Windows.PropertyMetadata
      description: "Egy tulajdonság metaadat-objektum."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A metaadatokat, a függőség tulajdonság adja vissza, mert a megadott típus létezik."
  remarks: "Adja meg a típus vagy a objektumhivatkozást szükség, mert a metaadatok bármely adott függőségi tulajdonság változnak az eredeti regisztráció miatt közül csak az egyiket <xref:System.Windows.DependencyProperty.AddOwner%2A>vagy <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>pontosíthatja a tulajdonság metaadatai, mert létezik egy típus hívások.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Egy adott objektum, amely rögzíti a függőségi objektumtípus, amelyből a függőség tulajdonság metaadatai van szükség."
    return:
      type: System.Windows.PropertyMetadata
      description: "Egy tulajdonság metaadat-objektum."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi egy belsőleg generált érték, amely egyedileg azonosítja a függőség tulajdonság."
  remarks: "Az érték egész szám, nem egy [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. Általában index érték nincs szükség, és nem az összes függőség tulajdonság táblák index hozzáférés. Függőségi tulajdonságok helyette az azonosító mező szerint lehet hivatkozni.       GlobalIndex belső használatra készült a nulla alapú tömbindex a GlobalIndex alkalmazzon adatstruktúrák gyorsabb hozzáférést. Előfordulhat, hogy a hasonló használat alkalmazások tervezők vagy eszközök."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Egyedi azonosítószáma."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Meghatározza, hogy egy megadott értéket a függőség tulajdonság típus elfogadható szerint be van jelölve az eredeti tulajdonság regisztrációjának megadott típus alapján."
  remarks: "Érték `null` referencia típus függőségi tulajdonságok, illetve a érvényes típus a <xref:System.Nullable%601>függőség tulajdonság, és alakítanák vissza `true` ezekben az esetekben a.</xref:System.Nullable%601> Azokban az esetekben, ahol a függőség tulajdonság sem hivatkozik, sem a <xref:System.Nullable%601>IsValidType típust ad vissza `false` rhető kivétel helyett egy null értékű.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Az érték kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a megadott érték az regisztrált tulajdonság vagy egy elfogadható származtatott típusú; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Meghatározza, hogy a megadott érték fogadja el a rendszer ellenőrzése az alapszintű és a tulajdonság típusát és potenciálisan is, ha az adott érték a megengedett tartományon belül van."
  remarks: "A függőségi tulajdonság esetében egy adott típusú értékek engedélyezett tartományán keresztül megadott egy <xref:System.Windows.ValidateValueCallback>, amely megtalálható a függőség tulajdonság regisztrációs.</xref:System.Windows.ValidateValueCallback>       Ez a metódus meghívja <xref:System.Windows.DependencyProperty.IsValidType%2A>belsőleg.</xref:System.Windows.DependencyProperty.IsValidType%2A> Ha az adott függőségi tulajdonság nincs <xref:System.Windows.ValidateValueCallback>majd a metódus hívása megegyezik hatékonyan <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> hívása</xref:System.Windows.ValidateValueCallback> Ha a függőség tulajdonság rendelkezik egy <xref:System.Windows.ValidateValueCallback>, és ha <xref:System.Windows.DependencyProperty.IsValidType%2A>vissza kellett volna `true`, visszatérési érték lesz a visszahívás-ben megvalósuló.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Null értékű érték érvényes referencia típus függőségi tulajdonságok, illetve a egy <xref:System.Nullable%601>függőség tulajdonság, és alakítanák vissza `true` ezekben az esetekben a.</xref:System.Nullable%601> Azokban az esetekben, ahol a függőség tulajdonság sem hivatkozik, sem a <xref:System.Nullable%601>típusa, <xref:System.Windows.DependencyProperty.IsValidType%2A>visszaadható `false` rhető kivétel helyett egy null értékű.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Az érték kereséséhez."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az érték elfogadható, és a megfelelő típusú vagy származtatott típusnak; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a függőség tulajdonság nevét."
  remarks: "Ez a tulajdonság lekérdezi a megadott név a `name` paraméter függőség tulajdonság regisztrálás során. Ez a név nem módosítható, és nem lehet `null` vagy üres karakterlánc. Ismétlődő regisztrációk ugyanabban tulajdonosi típus nem engedélyezett, és fog kivételt jelez, amikor megpróbálja regisztrálni az ismétlődő.      > [!IMPORTANT] > A függőség tulajdonság neve a függőség tulajdonság azonosítója csökkentve a utótagja &quot;Property&quot; névnek megfelelő az egyezmény kell követnie. További információkért lásd: [egyéni függőségi tulajdonságok](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "A tulajdonság nevét."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Megadja az alternatív metaadatok a függőség tulajdonság, ha megtalálható a metaadatokat, amelyek léteztek a függőségi tulajdonság esetében alaptípusában öröklődött, felülírva, a megadott típusú példányok."
  remarks: "A tulajdonság rendszert használó a függőség tulajdonság előtt felül kell bírálni a függőség tulajdonság metaadatai. Ez megfelel a időt, amely olyan specifikus példányai, amely a függőség tulajdonság regisztrálja az osztály használatával hozhatók létre. OverrideMetadata hívások csak belül a statikus konstruktorok magát, mint a biztosító típusú hajtható végre a `forType` paraméter ezt a módszert, vagy hasonló példánylétrehozás keresztül. Kísérlet a metaadatok módosítása után a tulajdonos típusú példányban található nem emeli kivételek, de a tulajdonság rendszerben inkonzisztens viselkedések eredményez.       Ez a metódus egy adott származtatott osztály felülbírálás metaadatok létrejötte után felülbírálásához metaadatainak Ez ugyanaz a származtatott osztály az ezt követő kísérletek emeli kivételt.       A megadott metaadatok egyesített a tulajdonság metaadata a függőségi tulajdonság esetében, mert az alap tulajdonosa létezik. Minden jellemző, amelyek meg lettek adva a eredeti alapmetaadatoknak egészen addig megmarad; csak a kifejezetten az új metaadatokkal módosított jellemzők felül fogja írni a alapmetaadatoknak jellemzőit. Például bizonyos jellemzők <xref:System.Windows.PropertyMetadata.DefaultValue%2A>váltják, ha meg van adva az új metaadatokkal.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Mások, mint például <xref:System.Windows.PropertyChangedCallback>, a rendszer kombinálja.</xref:System.Windows.PropertyChangedCallback> Végső soron az egyesítési viselkedés attól függ, az itt leírt a rendszer nem a meglévő tulajdonság metaadatainak osztályok által használt a felülbíráláshoz használt metaadatok tulajdonságtípus [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] függőségi tulajdonságok. További információkért lásd: [függőség tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md) és [keretrendszer tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "A típus, ahol a függőség tulajdonság öröklődik, és ha a megadott alternatív metaadatok lesz alkalmazva."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A metaadatok a függőség tulajdonság felülbíráló típus alkalmazandó."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kísérlet történt egy csak olvasható függőség tulajdonság metaadatainak felülírására (művelet nem hajtható végre az aláírás használatával)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Metaadatok már létrejött a függőségi tulajdonság esetében, mert a megadott típus létezik."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Készletek alternatív metaadatok egy csak olvasható függőségi tulajdonság esetében, ha felülbírálja a metaadatokat, amelyek a kezdeti regisztrációjának tulajdonság lett megadva, a megadott típusú példányok jelen. Át kell adnia a <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> kivételt elkerülése érdekében a csak olvasható függőségi tulajdonság esetében."
  remarks: "Az aláírás biztosítja a csak olvasható függőségi tulajdonságazonosító az alapul szolgáló implementáció (<xref:System.Windows.DependencyPropertyKey>) metódus.</xref:System.Windows.DependencyPropertyKey> Felülbírálja a metaadatokat egy írható-olvasható függőségi tulajdonság esetében, ha <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> használata       A tulajdonság rendszert használó a függőség tulajdonság előtt felül kell bírálni a függőség tulajdonság metaadatai. Ez megfelel a függőség tulajdonság regisztrálja osztály adott objektumok létrehozásakor idő. Hívások <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>csak végezhető belül a statikus konstruktorok a típusú, amelynek biztosít, mint maga a `forType` paraméter ezt a módszert, vagy hasonló példánylétrehozás keresztül.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Kísérlet a metaadatok módosítása után a tulajdonos típusú példányban található nem emeli kivételek, de a tulajdonság rendszerben inkonzisztens viselkedések eredményez.       Ez a metódus egy adott származtatott osztály felülbírálás metaadatok létrejötte után felülbírálásához metaadatainak Ez ugyanaz a származtatott osztály az ezt követő kísérletek emeli kivételt.       A megadott metaadatok egyesített a tulajdonság metaadata a függőségi tulajdonság esetében, mert az alap tulajdonosa létezik. Minden jellemző, amelyek meg lettek adva a eredeti alapmetaadatoknak egészen addig megmarad; csak a kifejezetten az új metaadatokkal módosított jellemzők felül fogja írni a alapmetaadatoknak jellemzőit. Például bizonyos jellemzők <xref:System.Windows.PropertyMetadata.DefaultValue%2A>váltják, ha meg van adva az új metaadatokkal.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Mások, mint például <xref:System.Windows.PropertyChangedCallback>, a rendszer kombinálja.</xref:System.Windows.PropertyChangedCallback> Az egyesítés viselkedés attól függ, hogy a tulajdonság metaadattípus a felülbíráláshoz használja. További információkért lásd: [függőség tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md) és [keretrendszer tulajdonság metaadatai](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "A típus, ahol a függőség tulajdonság öröklődik, és ha a megadott alternatív metaadatok lesz alkalmazva."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A metaadatok a függőség tulajdonság felülbíráló típus alkalmazandó."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "A hozzáférési kulcsot a következő egy csak olvasható függőség tulajdonság."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a függőség tulajdonság a tulajdonság rendszerben regisztrált, vagy fel van véve maga a tulajdonság tulajdonos objektum típusa."
  remarks: "Ez az érték a tulajdonság regisztrálás során lett megadva. A tulajdonos vagy az eredeti regisztrálásakor típust a következőket fogja a <xref:System.Windows.DependencyProperty>azonosítója alapján generált egy <xref:System.Windows.DependencyProperty.Register%2A>hívás vagy a típus, amely fel van véve maga a tulajdonos egy <xref:System.Windows.DependencyProperty>azonosítója alapján generált egy <xref:System.Windows.DependencyProperty.AddOwner%2A>hívása.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       A megadott OwnerType <xref:System.Windows.DependencyProperty>nem módosítható, és nem lehet `null` a egy érvényes <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "A tulajdonság regisztrálva, vagy fel van véve maga a tulajdonság tulajdonos objektum típusa."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Lekérdezi a típus, amely a függőség tulajdonság értéke használ."
  remarks: "Ez a tulajdonság jelzi a tulajdonság értékének használatával az eredeti regisztráció tulajdonság által megadott típus a `propertyType` paraméter. Hasonló a <xref:System.Windows.DependencyProperty.Name%2A>, regisztráció után a tulajdonság típusa a függőség tulajdonság nem módosítható.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>a tulajdonság értékének.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Egy érték, amely azt jelzi, hogy a függőség tulajdonság által azonosított lekérdezi <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> példány egy csak olvasható függőség tulajdonság."
  remarks: "Csak olvasható függőségi tulajdonságok meghívásával a tulajdonság rendszerben regisztrált a <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>metódus helyett a <xref:System.Windows.DependencyProperty.Register%2A>metódus.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Csatolt tulajdonságok is lehet regisztrálni írásvédett; Lásd: <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Csak olvasható függőségi tulajdonságok szükséges egy <xref:System.Windows.DependencyPropertyKey>azonosító helyett egy <xref:System.Windows.DependencyProperty>azonosító használatával végezhet metaadat-feladatokat, például a metaadatok felülbírálása vagy értékre állítja.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Ha beszerezte a gyűjteménye <xref:System.Windows.DependencyProperty>azonosítók keresztül hívása <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>vagy egy másik [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] azonosítók mutatja meg, amely, ellenőrizze a csak olvasható érték hívása előtt <xref:System.Windows.DependencyObject.SetValue%2A>vagy <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>segítségével adott függőségi tulajdonság azonosítót bemeneti paraméterként, győződjön meg arról, hogy a függőség tulajdonság, amely jelöli az azonosító nem csak olvasható.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Csak olvasható érték esetén `true` nincs semmilyen programozott módon mutató hivatkozás beszerzése egy függőség tulajdonság a <xref:System.Windows.DependencyPropertyKey>függőség tulajdonság, a metaadatok vagy az azonosító a <xref:System.Windows.DependencyProperty>azonosító; azonosító hívni egy statikus mezőben elérhetőnek kell lennie <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>egy csak olvasható függőség tulajdonság ellen.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       Hozzon létre egy egyéni függőség tulajdonság, és regisztrálhatja azt csak olvashatóként, csak a &quot;get&quot; elérő a érdemes definiálni a [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] burkoló tulajdonság. Ellenkező esetben az osztály a tulajdonság burkoló képest a hozzáférést a biztonsági függőség tulajdonság zavaró hálózatiobjektum-modellje fog rendelkezni. További információkért lásd: [egyéni függőségi tulajdonságok](~/add/includes/ajax-current-ext-md.md) vagy [csak olvasási jogosultsággal rendelkező függőségi tulajdonságok](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a függőség tulajdonság csak olvasható; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a függőség tulajdonság a megadott tulajdonság nevét, a tulajdonság típusát és a tulajdonos típusa."
  remarks: "A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve. A név a tulajdonos típusa a regisztrációs névtéren belül egyedinek kell lennie."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a függőség tulajdonság a megadott tulajdonságnév, a tulajdonság típusa, a tulajdonos típusa és a tulajdonság metaadatai."
  remarks: "A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a függőség tulajdonság a megadott tulajdonságnév, tulajdonságtípus, tulajdonostípusa, tulajdonság metaadatok és a tulajdonság értékének érvényesítési visszahívását."
  remarks: "A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Egy visszahívást, amelyet végre kell hajtania a függőség tulajdonság értékének tipikus típus érvényesítése túl bármilyen egyéni érvényesítési mutató hivatkozás."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A megadott tulajdonság nevét, a tulajdonság típusát és a tulajdonos típusa regisztrálja egy csatolt tulajdonság."
  remarks: "Egy csatolt tulajdonság fogalma tulajdonság által megadott [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]megvalósítja csatolt tulajdonságainak függőségi tulajdonságként. Mivel a [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] csatolt tulajdonságok függőségi tulajdonságok, rendelkezhetnek metaadatok alkalmazott műveleteket, például reporting elrendezés jellemzőkkel az általános tulajdonság rendszer használható. További információkért lásd: [csatolt tulajdonságok áttekintése](~/add/includes/ajax-current-ext-md.md).       A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a csatolt tulajdonság a megadott tulajdonságnév, a tulajdonság típusa, a tulajdonos típusa és a tulajdonság metaadatai."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai. Ez magában foglalhatja az alapértelmezett érték, valamint az egyéb jellemzőket is."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A megadott tulajdonságtípusnak, a tulajdonos típusa, a tulajdonság metaadatai és a érvényesítési visszahívási érték a tulajdonság egy csatolt tulajdonság regisztrálja."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai. Ez magában foglalhatja az alapértelmezett érték, valamint az egyéb jellemzőket is."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Egy visszahívást, amelyet végre kell hajtania a függőség tulajdonság értékének tipikus típus érvényesítése túl bármilyen egyéni érvényesítési mutató hivatkozás."
    return:
      type: System.Windows.DependencyProperty
      description: "A függőség tulajdonság azonosítója, amelynek használatával állítsa be a egy <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> mező mellett az osztályhoz. Ilyen azonosítójú ezután a függőség tulajdonság, később hivatkozhasson rá az érték beállítása programozott módon, vagy megszerezni a metaadatokat hasonló műveletek segítségével történik."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a csak olvasható csatolt tulajdonság a megadott tulajdonságtípusnak, a tulajdonos típusa és a tulajdonság metaadatai."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "A függőség tulajdonság kulcs, amelynek használatával a osztály, amely majd később hivatkozhasson rá a függőség tulajdonság statikus, csak olvasható mező értékének beállítása."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a csak olvasható csatolt tulajdonság a megadott tulajdonságtípusnak, a tulajdonos típusa, a tulajdonság metaadatai és a egy érvényesítési visszahívás."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Egy felhasználó által létrehozott visszahívást, amelyet végre kell hajtania a függőség tulajdonság értékének tipikus típus érvényesítése túl bármilyen egyéni érvényesítési mutató hivatkozás."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "A függőség tulajdonság kulcs, amelynek használatával a osztályban, amit a hivatkozást a függőség tulajdonság statikus, csak olvasható mező értékének beállítása."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a csak olvasható függőség tulajdonság a megadott tulajdonságtípusnak, a tulajdonos típusa és a tulajdonság metaadatai."
  remarks: "Ez a módszer a típust ad vissza <xref:System.Windows.DependencyPropertyKey>, mivel <xref:System.Windows.DependencyProperty.RegisterAttached%2A> <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> típusát adja vissza</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Általában a kulcsait csak olvasható tulajdonságok nem válnak, nyilvános, mert a kulcsok segítségével <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> meghívásával függőség tulajdonság értékének beállítása Az osztály kialakítás befolyásolja, a követelményeknek, de általában javasoljuk, hogy korlátozza a hozzáférést és látható-e bármely <xref:System.Windows.DependencyPropertyKey>csak részei a kódot az osztály vagy az alkalmazás logikája adott függőségi tulajdonság beállításához szükséges.</xref:System.Windows.DependencyPropertyKey> Javasolt továbbá, hogy jelentkezik, mintha értékének teszi közzé a függőség tulajdonság azonosítót az írásvédett függőségi tulajdonság esetében <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>, egy `public static readonly` található az osztály</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Csak olvasható függőségi tulajdonságok a viszonylag tipikus esetén is a meglévő [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] és testreszabási forgatókönyvek, mert más [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] szolgáltatásokhoz is szükség lehet a függőség tulajdonság akkor is, ha az adott tulajdonság nem készült állítható be kell hívóknak. Használhatja a csak olvasható függőség tulajdonság értékének alapjául a többi tulajdonság rendszer művelet, amelyek a függőség tulajdonság, például a sablon egy <xref:System.Windows.Trigger>függőség tulajdonság egy stílusban.</xref:System.Windows.Trigger>       A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "A függőség tulajdonság kulcs, amelynek használatával a osztályban, amit a hivatkozást a függőség tulajdonság statikus, csak olvasható mező értékének beállítása."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regisztrálja a csak olvasható függőség tulajdonság a megadott tulajdonságtípusnak, a tulajdonos típusa, a tulajdonság metaadatai és a egy érvényesítési visszahívás."
  remarks: "Ez a módszer a típust ad vissza <xref:System.Windows.DependencyPropertyKey>, mivel <xref:System.Windows.DependencyProperty.RegisterAttached%2A> <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> típusát adja vissza</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Általában a kulcsait csak olvasható tulajdonságok nem válnak, nyilvános, mert a kulcsok segítségével <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> meghívásával függőség tulajdonság értékének beállítása Az osztály kialakítás befolyásolja, a követelményeknek, de általában javasoljuk, hogy korlátozza a hozzáférést és látható-e bármely <xref:System.Windows.DependencyPropertyKey>csak részei a kódot az osztály vagy az alkalmazás logikája adott függőségi tulajdonság beállításához szükséges.</xref:System.Windows.DependencyPropertyKey> Javasolt továbbá, hogy jelentkezik, mintha értékének teszi közzé a függőség tulajdonság azonosítót az írásvédett függőségi tulajdonság esetében <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>, egy `public static readonly` található az osztály</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       A rendszer viszonylag tipikus forgatókönyv írásvédett függőségi tulajdonságokat. Használhatja a csak olvasható függőség tulajdonság értékének alapjául a többi tulajdonság rendszer művelet, amelyek a függőség tulajdonság, például a sablon egy <xref:System.Windows.Trigger>függőség tulajdonság egy stílusban.</xref:System.Windows.Trigger>       A függőség tulajdonság regisztrációs további információkért lásd: <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       Előfordulhat, hogy érvényesítése egy csak olvasható függőség tulajdonság a kevésbé fontos. Adja meg, ha a kulcs bizalmasként hozzáférési szintjét csökkenti annak a valószínűségét, tetszőleges érvénytelen bemenet."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Regisztrálja a függőség tulajdonság neve."
    - id: propertyType
      type: System.Type
      description: "A tulajdonság típusát."
    - id: ownerType
      type: System.Type
      description: "A tulajdonos típusa, amely a függőség tulajdonság regisztrál."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "A függőség tulajdonság tulajdonság metaadatai."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Egy felhasználó által létrehozott visszahívást, amelyet végre kell hajtania a függőség tulajdonság értékének tipikus típus érvényesítése túl bármilyen egyéni érvényesítési mutató hivatkozás."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "A függőség tulajdonság kulcs, amelynek használatával a osztály, amely majd később hivatkozhasson rá a függőség tulajdonság statikus, csak olvasható mező értékének beállítása."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "A karakterlánc a függőség tulajdonság alakot adja vissza."
  remarks: "Ez a megvalósítás adja vissza a <xref:System.Windows.DependencyProperty.Name%2A>tulajdonság értéke.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "A függőség tulajdonság karakterláncos ábrázolása."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Statikus érték, melynek használatával a [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] tulajdonság rendszer helyett <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> annak jelzésére, hogy létezik-e a tulajdonság, de nem rendelkezik a tulajdonság rendszer állítja be az értékét."
  remarks: "UnsetValue értéke sentinel forgatókönyvekben használt ahol a [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] tulajdonság rendszer nem tudja megállapítani a kért <xref:System.Windows.DependencyProperty>érték.</xref:System.Windows.DependencyProperty> UnsetValue használata helyett `null`, mert `null` érvényes tulajdonság értéke, valamint egy érvényes lehet (és gyakran használt) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue soha nem adott vissza <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> kívül Hívás esetén <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>a függőség tulajdonság alapján egy <xref:System.Windows.DependencyObject>példány, a következők egyikére vonatkozik: - függőség tulajdonság metaadatai között létrejött alapértelmezett értékkel rendelkezik, és ezt az értéket ad vissza.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Ez az érték származhat például <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Más értéket a tulajdonság rendszer hozta létre, és az alapértelmezett érték: nem megfelelő. További információkért lásd: [függőség tulajdonság értéke sorrend](~/add/includes/ajax-current-ext-md.md).       Beállítás a <xref:System.Windows.PropertyMetadata.DefaultValue%2A>a UnsetValue kifejezetten nem engedélyezett.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>UnsetValue adja vissza, ha a kért tulajdonság nem helyileg beállítása megtörtént.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue rendelkezik egy különleges jelentéssel bíró <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> visszatérési értéke További információkért lásd: [függőség tulajdonság visszahívások és az érvényesítés](~/add/includes/ajax-current-ext-md.md).       Ha egy adatbázis köti, vegye figyelembe, hogy UnsetValue nem egyenértékű <xref:System.DBNull.Value>, hasonló módon be, hogyan <xref:System.DBNull.Value>nincs egyenértékű igaz értéke null.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "Fel kell venni a párbeszédpanelre."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Az érték érvényesítési visszahívási lekérdezi a függőségi tulajdonság esetében."
  remarks: "Ez a tulajdonság fogja tartalmazni `null` együtt nincs regisztrált érvényesítési visszahívás bármely függőségi tulajdonság esetében.       Ellenőrizni az értékét visszahívások statikus értelemben kell eljárnia: alkalmazott érvényesítése a <xref:System.Windows.ValidateValueCallback>nem tudja megállapítani, hogy a megadott érték azonban egy adott esetben érvényes.</xref:System.Windows.ValidateValueCallback> A visszahívási csak is meghatározhatja, hogy összes objektum, amely rendelkezik a függőség tulajdonság kell, vagy nem fogadja el a megadott érték érvényes. Ha van szüksége, amely egy adott példányon, használjon más függőségi tulajdonságok értékeit tudatában támaszkodik-ellenőrzéshez egy <xref:System.Windows.CoerceValueCallback>helyette.</xref:System.Windows.CoerceValueCallback> A <xref:System.Windows.CoerceValueCallback>függőség tulajdonság metaadatainak, nem pedig közvetlenül a függőség tulajdonság azonosítója részeként van regisztrálva.</xref:System.Windows.CoerceValueCallback> További információkért lásd: [függőség tulajdonság visszahívások és az érvényesítés](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "Az érték érvényesítési visszahívási a függőség tulajdonság, ahogyan azt a <code> validateValueCallback </code> az eredeti tulajdonság regisztrációjának paramétere."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
