### YamlMime:ManagedReference
items:
- uid: System.Security.Cryptography.HMACSHA1
  id: HMACSHA1
  children:
  - System.Security.Cryptography.HMACSHA1.#ctor
  - System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  - System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  langs:
  - csharp
  name: HMACSHA1
  nameWithType: HMACSHA1
  fullName: System.Security.Cryptography.HMACSHA1
  type: Class
  summary: "Kiszámítja a kivonat-alapú üzenethitelesítési kód (HMAC) használatával a <xref href=&quot;System.Security.Cryptography.SHA1&quot;> </xref> kivonatoló függvényt."
  remarks: "HMACSHA1 típus az SHA1 kivonatoló függvénytől értékekből összeállított és HMAC, vagy kivonat-alapú üzenethitelesítési kódja használt létre kivonatoló kulcsalgoritmus. A HMAC-folyamat egy titkos kulcsot kever az üzenet adataihoz, a kivonatoló függvényt eredményét, a titkos kulccsal rendelkező keveri újra és majd még egyszer alkalmazza a kivonatoló függvényt. A kimeneti kivonat 160 bit hosszúságú.       Egy HMAC használható annak meghatározásához, hogy egy nem biztonságos csatornán keresztül küldött üzenet módosították, feltéve, hogy a küldő és fogadó ugyanazt a titkos kulcsot. A küldő kiszámítja a kivonatot az eredeti adatokkal, és elküldi az eredeti adatok és a kivonat értéke egyetlen üzenetben. A fogadó újraszámítja a kivonat értéke a fogadott üzenethez, és ellenőrzi, hogy a számított HMAC megegyezik-e a továbbított HMAC.       Bármi is módosul az adatokat, vagy a kivonat értéke nem egyezik, eredményez, mert a titkos kulcs ismerete szükséges módosítani az üzenetet, és Reprodukálja a megfelelő kivonat értéke. Ezért ha az eredeti és számított kivonati értékek egyeznek, az üzenet hitelesítése.       Az SHA-1 (biztonságos kivonatoló algoritmus, más néven SHS, biztonságos kivonatoló Standard) az Egyesült Államok kormánya által közzétett kriptográfiai kivonatoló algoritmus. Egy tetszőleges hosszúságú karakterlánc értéket 160 bites üzenetkivonatot képes.       HMACSHA1 kulcsok bármilyen méretű fogad, és 160 bit hosszúságú kivonatoló sorrend eredményez."
  example:
  - "The following code example shows how to sign a file by using the HMACSHA1 object and then how to verify the file.  \n  \n [!code-cs[HMACSHA1#1](~/add/codesnippet/csharp/t-system.security.crypto_82_1.cs)]\n [!code-cpp[HMACSHA1#1](~/add/codesnippet/cpp/t-system.security.crypto_82_1.cpp)]\n [!code-vb[HMACSHA1#1](~/add/codesnippet/visualbasic/t-system.security.crypto_82_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class HMACSHA1 : System.Security.Cryptography.HMAC
  inheritance:
  - System.Object
  - System.Security.Cryptography.HashAlgorithm
  - System.Security.Cryptography.KeyedHashAlgorithm
  - System.Security.Cryptography.HMAC
  implements: []
  inheritedMembers:
  - System.Security.Cryptography.HashAlgorithm.CanReuseTransform
  - System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks
  - System.Security.Cryptography.HashAlgorithm.Clear
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)
  - System.Security.Cryptography.HashAlgorithm.Dispose
  - System.Security.Cryptography.HashAlgorithm.Hash
  - System.Security.Cryptography.HashAlgorithm.HashSize
  - System.Security.Cryptography.HashAlgorithm.HashSizeValue
  - System.Security.Cryptography.HashAlgorithm.HashValue
  - System.Security.Cryptography.HashAlgorithm.InputBlockSize
  - System.Security.Cryptography.HashAlgorithm.OutputBlockSize
  - System.Security.Cryptography.HashAlgorithm.State
  - System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)
  - System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HMAC.BlockSizeValue
  - System.Security.Cryptography.HMAC.Create
  - System.Security.Cryptography.HMAC.Create(System.String)
  - System.Security.Cryptography.HMAC.Dispose(System.Boolean)
  - System.Security.Cryptography.HMAC.HashCore(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HMAC.HashFinal
  - System.Security.Cryptography.HMAC.HashName
  - System.Security.Cryptography.HMAC.Initialize
  - System.Security.Cryptography.HMAC.Key
  - System.Security.Cryptography.KeyedHashAlgorithm.KeyValue
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor
  id: '#ctor'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1()
  nameWithType: HMACSHA1.HMACSHA1()
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> osztály egy véletlenszerűen generált kulccsal."
  remarks: "<xref:System.Security.Cryptography.HMACSHA1>egy olyan típusú, az SHA1 kivonatoló függvénytől értékekből összeállított és HMAC, vagy kivonat-alapú üzenethitelesítési kódja használ létre kivonatoló kulcsalgoritmus.</xref:System.Security.Cryptography.HMACSHA1> A HMAC-folyamat egy titkos kulcsot kever az üzenet adataihoz, a kivonatoló függvényt eredményét, a titkos kulccsal rendelkező keveri újra és majd még egyszer alkalmazza a kivonatoló függvényt. A kimeneti kivonat (20 bájt) 160 bit hosszúságú.       Ez a konstruktor 64 bájtos, véletlenszerűen létrehozott kulcsot használ."
  syntax:
    content: public HMACSHA1 ();
    parameters: []
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  id: '#ctor(System.Byte[])'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1(Byte[])
  nameWithType: HMACSHA1.HMACSHA1(Byte[])
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[])
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> osztály a megadott kulcs adatokkal."
  remarks: "<xref:System.Security.Cryptography.HMACSHA1>egy olyan típusú, az SHA1 kivonatoló függvénytől értékekből összeállított és HMAC, vagy kivonat-alapú üzenethitelesítési kódja használ létre kivonatoló kulcsalgoritmus.</xref:System.Security.Cryptography.HMACSHA1> A HMAC-folyamat egy titkos kulcsot kever az üzenet adataihoz, a kivonatoló függvényt eredményét, a titkos kulccsal rendelkező keveri újra és majd még egyszer alkalmazza a kivonatoló függvényt. A kimeneti kivonat (20 bájt) 160 bit hosszúságú.      > [!NOTE] > Ezt a konstruktort az algoritmus nem felügyelt példányának <xref:System.Security.Cryptography.SHA1CryptoServiceProvider>osztály</xref:System.Security.Cryptography.SHA1CryptoServiceProvider> használatával hozza létre."
  example:
  - For an example of how to use this constructor, see the <xref:System.Security.Cryptography.HMACSHA1> class.
  syntax:
    content: public HMACSHA1 (byte[] key);
    parameters:
    - id: key
      type: System.Byte[]
      description: "A titkos kulcs <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> titkosítás. A kulcs hossza lehet, de ha több mint 64 bájt hosszú megtörténik annak kivonatolása (használatával SHA-1) egy 64 bájtos kulcs létrehozására. Ezért ajánlott a titkos kulcs mérete 64 bájt."
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>key</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  id: '#ctor(System.Byte[],System.Boolean)'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1(Byte[],Boolean)
  nameWithType: HMACSHA1.HMACSHA1(Byte[],Boolean)
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[],Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> osztály a megadott kulcs adatok és egy érték, amely megadja, hogy az SHA1 algoritmusok felügyelt verzióját használja-e."
  syntax:
    content: public HMACSHA1 (byte[] key, bool useManagedSha1);
    parameters:
    - id: key
      type: System.Byte[]
      description: "A titkos kulcs <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> titkosítás. A kulcs hossza lehet, de ha több mint 64 bájt hosszú, megtörténik annak kivonatolása (használatával SHA-1) egy 64 bájtos kulcs létrehozására. Ezért ajánlott a titkos kulcs mérete 64 bájt."
    - id: useManagedSha1
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>a felügyelt végrehajtása az SHA1 algoritmusok használata (a <xref href=&quot;System.Security.Cryptography.SHA1Managed&quot;> </xref> osztály); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> használni a nem felügyelt megvalósítása (a <xref href=&quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;> </xref> osztály)."
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Security.Cryptography.HMAC
  isExternal: false
  name: System.Security.Cryptography.HMAC
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.Cryptography.HMACSHA1.#ctor
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1()
  nameWithType: HMACSHA1.HMACSHA1()
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1()
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1(Byte[])
  nameWithType: HMACSHA1.HMACSHA1(Byte[])
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1(Byte[],Boolean)
  nameWithType: HMACSHA1.HMACSHA1(Byte[],Boolean)
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[],Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.HMACSHA1.#ctor*
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1
  nameWithType: HMACSHA1.HMACSHA1
