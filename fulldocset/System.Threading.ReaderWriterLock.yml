### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "Határozza meg, amely támogatja a egyetlen írók és több olvasók zárolást."
  remarks: "> [!IMPORTANT]> A [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] két olvasási-írási zárolás van <xref:System.Threading.ReaderWriterLockSlim>és ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>ajánlott az összes új fejlesztését.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>hasonló ReaderWriterLock, de azt van egyszerűsített szabályok rekurzió és frissítése, és alacsonyabb verziójúra változtatása a zárolás állapotát.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>Ezzel elkerülheti a holtpont sok esetben.</xref:System.Threading.ReaderWriterLockSlim> Emellett a teljesítményét <xref:System.Threading.ReaderWriterLockSlim>jelentősen jobb, mint ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock erőforráshoz való hozzáférés szinkronizálására használják. Egy adott időpontban lehetővé teszi az egyszerre használható szálak egyidejű olvasási hozzáférés, vagy egyetlen szálon írási hozzáférést. Egy olyan esetben, ha egy erőforrás ritkán, megváltozott-e egy `ReaderWriterLock` mint egy egyszerű egy-a-a-time zár, például <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor> jobb teljesítményt biztosít       `ReaderWriterLock`Amennyiben a legtöbb hozzáférések olvasások, míg írások alkalomszerű és rövid időtartam működik a legjobban. Több olvasók alternatív egyetlen írók az, hogy az olvasók sem írók hosszú ideig le vannak tiltva.      > [!NOTE] > Rendelkezik olvasási zárolások vagy írási zárolás, a hosszabb ideig ki lesz is szoríthatják más szálak. A legjobb teljesítmény érdekében érdemes a át lesznek strukturálva a az alkalmazás írási műveletek időtartama minimalizálása érdekében.       A szál tárolására képes olvasó, lock vagy zárolást, de ne mindkettőt egyszerre. Egy olvasási zárolás feloldása ahhoz, hogy a zárolást szerezni, helyett használhat, <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>és <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> </xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Rekurzív zárolási kérelmek növelje meg a zárolást a zárolási szám.       Olvasók és írók külön-külön sorba. A szál írási zárolás feloldása, amikor minden szál várakozik a olvasó, hogy azonnali kapnak olvasási zárolások; Ha az összes adott olvasási zárolások adtak ki, az író a következő szál várakozó feldolgozási sor, ha vannak ilyenek, kap a zárolást, és így tovább. Más szóval `ReaderWriterLock` helyettesek olvasók gyűjteménye, és egy író között.       Egy szál a író várólistában lévő aktív olvasóval zárolások kiadandó vár, amíg az olvasó várólistában új olvasási zárolások kérése szálak gyűlik össze. A nem kéréseket, annak ellenére, hogy azok sikerült egyidejű hozzáférés megosztása meglévő olvasó-lock tartozó felhasználók számára; hozzájárul írók olvasók határozatlan elakadása elleni védelméhez.       Zárolás beszerzése a legtöbb módszerei egy `ReaderWriterLock` időtúllépési értékét fogadja el. Az alkalmazás holtpont elkerülése érdekében időtúllépéseket használja. Például egy szál előfordulhat, hogy az író tud zárolást szerezni a egy erőforrást és majd egy olvasó zárolást kérhetnek a második erőforrás; addig is egy másik szál előfordulhat, hogy az író tud zárolást szerezni a második erőforrás, és olvasási zárolás. az első kérelem. Ha nincsenek időtúllépéseket, a szálak holtpont.       Az időtúllépési időtartama lejár, és a zárolási kérelem nem lett engedélyezve, ha a metódus visszaadja a hívó szál által <xref:System.ApplicationException>.</xref:System.ApplicationException> kiváltása Egy szál a rendszer a findlogin, és határozza meg a következő végrehajtandó műveletet.       Várakozási idő ezredmásodpercben szerint van megadva. Ha egy <xref:System.TimeSpan?displayProperty=fullName>adhatja meg az időtúllépés értékét teljes száma érték teljes ideje (MS) a <xref:System.TimeSpan>.</xref:System.TimeSpan> által képviselt</xref:System.TimeSpan?displayProperty=fullName> A következő táblázat a érvényes időtúllépési értékét, ezredmásodpercben megadva.      | Érték |} Leírás |}   |-----------|-----------------|   |} -1 |} A szál megvárja, amíg a zárolást szerzett, függetlenül attól, hogy mennyi ideig tart. Adja meg az egész időtúllépéseket módszerek, a állandó <xref:System.Threading.Timeout.Infinite>használhatók. |}   |}&0; |} A szál nem várnak a zárolás megszerzésére.</xref:System.Threading.Timeout.Infinite> Ha nem zárolható azonnal, a metódus visszaadja. |}   |} >&0; |} Várja meg ezredmásodpercben. |}       -1, kivéve negatív időtúllépési értékek nem engedélyezettek. Ha megad egy negatív egész szám,-1, nulla időtúllépési értéket használja helyette. (Ez azt jelenti, hogy a metódus visszaadja nélkül várakozik, ha nem zárolható azonnal.) Ha megad egy <xref:System.TimeSpan>ideje (MS)-1 negatív számot jelöl, amely <xref:System.ArgumentOutOfRangeException>vált ki.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> osztály."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az olvasót szerez be zárolása használatával egy <xref:System.Int32>az időtúllépési érték.</xref:System.Int32>"
  remarks: "AcquireReaderLock tiltása, ha egy másik szálon a zárolást, vagy ha legalább egy szál várakozik a zárolást.      > [!NOTE] > Az aktuális szál már a zárolást, ha nincs olvasási zárolás keletkezik. Ehelyett a zárolási szám a zárolást a értéke akkor növekszik. Ez megakadályozza, hogy a szál nem blokkolják a saját zárolást. Az eredmény, pontosan megegyezik hívása <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, és további hívnia <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>szükség, amikor az írási zárolás feloldása.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`támogatja a rekurzív olvasó-zárolási kérelmek. Ez azt jelenti, hogy a szál meghívhatja AcquireReaderLock többször, ami növeli a zárolási szám minden alkalommal. Meg kell hívnia <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>egyszer minden alkalommal meghívja a `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Másik lehetőségként hívása <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>a zárolási szám, nulla azonnal csökkentése érdekében.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekurzív zárolási mindig kéréseket azonnal, anélkül, hogy az olvasó várólista helyezi el a kérést küldő szálon. Óvatosan rekurzív zárolásokat, hosszú ideig zárolást kérések blokkolása elkerülése érdekében.       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Az időkorlát ezredmásodpercben."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>lejárt a zárolási kérelem megadása előtt."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az olvasót szerez be zárolása használatával egy <xref:System.TimeSpan>az időtúllépési érték.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>Ha egy másik szálon a zárolást, vagy ha legalább egy szál várakozik a zárolást blokkolja.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > Az aktuális szál már a zárolást, ha nincs olvasási zárolás keletkezik. Ehelyett a zárolási szám a zárolást a értéke akkor növekszik. Ez megakadályozza, hogy a szál nem blokkolják a saját zárolást. Az eredmény, pontosan megegyezik hívása <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, és további hívnia <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>szükség, amikor az írási zárolás feloldása.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`támogatja a rekurzív olvasó-zárolási kérelmek. Ez azt jelenti, hogy a szál meghívhatja AcquireReaderLock többször, ami növeli a zárolási szám minden alkalommal. Meg kell hívnia <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>egyszer minden alkalommal meghívja a `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Másik lehetőségként hívása <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>a zárolási szám, nulla azonnal csökkentése érdekében.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekurzív zárolási mindig kéréseket azonnal, anélkül, hogy az olvasó várólista helyezi el a kérést küldő szálon. Óvatosan rekurzív zárolásokat, hosszú ideig zárolást kérések blokkolása elkerülése érdekében.       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> adja meg a megadott időn belül."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>lejárt a zárolási kérelem megadása előtt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Adja meg a-1 ezredmásodperc nem negatív érték."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az író beolvasások zárolása használatával egy <xref:System.Int32>az időtúllépési érték.</xref:System.Int32>"
  remarks: "Ez a módszer tiltása, ha egy másik szál rendelkezik olvasási zárolás vagy zárolást. Annak, ahogyan a írási zárolás helyettesek több egyidejű olvasási zárral, olvassa el az <xref:System.Threading.ReaderWriterLock>osztályhoz.</xref:System.Threading.ReaderWriterLock>       A szál, amely már rendelkezik az olvasási zárolás lekérheti a zárolást az alábbi két módszer egyikével: az olvasási zárolás feloldása AcquireWriterLock hívása előtt, vagy hívja <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>      > [!CAUTION] > Ha a szál `AcquireWriterLock` továbbra is rendelkezik olvasási zárolás, amíg blokkolja a saját olvasási zárolás; Ha egy végtelen időtúllépés van megadva, a szál kölcsönös lesz-e a kizárás. Ilyen holtpont elkerülése érdekében használja <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>annak meghatározásához, hogy az aktuális szál már rendelkezik-e olvasási zárolás.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`rekurzív zárolást kérelmeket támogatja. Ez azt jelenti, hogy a szál meghívhatja `AcquireWriterLock` többször, ami növeli a zárolási szám minden alkalommal. Meg kell hívnia <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>egyszer minden alkalommal meghívja a `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Másik lehetőségként hívása <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>a zárolási szám, nulla azonnal csökkentése érdekében.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekurzív zárolási mindig kéréseket azonnal, anélkül, hogy az író várólista helyezi el a kérést küldő szálon.       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Az időkorlát ezredmásodpercben."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>lejárt a zárolási kérelem megadása előtt."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az író beolvasások zárolása, használja a <xref:System.TimeSpan>az időtúllépési érték.</xref:System.TimeSpan>"
  remarks: "Ez a módszer tiltása, ha egy másik szál rendelkezik olvasási zárolás vagy zárolást. Annak, ahogyan a írási zárolás helyettesek több egyidejű olvasási zárral, olvassa el az <xref:System.Threading.ReaderWriterLock>osztályhoz.</xref:System.Threading.ReaderWriterLock>       A szál, amely már rendelkezik az olvasási zárolás lekérheti a zárolást az alábbi két módszer egyikével: az olvasási zárolás hívása előtt készítéséhez <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, vagy <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> meghívásával</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > Ha a szál `AcquireWriterLock` továbbra is rendelkezik olvasási zárolás, amíg blokkolja a saját olvasási zárolás; Ha egy végtelen időtúllépés van megadva, a szál kölcsönös lesz-e a kizárás. Ilyen holtpont elkerülése érdekében használja <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>annak meghatározásához, hogy az aktuális szál már rendelkezik-e olvasási zárolás.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`rekurzív zárolást kérelmeket támogatja. Ez azt jelenti, hogy a szál meghívhatja `AcquireWriterLock` többször, ami növeli a zárolási szám minden alkalommal. Meg kell hívnia <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>egyszer minden alkalommal meghívja a `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Másik lehetőségként hívása <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>a zárolási szám, nulla azonnal csökkentése érdekében.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekurzív zárolási mindig kéréseket azonnal, anélkül, hogy az író várólista helyezi el a kérést küldő szálon.       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> adja meg a megadott időn belül."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>lejárt a zárolási kérelem megadása előtt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Adja meg a-1 ezredmásodperc nem negatív érték."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Azt jelzi, hogy a zárolást megkapta bármely szálon óta a sorszám lett lekérve."
  remarks: "Használhat <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>és `AnyWritersSince` az alkalmazások teljesítményének javítása érdekében.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> Például egy szál előfordulhat, hogy gyorsítótárazza az információkat, amíg olvasási zárolás beolvassa. Után felszabadítása, és később ismételt megszerzéséhez szükséges a zárolás, a szál használható `AnyWritersSince` annak meghatározásához, hogy más szálak az ideiglenes; kell írni a erőforrás Ha nem, a gyorsítótárban lévő adatokkal is használható. Ez a módszer akkor hasznos, ahol a zárolás által védett adatainak olvasásakor költséges; például egy adatbázis a lekérdezésnek a futtatása.       Ahhoz, hogy a sorszám hasznos lehet az olvasási zárolás vagy a zárolást a hívónak kell rendelkezik."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "A sorszám."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a zárolást bármely szálon megkapta, mivel a sorszám kapott; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál zárolás állapotát visszaállítja az állapotba <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>lett meghívva.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock kiadja a zárolást, függetlenül a rekurzív zárolási szám, és visszaállítja a olvasási zárolás, mielőtt frissítene a zárolást a szál tartja. A zárolási szám a olvasási zárolás helyreáll.      > [!NOTE]  >   `DowngradeFromWriterLock` fogad el egy <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> meghívásával kapott</xref:System.Threading.LockCookie> Ne használjon egy `LockCookie` <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> által visszaadott       A szál nem blokkolni, ha alacsonyabb verziójúra változtatása a zárolást, akkor is, ha más szálak vár a zárolást, mert az összes olvasó-lock kérelmek kapnak, amikor az írási zárolás."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*> által visszaadott"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "A szál nem rendelkezik a zárolást."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "A címe <code> lockCookie </code> null mutató."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ellenőrzi, hogy az erőforrások felszabadítását, és egyéb törlési művelet végrehajtása közben a szemétgyűjtő úgy szabadít fel a <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> objektum."
  remarks: "A szemétgyűjtő hívások véglegesítése, ha az aktuális <xref:System.Threading.ReaderWriterLock>objektum véglegesítésre készen áll.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy érték, amely jelzi, hogy az aktuális szál rendelkezik-e olvasási zárolás lekérése."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az aktuális szál olvasási zárolás; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi egy érték, amely jelzi, hogy az aktuális szál rendelkezik-e a zárolást."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az aktuális szál a zárolást; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Feloldja a zárolást, függetlenül a szál a zárolást szerzett száma."
  remarks: "ReleaseLock kiadja a olvasási zárolás vagy a zárolást, függetlenül a rekurzív zárolási szám. A zárolás, beleértve a zárolási szám állapotának visszaállítására adja át a <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> érték az engedélyezett zárolása."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Csökkenti a zárolás száma."
  remarks: "ReleaseReaderLock csökkenti a zárolás száma. Ha a szám eléri a nulla, a zárolás úgy.      > [!NOTE] > Hívja. Ha a szál a zárolást, `ReleaseReaderLock` ugyanaz a hatása, mint <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> hívása Ha a szál nem zárolásokat, hívja `ReleaseReaderLock` <xref:System.ApplicationException>.</xref:System.ApplicationException> jelez"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "A szál nem rendelkezik bármely olvasási vagy írási zárolás."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Csökkenti a zárolást a zárolást count."
  remarks: "ReleaseWriterLock csökkenti a zárolást száma. Ha a szám eléri a nulla, az írási zárolás van.      > [!NOTE] > Szál rendelkezik olvasási zárolás, vagy nincs elegendő zárolás, ha hívása `ReleaseWriterLock` <xref:System.ApplicationException>.</xref:System.ApplicationException> jelez"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "A szál nem rendelkezik a zárolást."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál zárolás állapotát visszaállítja az mi volt <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*> hívása előtt"
  remarks: "Az állapot visszaállítása `RestoreLock` magában foglalja a rekurzív zárolási szám.       Egy szál blokkok, ha megpróbálja olvasási zárolás visszaállítása után egy másik szál megszerezte a zárolást, illetve ha megpróbálja a zárolást visszaállítást, miután egy olvasási zárolás vagy zárolást szerzett meg egy másik szál. Mivel `RestoreLock` nem fogadja el a időtúllépés, meg kell gondoskodunk holtpont lehetséges elkerülése érdekében.      > [!CAUTION] > Hívása előtt `RestoreLock`, győződjön meg arról, hogy közzétette a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> hívása óta beállított összes zárolás Például egy szál holtpont Ha az egy olvasási zárolás, majd megkísérli visszaállítani egy korábbi zárolást. Használjon <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>és <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>észleléséhez az ilyen további zárolás.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       Ne használjon egy <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> által visszaadott</xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*> által visszaadott"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "A címe <code> lockCookie </code> null mutató."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Frissítések olvasási zárolás. az író zárolásához használatával egy <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> az időtúllépési érték."
  remarks: "Ha a szál meghívja `UpgradeToWriterLock` az olvasási zárolás úgy, függetlenül a zárolási szám és a szál a zárolást a sor végére kerül. Emiatt más szálak előfordulhat, hogy írni előtt a szál által kért a verziófrissítést kap a zárolást az erőforrás.      > [!IMPORTANT] > Az időtúllépési kivételt nem vált ki addig, amíg a UpgradeToWriterLock metódus hívása szál is újbóli az olvasó zárolása. Ha nincs más futásra, Várakozás a zárolást, ez akkor fordul elő azonnal. Azonban egy másik szál várakozik a zárolást, ha a szál, amely a UpgradeToWriterLock metódus hívása nem újbóli az olvasó zárolása mindaddig, amíg az összes jelenlegi olvasók rendelkezik, amely a hozzájuk tartozó zárolásokat, és egy szálat rendelkezik szerezte be, és megjelent a zárolást. Ez igaz, akkor is, ha a szál, a zárolást kért kért az aktuális szál UpgradeToWriterLock metódus hívása után.       A zárolás állapotának visszaállításához hívja meg a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>használatával a <xref:System.Threading.LockCookie>által visszaadott `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Ne használja a `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Ha a szál nincs olvasási zárolás van, ne használjon `UpgradeToWriterLock`. Használjon <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>helyette.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Az időkorlát ezredmásodpercben."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>lejárt a zárolási kérelem megadása előtt."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Frissítések olvasási zárolás. az író zárolása, használja a <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> az időtúllépési érték."
  remarks: "Ha a szál meghívja `UpgradeToWriterLock` az olvasási zárolás úgy, függetlenül a zárolási szám és a szál a zárolást a sor végére kerül. Emiatt más szálak előfordulhat, hogy írni előtt a szál által kért a verziófrissítést kap a zárolást az erőforrás.      > [!IMPORTANT] > Az időtúllépési kivétel nem történt a szál nevezett csak a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>módszer is újbóli az olvasó zárolása.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Ha nincs más futásra, Várakozás a zárolást, ez akkor fordul elő azonnal. Azonban ha egy másik szál várakozik a zárolást, a szál, amely hívja meg a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metódus nem újbóli az olvasó zárolása, amíg az összes jelenlegi olvasók rendelkezik, amely a hozzájuk tartozó zárolásokat, és egy szálat rendelkezik szerezte be, és megjelent a zárolást.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Ez igaz, akkor is, ha a szál, a zárolást kért kért az aktuális szál hívása után a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metódus.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       A zárolás állapotának visszaállításához hívja meg a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>használatával a <xref:System.Threading.LockCookie>által visszaadott `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Ne használja a `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Ha a szál nincs olvasási zárolás van, ne használjon `UpgradeToWriterLock`. Használjon <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>helyette.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Érvényes időtúllépési értékét lásd: <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> adja meg a megadott időn belül."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>lejárt a zárolási kérelem megadása előtt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Adja meg a-1 ezredmásodperc nem negatív érték."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi az aktuális sorszám."
  remarks: "A sorozat száma növekszik, ha a szál az írási zárolás. A sorszám mentheti, és adja át a <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>később, ha meg szeretné határozni, hogy más szálak időközben szerezték a zárolást.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       Használhat `WriterSeqNum` az alkalmazások teljesítményének javítása érdekében. Például egy szál előfordulhat, hogy gyorsítótárazza az információkat, amíg olvasási zárolás beolvassa. Után felszabadítása, és később ismételt megszerzéséhez szükséges a zárolás, a szál megállapíthatja, hogy más szálak erőforráshoz írt meghívásával `AnyWritersSince`; Ha nem, a gyorsítótárban lévő adatokkal is használható. Ez a módszer akkor hasznos, ha a zárolást által védett adatainak olvasásakor is drága; például egy adatbázis a lekérdezésnek a futtatása.       Ahhoz, hogy a sorszám hasznos lehet az olvasási zárolás vagy a zárolást a hívónak kell rendelkezik."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "A jelenlegi sorszám."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
