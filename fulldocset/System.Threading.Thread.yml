### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Létrehozza és szabályozza a szál, beállítja a hozzá tartozó Prioritás és állapotának beolvasása."
  remarks: "A folyamat indításakor a közös nyelvi futtatókörnyezet automatikusan létrehoz egy egyetlen előtér szál alkalmazáskód végrehajtásához. A fő előtér szál együtt egy folyamat végrehajtása a folyamathoz társított programkód része egy vagy több szál hozhat létre. Ezek a szálak hajthat végre az előtérben vagy a háttérben. Ezenkívül használhatja a <xref:System.Threading.ThreadPool>osztály legyen futtatható kód a közös nyelvi futtatókörnyezet által kezelt munkaszál.</xref:System.Threading.ThreadPool>       Ebben a szakaszban [a szál indítása](#Starting)[beolvasása szál objektumok](#Retrieving)[előtérben és háttérben futó szálak](#Foreground)[kulturális környezet és a szálak](#Culture)[Információkinyeréssel kapcsolatos és szabályozására szálak](#Properties)[a forráskód a szál osztály](#Source) <a name=&quot;Starting&quot;> </a> ## a szál indítása meg elindítani egy szálat úgy, hogy megadja a módszer, a szál az osztály konstruktorában végrehajtása jelölő meghatalmazottként.                                Majd hívja a <xref:System.Threading.Thread.Start%2A>metódus végrehajtásának megkezdésére.</xref:System.Threading.Thread.Start%2A>       A szál konstruktorok is igénybe vehet, vagy két delegált típusok, attól függően, hogy átadhatók argumentumot végrehajtandó metódus:-a metódushoz argumentum nélkül, ha át egy <xref:System.Threading.ThreadStart>delegálása a konstruktor.</xref:System.Threading.ThreadStart> Az aláírása: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` az alábbi példa hoz létre, és elindítja a szál, amely végrehajtja a `ExecuteInForeground` metódust.           A módszer egyes szál tulajdonságok információit jeleníti meg, majd végrehajtja a ciklus, amelyben fél másodpercig megszakítja, és a eltelt másodpercek számát jeleníti meg. A szál által végrehajtott legalább öt másodpercig, a hurok véget ér, és a szál végrehajtási leáll.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -a metódus argumentum tartozik az, ha át egy <xref:System.Threading.ParameterizedThreadStart>delegálása a konstruktor.</xref:System.Threading.ParameterizedThreadStart>       Az aláírása: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` hajtja végre a következő delegáltnak metódus ezután típuskonverziójához (C#) vagy (a Visual Basic nyelvben) átalakítani a paramétert a megfelelő típusú.                     A következő példa megegyezik az előzőre, azzal a különbséggel, hogy meghívja a <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>konstruktor.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> A jelen verziójában a `ExecuteInForeground` metódusnak egyetlen paramétert, amely a hurok végrehajtani ezredmásodpercben hozzávetőleges számát jelöli.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] nincs szükség a szál objektumra mutató hivatkozás megőrzése a szál megkezdése után.       A szál továbbra is fennáll, amíg be nem fejeződik a szál az eljárás végrehajtásához.      <a name=&quot;Retrieving&quot;></a>## Beolvasása szál objektumokat is használhatja a statikus (`Shared` a Visual Basic nyelvben) <xref:System.Threading.Thread.CurrentThread%2A>tulajdonság beolvasni a szál éppen futó kód a jelenleg végrehajtás alatt álló szál mutató hivatkozás.</xref:System.Threading.Thread.CurrentThread%2A> Az alábbi példában a <xref:System.Threading.Thread.CurrentThread%2A>tulajdonság a fő alkalmazás szál, egy másik előtér szál, a háttérszálon és a szál készlet szál információt szeretne megjeleníteni.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> ## előtérben és háttérben futó szálak szál osztály példányai előtér szálak vagy háttérszál képviseli.         Háttérszál azonosak előtér szálak számát, egy kivétellel: a háttérszálon nem őrzi futó egyik folyamat, ha az összes előtérbeli lánc megszakadt. Amennyiben az összes előtérbeli szálak le lett állítva, a futtatókörnyezet leállítja az összes háttérben szálak, és leállítja.       Alapértelmezés szerint a következő szálak hajtható végre az előtérben:-a fő alkalmazás szál.      -Összes szála által létrehozott szál osztálykonstruktor meghívásával.       Alapértelmezés szerint a háttérben megtörténik a következő szálat:-készlet szálak, amelyek egy alkalmazáskészlet munkavégző szál tartja fenn a futtatókörnyezet szál.  Konfigurálhatja a szál címkészletet és az ütemezés munka a szál készlet szálak <xref:System.Threading.ThreadPool>osztály</xref:System.Threading.ThreadPool> használatával          > [!NOTE] > Feladatalapú aszinkron műveletek automatikusan a szál készlet szálak hajtható végre. Feladatalapú aszinkron műveletek használata a <xref:System.Threading.Tasks.Task>és <xref:System.Threading.Tasks.Task%601>osztályok megvalósítása a [feladatalapú aszinkron mintát](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      – Adja meg a felügyelt végrehajtási környezet nem felügyelt kódból az összes szál.       Módosíthatja úgy, hogy a háttérben végrehajtani egy szál a <xref:System.Threading.Thread.IsBackground%2A>tulajdonság bármikor.</xref:System.Threading.Thread.IsBackground%2A>  Minden művelet, amely elvileg a továbbiakban mindaddig, amíg az alkalmazás fut, de nem akadályozhatja meg az alkalmazás leáll, például a rendszer fájlváltozások vagy bejövő szoftvercsatorna-kapcsolat figyelése háttérszál hasznosak.       Az alábbi példa mutatja be előtérben és háttérben futó szálak közötti különbség. Az első példában a hasonlít a [a szál indítása](#Starting) szakaszban, kivéve, hogy a szál az újraindítás előtt a háttérben végrehajtása állítja be. Az alábbiakat mutatja be, mert a ciklus megszakad, mielőtt végrehajtja a öt másodpercig.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> ## kulturális környezet és a szálak minden szál rendelkezik-e a kulturális környezet által képviselt a <xref:System.Threading.Thread.CurrentCulture%2A>által képviselt tulajdonság, és egy felhasználói felületi kulturális környezet, a <xref:System.Threading.Thread.CurrentUICulture%2A>tulajdonság.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          A jelenlegi kulturális környezethez elemzése és formázás, karakterlánc-összehasonlítási és rendezési kulturális környezet érzékeny műveletek támogatja, és az írást rendszer és a szál által használt naptár is vezérli. A jelenlegi felhasználói felületi kulturális környezet kulturális környezet érzékeny lekérése az erőforrás-fájlokban szereplő erőforrások biztosít.       Amikor létrejön egy új szál, a kulturális környezet és a felhasználói felületi kulturális környezet vannak definiálva az aktuális rendszer kulturális környezet és a felhasználói felületi kulturális környezet, nem pedig a kulturális környezet és a felhasználói felületi kulturális környezet, a szál, amelyről az új szál jön létre. Ez azt jelenti, például, ha a rendszer aktuális kulturális környezetének angol (Egyesült Államok), és az elsődleges alkalmazás szál aktuális kulturális környezetének francia (Franciaország), a kulturális környezet meghívásával létrehozott egy új szál a <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>az elsődleges szálból konstruktor az angol (Egyesült Államok), és nem francia (Franciaország).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> További információkért lásd: a &quot;Kulturális környezet és szálak&quot; szakaszában a <xref:System.Globalization.CultureInfo>osztály a témakörben.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > Ez nem teljesül, amely az alkalmazások aszinkron műveletek végrehajtása, hogy a célkiszolgáló szálak száma az [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] és újabb verziók, ebben az esetben, a kulturális környezet és a felhasználói felületi kulturális környezet egy aszinkron műveletek környezet része; a szál, amelyen egy aszinkron művelet alapértelmezés szerint végrehajtja a kulturális környezet és a felhasználói felületi kulturális környezet, a szál az aszinkron művelet elindult, amelyből örököl. További információkért lásd: a &quot;Kulturális környezetet és feladatalapú aszinkron műveletek&quot; szakaszában a <xref:System.Globalization.CultureInfo>osztály a témakörben.</xref:System.Globalization.CultureInfo>       Hajthatja annak érdekében, hogy a szálai a következő végrehajtás alatt egy alkalmazást a azonos kulturális környezet és a megosztott felhasználói felületi kulturális környezet:-átadhatók egy <xref:System.Globalization.CultureInfo>adott kulturális képviselő objektum a <xref:System.Threading.ParameterizedThreadStart>delegálása vagy a <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>metódus.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -A futó alkalmazások a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] és újabb verziók, megadhatja a kulturális környezet és a felhasználói felületi kulturális környezet, amely hozzá kell rendelni egy alkalmazástartomány értékre állítja által létrehozott összes szála által a <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>és <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Tulajdonságok.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Vegye figyelembe, hogy ez egy alkalmazás-beállítás.       &quot;További információt és példákat a kulturális környezet és szálak&quot; szakaszában olvashat a <xref:System.Globalization.CultureInfo>osztály a témakörben.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a>## Információkinyeréssel és szálak szabályozása, amelyek információval szolgálnak a szál számos kérheti le. Bizonyos esetekben a tulajdonságok értékeit a műveletet, a szál vezérlő is beállíthat. A szál tulajdonságok a következők:-nevet. <xref:System.Threading.Thread.Name%2A>egy írható-egyszer, amelyek segítségével azonosíthatja a szál tulajdonság.</xref:System.Threading.Thread.Name%2A>  Az alapértelmezett érték `null`.      -A kivonatoló kódot, mely meghívásával kérheti le a <xref:System.Threading.Thread.GetHashCode%2A>metódus.</xref:System.Threading.Thread.GetHashCode%2A> A kivonatoló kódot segítségével egyedi módon azonosítja az egy szál; a szál teljes a kivonatoló kódot fog nem ütköznek a más szálból, függetlenül az alkalmazástartományt, amelyből beszerezni az értéket a értékű.      – Egy szálat. A csak olvasható értékének <xref:System.Threading.Thread.ManagedThreadId%2A>tulajdonság a futtatókörnyezet által hozzárendelt, és egyedileg azonosít egy szál a folyamaton belül.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > Egy operációs rendszer [szálazonosító](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) nem kezelt szál, rögzített kapcsolattal rendelkezik, egy nem felügyelt gazdagép szabályozhatják a kezelt és kezeletlen szálak közötti kapcsolat. Pontosabban, a kifinomult állomás használhatja a [CLR-beli futtató API](https://msdn.microsoft.com/library/ms404385.aspx) szemben az operációs rendszer elemmel azonos szálban sok felügyelt szál ütemezése, vagy egy felügyelt szál áthelyezése másik operációs rendszer szálak közötti.      -A szál aktuális állapota. A létezésük időtartama, a szál mindig van egy vagy több által meghatározott állapotok a <xref:System.Threading.ThreadState>tulajdonság.</xref:System.Threading.ThreadState>      -A ütemezési prioritási szintet, amely határozzák meg a <xref:System.Threading.ThreadPriority>tulajdonság.</xref:System.Threading.ThreadPriority> Bár ez az érték a szál prioritását kéréséhez állíthatja be, akkor előfordulhat, hogy kell ezt a funkciót az operációs rendszer.      -A csak olvasható <xref:System.Threading.Thread.IsThreadPoolThread%2A>tulajdonság, amely azt jelzi, hogy a szál szál készlet szálnak.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      -A <xref:System.Threading.Thread.IsBackground%2A>tulajdonság.</xref:System.Threading.Thread.IsBackground%2A> További információkért lásd: a [előtérben és háttérben futó szálak](#Foreground) szakasz.      <a name=&quot;Source&quot;></a>## A forráskód a szál osztály a .NET-keretrendszer forráskódja szál osztály megtekintéséhez lásd a [hivatkozás forrás](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Tallózzon a forráskód online, töltse le a hivatkozás nélküli megtekintéshez és a források (beleértve a javítások és frissítések) végighaladhat hibakeresési; Lásd: [utasításokat](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Threading.Thread&quot;> </xref> osztály, amely lehetővé teszi egy objektum átadását a szálat, a szál indításakor meghatalmazott megadása."
  remarks: "A szál nem kezdődik végrehajtása létrehozásakor. A szál végrehajtásra ütemezni, hívja meg a <xref:System.Threading.Thread.Start%2A>metódus.</xref:System.Threading.Thread.Start%2A> A szál átadni egy objektumot, használja a <xref:System.Threading.Thread.Start%28System.Object%29>metódus túlterhelési.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Visual Basic-felhasználók kihagyhatja a <xref:System.Threading.ThreadStart>konstruktor a szál létrehozása során.</xref:System.Threading.ThreadStart> Használja a `AddressOf` operátor, ha a metódus, például `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatikusan meghívja a <xref:System.Threading.ThreadStart>konstruktor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Ez a delegált hívható meg ebből a szálból megkezdésekor végrehajtása eljárások jelöli."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Threading.Thread&quot;> </xref> osztály."
  remarks: "A szál nem kezdődik végrehajtása létrehozásakor. A szál végrehajtásra ütemezni, hívja meg a <xref:System.Threading.Thread.Start%2A>metódus.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Visual Basic-felhasználók kihagyhatja a <xref:System.Threading.ThreadStart>konstruktor a szál létrehozása során.</xref:System.Threading.ThreadStart> Használja a `AddressOf` operátor történő átadásakor például a metódus `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatikusan meghívja a <xref:System.Threading.ThreadStart>konstruktor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> kell meghívni, ha a szál kezdődik végrehajtása eljárások jelölő delegált."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Threading.Thread&quot;> </xref> osztály adható meg, amely lehetővé teszi egy objektum átadását a szálat, a szál indításakor meghatalmazott, és meghatározza a maximális verem méretét a szál."
  remarks: "Ez a konstruktor túlterhelés kerülje. A által használt alapértelmezett hívásverem mérete a <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>konstruktor túlterhelési érték szálak ajánlott verem méretét.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Ha a szál memóriával kapcsolatos problémák, a ennek legvalószínűbb oka van programozási hiba, például a végtelen rekurzió.      > [!IMPORTANT] > Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], csak a teljesen megbízható kód állíthat `maxStackSize` egy érték, amely nagyobb, mint az alapértelmezett hívásverem mérete (1 megabájtnak). Ha egy nagyobb érték van megadva a(z) `maxStackSize` kód részleges megbízhatósággal fut. Ha `maxStackSize` figyelmen kívül hagyja, és használja az alapértelmezett hívásverem mérete. Nincs kivétel történt. Kód bármely megbízhatósági szinten állíthatja be `maxStackSize` egy érték, amely kisebb, mint az alapértelmezett hívásverem mérete.      > [!NOTE] > Ha a teljesen megbízható-részlegesen megbízható kód által használt szalagtár fejlesztői és kell elindítani egy szálat a nagy méretű verem igénylő, a szál létrehozása előtt kell helyességi feltétel teljes megbízhatósággal, vagy az alapértelmezettnél verem használható. Nem ez csak akkor teljes irányítása a szálon futó kóddal.       Ha `maxStackSize` kisebb, mint a minimális verem mérete, a minimális hívásverem mérete szolgál. Ha `maxStackSize` nincs többszöröse lap a mérete, a lapméretnél nagyobb következő többszörösére lesz kerekítve. Például a .NET-keretrendszer 2.0-s verziójának használatakor a Windows Vista 256KB (262 144 bájt) a minimális hívásverem mérete, pedig a lapméretnél 64 KB-os (65 536 bájt).      > [!NOTE] > Előtt a Windows XP és Windows Server 2003, Microsoft Windows-verziókban `maxStackSize` figyelmen kívül hagyja, és a hívásverem mérete végrehajtható fejlécben megadott szolgál.       Ha megad egy nagyon kis hívásverem mérete, szükség lehet a veremtúlcsordulás probing letiltása. Ha a verem súlyosan korlátozott, az ellenőrzés maga miatt veremtúlcsordulás. Verem túlcsordulás ellenőrzés letiltásához adja hozzá a következőket az alkalmazás konfigurációs fájljában.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "A <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> kell meghívni, ha a szál kezdődik végrehajtása eljárások jelölő delegált."
    - id: maxStackSize
      type: System.Int32
      description: "A maximális verem mérete, a végrehajtható fájl fejlécben megadott alapértelmezett maximális verem mérete használandó a szál, vagy 0 által használható.       Fontos a részlegesen megbízható kód, `maxStackSize` nagyobb, mint az alapértelmezett verem mérete esetén figyelmen kívül hagyja. Nincs kivétel történt."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy új példányát inicializálja a <xref href=&quot;System.Threading.Thread&quot;> </xref> osztály, a szál a verem maximális méret megadása."
  remarks: "Ez a konstruktor túlterhelés kerülje. A által használt alapértelmezett hívásverem mérete a <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>konstruktor túlterhelési érték szálak ajánlott verem méretét.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Ha a szál memóriával kapcsolatos problémák, a ennek legvalószínűbb oka van programozási hiba, például a végtelen rekurzió.      > [!IMPORTANT] > Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], csak a teljesen megbízható kód állíthat `maxStackSize` egy érték, amely nagyobb, mint az alapértelmezett hívásverem mérete (1 megabájtnak). Ha egy nagyobb érték van megadva a(z) `maxStackSize` kód részleges megbízhatósággal fut. Ha `maxStackSize` figyelmen kívül hagyja, és használja az alapértelmezett hívásverem mérete. Nincs kivétel történt. Kód bármely megbízhatósági szinten állíthatja be `maxStackSize` egy érték, amely kisebb, mint az alapértelmezett hívásverem mérete.      > [!NOTE] > Ha a teljesen megbízható-részlegesen megbízható kód által használt szalagtár fejlesztői és kell elindítani egy szálat a nagy méretű verem igénylő, a szál létrehozása előtt kell helyességi feltétel teljes megbízhatósággal, vagy az alapértelmezettnél verem használható. Nem ez csak akkor teljes irányítása a szálon futó kóddal.       Ha `maxStackSize` kisebb, mint a minimális verem mérete, a minimális hívásverem mérete szolgál. Ha `maxStackSize` nincs többszöröse lap a mérete, a lapméretnél nagyobb következő többszörösére lesz kerekítve. Például a .NET-keretrendszer 2.0-s verziójának használatakor a Windows Vista 256KB (262 144 bájt) a minimális hívásverem mérete, pedig a lapméretnél 64 KB-os (65 536 bájt).      > [!NOTE] > Előtt a Windows XP és Windows Server 2003, Microsoft Windows-verziókban `maxStackSize` figyelmen kívül hagyja, és a hívásverem mérete végrehajtható fejlécben megadott szolgál.       Ha megad egy nagyon kis hívásverem mérete, szükség lehet a veremtúlcsordulás probing letiltása. Ha a verem súlyosan korlátozott, az ellenőrzés maga miatt veremtúlcsordulás. Verem túlcsordulás ellenőrzés letiltásához adja hozzá a következőket az alkalmazás konfigurációs fájljában.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> kell meghívni, ha a szál kezdődik végrehajtása eljárások jelölő delegált."
    - id: maxStackSize
      type: System.Int32
      description: "A maximális verem mérete, a végrehajtható fájl fejlécben megadott alapértelmezett maximális verem mérete használandó a szál, vagy 0 által használható.       Fontos a részlegesen megbízható kód, `maxStackSize` nagyobb, mint az alapértelmezett verem mérete esetén figyelmen kívül hagyja. Nincs kivétel történt."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>kisebb, mint nulla."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Kivált egy <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> a szál, amelyre meghívták, a szál leáll, a folyamat megkezdéséhez. A metódus hívása általában befejezi a szál."
  remarks: "Olyan szálon Ez a metódus meghívásakor a rendszer jelez egy <xref:System.Threading.ThreadAbortException>a szál megszakítható azt.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`a speciális kivételt, amely alkalmazáskód által kezelve is, de újra kivétel végén a `catch` tiltása kivéve <xref:System.Threading.Thread.ResetAbort%2A>nevezik.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`megszakítja a kérelmet, megszakítható, és megakadályozza, hogy a `ThreadAbortException` billentyűk megnyomása leállítsa a szál. Unexecuted `finally` blokkok végrehajtása előtt a szál megszakadt.      > [!NOTE] > Ha meghívja a szál `Abort` a saját magát, a hatás hasonlít; egy kivétel kiváltása a <xref:System.Threading.ThreadAbortException>történik, azonnal, és az eredmény előre jelezhető.</xref:System.Threading.ThreadAbortException> Azonban ha egy szál `Abort` egy másik szál a megszakítási megzavarja a tetszőleges kód futtatása. Lehetséges, hogy statikus konstruktorban sikerült-e megszakítva is van. Bizonyos ritkán előforduló esetekben ez megakadályozhatja, hogy az osztály példányai, hogy alkalmazástartomány létrehozása. Változataiban a .NET-keretrendszer 1.0 és 1.1, esély van a szál megszakítása sikerült közben egy `finally` blokk fut, ebben az esetben a `finally` blokk végrehajtása megszakadt.       A szál megszakítja az azonnal, vagy egyáltalán nem garantált. Ez a helyzet akkor fordulhat elő, ha a szál a számítási unbounded összege a `finally` mutatnak a megszakítási művelet, így határozatlan ideig késlelteti az abort részeként nevezzük. Várjon, amíg a szál megszakadt, hívja az <xref:System.Threading.Thread.Join%2A>metódust a szál az Abort metódus hívása után, de nem garantálja a Várjon, amíg befejeződik.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > A megszakítási hívó szál blokkolhatják, ha a szál megszakítás alatt áll, egy védett régió kódja, például egy `catch` blokk, `finally` blokk, vagy a korlátozott végrehajtási területet. Ha a szál, amely behívja a megszakítás a megszakított szál igénylő zárolja, holtpont akkor fordulhat elő.       Ha `Abort` nevezik szálban, amely nem lett elindítva, a szál leáll, amikor <xref:System.Threading.Thread.Start%2A>nevezik.</xref:System.Threading.Thread.Start%2A> Ha `Abort` nevezik szálban, amely le van tiltva, vagy alvó állapotban, a szál megszakadt, és majd megszakadt.       Ha `Abort` a szál fel van függesztve, a neve egy <xref:System.Threading.ThreadStateException>vált ki, a szál nevezett <xref:System.Threading.Thread.Abort%2A>, és <xref:System.Threading.ThreadState>hozzáadódik a <xref:System.Threading.Thread.ThreadState%2A>a megszakított szál tulajdonsága.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>nem vált ki, amíg a felfüggesztett szál <xref:System.Threading.Thread.Resume%2A>nevezik.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Ha `Abort` közben nem felügyelt kód, végrehajtja a felügyelt szál metódust egy `ThreadAbortException` nem vált ki, amíg a szál és felügyelt kódot ad vissza.       Ha két hívások `Abort` származnak egyszerre, lehetséges, egy hívás a állapot adatainak beállításához a más hívás végrehajtása a `Abort`. Azonban egy alkalmazást ebben a helyzetben nem észlel.       Miután `Abort` meghívták szálban, a szál állapota <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> tartalmaz A szál megszakadt miatt sikeres hívását követően `Abort`, a szál állapota megváltozik a <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Rendelkezik a szükséges engedélyekkel, a szál, amelyek célja az `Abort` megszüntetheti a megszakítási használatával a `ResetAbort` metódus. Példa azt mutatja be, hívása a `ResetAbort` módszer, tekintse meg a `ThreadAbortException` osztály."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál megszakítás alatt áll, jelenleg fel van függesztve."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Kivált egy <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> a szál, amelyre meghívták, leállítja a szál közben is és a szál futása kivétel információt nyújt a folyamat megkezdéséhez. A metódus hívása általában befejezi a szál."
  remarks: "Olyan szálon Ez a metódus meghívásakor a rendszer jelez egy <xref:System.Threading.ThreadAbortException>a szál megszakítható azt.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`a speciális kivételt, amely alkalmazáskód által kezelve is, de újra kivétel végén a `catch` tiltása kivéve <xref:System.Threading.Thread.ResetAbort%2A>nevezik.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`megszakítja a kérelmet, megszakítható, és megakadályozza, hogy a `ThreadAbortException` billentyűk megnyomása leállítsa a szál. Unexecuted `finally` blokkok végrehajtása előtt a szál megszakadt.      > [!NOTE] > Ha meghívja a szál `Abort` a saját magát, a hatás hasonlít; egy kivétel kiváltása a <xref:System.Threading.ThreadAbortException>történik, azonnal, és az eredmény előre jelezhető.</xref:System.Threading.ThreadAbortException> Azonban ha egy szál `Abort` egy másik szál a megszakítási megzavarja a tetszőleges kód futtatása. Statikus konstruktorban megszakítását sikerült esély van. Bizonyos ritkán előforduló esetekben ez megakadályozhatja, hogy az osztály példányai, hogy alkalmazástartomány létrehozása. Változataiban a .NET-keretrendszer 1.0 és 1.1, esély van a szál megszakítása sikerült közben egy `finally` blokk fut, ebben az esetben a `finally` blokk végrehajtása megszakadt.       A szál megszakítja az azonnal, vagy egyáltalán nem garantált. Ez a helyzet akkor fordulhat elő, ha a szál a számítási unbounded összege a `finally` mutatnak a megszakítási művelet, így határozatlan ideig késlelteti az abort részeként nevezzük. Várjon, amíg a szál megszakadt, hívja az <xref:System.Threading.Thread.Join%2A>metódust a szál az Abort metódus hívása után, de nem biztos, hogy a Várjon, amíg befejeződik.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > A hívó szál <xref:System.Threading.Thread.Abort%2A>blokkolhatják, ha a szál megszakítás alatt áll, egy védett régió kódja, például egy `catch` blokk, `finally` blokk, vagy a korlátozott végrehajtási területet.</xref:System.Threading.Thread.Abort%2A> Ha a szál hívó <xref:System.Threading.Thread.Abort%2A>rendelkezik, amely a megszakított szál igényel, akkor fordulhat elő, holtpont zárolást.</xref:System.Threading.Thread.Abort%2A>       Ha `Abort` nevezik szálban, amely nem lett elindítva, a szál leáll, amikor <xref:System.Threading.Thread.Start%2A>nevezik.</xref:System.Threading.Thread.Start%2A> Ha `Abort` nevezik szálban, amely le van tiltva, vagy alvó állapotban, a szál megszakadt, és majd megszakadt.       Ha `Abort` a szál fel van függesztve, a neve egy <xref:System.Threading.ThreadStateException>vált ki, a szál nevezett <xref:System.Threading.Thread.Abort%2A>, és <xref:System.Threading.ThreadState>hozzáadódik a <xref:System.Threading.Thread.ThreadState%2A>a megszakított szál tulajdonsága.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>nem vált ki, amíg a felfüggesztett szál <xref:System.Threading.Thread.Resume%2A>nevezik.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Ha `Abort` közben nem felügyelt kód, végrehajtja a felügyelt szál metódust egy `ThreadAbortException` nem vált ki, amíg a szál és felügyelt kódot ad vissza.       Ha két hívások `Abort` származnak egyszerre, lehetséges, egy hívás a állapot adatainak beállításához a más hívás végrehajtása a `Abort`. Azonban egy alkalmazást ebben a helyzetben nem észlel.       Miután `Abort` meghívták szálban, a szál állapota <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> tartalmaz A szál megszakadt miatt sikeres hívását követően `Abort`, a szál állapota megváltozik a <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Rendelkezik a szükséges engedélyekkel, a szál, amelyek célja az `Abort` megszüntetheti a megszakítási használatával a `ResetAbort` metódus. Példa azt mutatja be, hívása a `ResetAbort` módszer, tekintse meg a `ThreadAbortException` osztály."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Egy objektum, amely tartalmazza az alkalmazás-specifikus információkat, például állapotát, amely a megszakított szál által használható."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál megszakítás alatt áll, jelenleg fel van függesztve."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy névtelen adatokat helyre, a szálak a foglal le. A jobb teljesítmény érdekében használja a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       A tárolóhely szálak osztja ki a rendszer.       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, tároló és az adatok beolvasása a tárolóhelyen lévő érték, a tárhely újbóli ingyenes, a szál lejárata után is. Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "A hozzárendelt összes szála által az adatok tárolóhely neve."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az összes szála által elnevezett tárhely foglal le. A jobb teljesítmény érdekében használja a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, tároló és az adatok beolvasása a tárolóhelyen lévő érték, a tárhely újbóli ingyenes, a szál lejárata után is. Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le.       Nincs szükség a AllocateNamedDataSlot módszer használatát egy elnevezett tárolóhely lefoglalni, mert a <xref:System.Threading.Thread.GetNamedDataSlot%2A>módszer a tárolóhely foglal le, ha már nincs lefoglalva.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > A AllocateNamedDataSlot módszer használata esetén azt kell hívható meg a fő szálnak a program indításakor, mert azt kivételt jelez, ha a tárhely a megadott névvel már van rendelve. Nincs mód annak megállapítására, hogy a tárhely lefoglalása már megtörtént.       Ezzel a módszerrel lefoglalt el kell választani a <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Az adatok tárhely lefoglalni kívánt nevét."
    return:
      type: System.LocalDataStoreSlot
      description: "A hozzárendelt összes szála által az adatok tárolóhely neve."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egy elnevezett tárolóhely a megadott névvel már létezik."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja a ebből a szálból állapot."
  remarks: "**A Thread.TrySetApartmentState tulajdonság elavult.**  A nem elavult alternatíva vannak a <xref:System.Threading.Thread.GetApartmentState%2A>metódusának segítéségével lekérheti az állapot és a <xref:System.Threading.Thread.SetApartmentState%2A>módszer beállítása az apartmanállapotot.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       A .NET-keretrendszer verzióiban 1.0 és 1.1 a `ApartmentState` tulajdonság jelzi, hogy az egyszálas vagy többszálas apartmanban végrehajtja a szál jelöli meg. Ez a tulajdonság beállítható, ha a szál a `Unstarted` vagy `Running` szál állapot; azonban akkor is csak egyszer állítható be egy szálhoz. Ha a tulajdonság nem lett beállítva, adja vissza, `Unknown`.       A szál, amelynek apartmanállapotot már be van állítva az állapot beállítása a Thread.TrySetApartmentState tulajdonság használata a rendszer figyelmen kívül hagyja. Azonban a <xref:System.Threading.Thread.SetApartmentState%2A>metódus jelez a <xref:System.InvalidOperationException>Ebben az esetben.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > A a .NET-keretrendszer 2.0-s verzióját, új szálak inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>Ha az állapot nem lett beállítva ahhoz, azok elindult.</xref:System.Threading.ApartmentState?displayProperty=fullName> A fő alkalmazás szál inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>alapértelmezés szerint.</xref:System.Threading.ApartmentState?displayProperty=fullName> Már nem állíthatja be az alkalmazás szál <xref:System.Threading.ApartmentState?displayProperty=fullName>úgy, hogy a <xref:System.Threading.ApartmentState?displayProperty=fullName>tulajdonság kód első sorában.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Használja a <xref:System.STAThreadAttribute>helyette.</xref:System.STAThreadAttribute>       A .NET-keretrendszer 2.0-s verzióját, adja meg a COM C++ alkalmazás használatára vonatkozó szálmodell a [/CLRTHREADATTRIBUTE (beállítása CLR szál attribútum)](~/add/includes/ajax-current-ext-md.md) összekötő lehetőséget."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "Egy a <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> értékeket. A kezdeti érték <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A tulajdonság beállításához, amely nem egy érvényes állapot állapotba tett kísérlet (nem egyszálas apartman állapotban (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) vagy a többszálas apartmanban (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értesíti a gazdagépet, hogy végrehajtási készül, hogy adja meg a régió kódja, amelyben a szál megszakítás vagy a nem kezelt kivétel eredő esetlegesen veszélyeztető más feladatok alkalmazástartományt."
  remarks: "A gazdagépeket, a közös nyelvi futtatókörnyezet (CLR), például a Microsoft SQL Server 2005, a kódot, kritikus és a nem kritikus régiókban hibák különböző szabályzatokat hozhat létre. Egy kritikus terület az egyik, amelyben a szál megszakítás vagy nem kezelt kivétel eredő nem korlátozott lehet az aktuális feladathoz. Ezzel szemben az abort vagy hiba történt a nem kritikus régió kódja a hatással van az csak a feladat, ahol a hiba akkor fordul elő.       Vegye figyelembe például egy feladatot, amely megkísérli a zárolást okozó memóriát lefoglalni. A memóriafoglalás sikertelen lesz, ha az aktuális feladat megszakítása nincs elegendő stabilitásának biztosításához a <xref:System.AppDomain>, mert lehet más feladatok az azonos zár Várakozás a tartományban.</xref:System.AppDomain> Ha az aktuális feladathoz, más feladatok sikerült kell-e holtpontba.       Ha hiba történik egy kritikus régióban található, a gazdagép dönthet, hogy a teljes memóriából való <xref:System.AppDomain>helyett kapcsolni a visszaállítási végrehajtásának folytatása potenciálisan instabil állapotban.</xref:System.AppDomain> Tájékoztatja a gazdagépet, hogy a kódot írja be a kritikus régió, hívja meg a BeginCriticalRegion. Hívás <xref:System.Threading.Thread.EndCriticalRegion%2A>Amikor végrehajtása és a nem kritikus régió kódja ad vissza.</xref:System.Threading.Thread.EndCriticalRegion%2A>       Ezzel a módszerrel a kód, amely az SQL Server 2005 rendszeren fut. a kódot a legmagasabb állomás védelmi szintjén futtatásához szükséges."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értesíti a olyan gazdagépet, amely a felügyelt kód készül az utasításokat, amelyek az aktuális fizikai operációs rendszer szál identitása függ végrehajtásához."
  remarks: "A közös nyelvi futtatókörnyezet, például a Microsoft SQL Server 2005, az egyes állomások képes saját szál kezelésére. Olyan gazdagépet, amely a saját szál felügyeletet biztosít áthelyezheti a feladat végrehajtása fizikai operációs rendszer egyik szálról a másikra bármikor. Feladatok többsége nem érinti a váltás. Azonban néhány feladat rendelkezik szál affinitását, mert ez azt jelenti, de szükségük van arra a fizikai operációs rendszer szál identitását. Ezek a feladatok tájékoztatnia kell a gazdagép azok kódot, amely nem állítható át végrehajtása közben.       Például, ha az alkalmazás a rendszer az operációs rendszer zárolás, amely rendelkezik a szál affinitását, például egy Win32 CRITICAL_SECTION API előtt meg kell hívnia BeginThreadAffinity a zárolás végrehajtása és <xref:System.Threading.Thread.EndThreadAffinity%2A>után a zárolás feloldása.</xref:System.Threading.Thread.EndThreadAffinity%2A>       Ezzel a módszerrel a kód, amely az SQL Server 2005 rendszeren fut. a kódot a legmagasabb állomás védelmi szintjén futtatásához szükséges."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi az aktuális környezetben, amelyben a szál végrehajtása történik."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "A <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> képviselő az aktuális szál környezetben."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja az aktuális szál kulturális környezetet."
  remarks: "A <xref:System.Globalization.CultureInfo>ezt a tulajdonságot, és a kapcsolódó objektumok által visszaadott objektum határozza meg a dátumok alapértelmezett formátuma, hányszor, számok, pénznemek, a rendezési sorrend szöveg, körül, egyezmények, és karakterlánc-összehasonlítást.</xref:System.Globalization.CultureInfo> Tekintse meg a <xref:System.Globalization.CultureInfo>osztály kulturális környezet neve és azonosítója, állandó, semleges és adott kulturális környezetek közötti különbségek megismeréséhez, és a módon információ hatással van a szálak és a alkalmazástartományok.</xref:System.Globalization.CultureInfo> Tekintse meg a <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>tulajdonság megtudhatja, hogyan határozza meg, a szál kulturális környezetet, és hogyan állítsa be a felhasználók a számítógépükön kulturális információi.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Verziótól kezdve a [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], beállíthatja a CurrentCulture tulajdonságát egy semleges kulturális környezetre. Ennek az az oka viselkedését a <xref:System.Globalization.CultureInfo>osztály megváltozott: Ha ez azt jelenti, hogy egy semleges kulturális környezethez, a tulajdonságértékek (különösen a <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, és <xref:System.Globalization.CultureInfo.TextInfo%2A>Tulajdonságok) most tükrözi az adott kulturális környezet semleges kulturális környezethez tartozó.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> A .NET-keretrendszer korábbi verzióiban a CurrentCulture tulajdonság kivételt okozott a <xref:System.NotSupportedException>kivétel, amikor egy semleges kulturális környezet hozzá lett rendelve.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Az aktuális szál kulturális környezet képviselő objektum."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A tulajdonság értéke <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja a szál aktuális rendszerbiztonsági tag (a szerepalapú biztonság)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "Egy <xref:System.Security.Principal.IPrincipal>érték a biztonsági környezet.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívónak nincs engedélye a kell beállítania a rendszerbiztonsági tag."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az aktuálisan futó szál lekérdezi."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "A <xref href=&quot;System.Threading.Thread&quot;> </xref> , amely a jelenleg futó szál ábrázolása."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja az erőforrás-kezelő által használt kulturális környezet-specifikus erőforrásokat kereshet a futási időben aktuális kulturális környezetet."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "A jelenlegi kulturális környezethez képviselő objektum."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A tulajdonság értéke <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A tulajdonság értéke nem használható erőforrásfájl azonosításához kulturális környezet neve. Csak betűk, számok, kötőjelek és aláhúzásjelek erőforrás fájlnevek tartalmaznia kell."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Kikapcsolja a futásidejű hívható burkolók (RCW) az aktuális szál automatikus karbantartása."
  remarks: "Alapértelmezés szerint a közös nyelvi futtatókörnyezet (CLR) a szükségtelenné vált futásidejű hívható burkolók automatikusan. A közös nyelvi Futtatókörnyezet szivattyúk üzenetek, amely néhány olyan alkalmazásnál, amely a következő szokatlan feltételeknek rögzítve problémákat okozhat a karbantartás során:-az alkalmazás teszi saját üzenet az adatok kiolvasása.      -Az alkalmazást kell pontosan, amikor az üzenet az adatok kiolvasása következik be.       Ilyen alkalmazások DisableComObjectEagerCleanup metódus használatával a közös nyelvi Futtatókörnyezet megakadályozása történt az automatikus visszaigénylését a futásidejű hívható burkolók.       Ha ez a metódus meghívása szálban, automatikus karbantartás újra engedélyezni, hogy a szál nem lehet. Használjon, amikor az alkalmazás készen áll a futásidejű hívható burkolók tisztítása a <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>módszert utasítja a futtatókörnyezet összes futásidejű hívható burkolók ebben a kontextusban karbantartása.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Üzenet az adatok kiolvasása következik be, amíg a metódus."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értesíti a gazdagépet, hogy végrehajtási készül, hogy adja meg a régió kódja, amelyben a szál megszakítás vagy a nem kezelt kivétel eredő korlátozva, és az aktuális feladatot."
  remarks: "A gazdagépeket, a közös nyelvi futtatókörnyezet (CLR), például a Microsoft SQL Server 2005, a kódot, kritikus és a nem kritikus régiókban hibák különböző szabályzatokat hozhat létre. Egy kritikus terület az egyik, amelyben a szál megszakítás vagy nem kezelt kivétel eredő nem korlátozott lehet az aktuális feladathoz. Ezzel szemben az abort vagy hiba történt a nem kritikus régió kódja a hatással van az csak a feladat, ahol a hiba akkor fordul elő.       Vegye figyelembe például egy feladatot, amely megkísérli a zárolást okozó memóriát lefoglalni. A memóriafoglalás sikertelen lesz, ha az aktuális feladat megszakítása nincs elegendő stabilitásának biztosításához a <xref:System.AppDomain>, mert lehet más feladatok az azonos zár Várakozás a tartományban.</xref:System.AppDomain> Ha az aktuális feladathoz, más feladatok sikerült kell-e holtpontba.       Ha hiba történik egy kritikus régióban található, a gazdagép dönthet, hogy a teljes memóriából való <xref:System.AppDomain>helyett kapcsolni a visszaállítási végrehajtásának folytatása potenciálisan instabil állapotban.</xref:System.AppDomain> Tájékoztatja a gazdagépet, hogy a kódot írja be a kritikus régió, hívja meg a <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> EndCriticalRegion hívására végrehajtása és a nem kritikus régió kódja ad vissza.       Ezzel a módszerrel a kód, amely az SQL Server 2005 rendszeren fut. a kódot a legmagasabb állomás védelmi szintjén futtatásához szükséges."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értesíti az olyan gazdagépet, amely a felügyelt kód utasításokat tartalmaz, amelyek az aktuális fizikai operációs rendszer szál identitása függ végrehajtása befejeződött."
  remarks: "A közös nyelvi futtatókörnyezet, például a Microsoft SQL Server 2005, az egyes állomások képes saját szál kezelésére. Olyan gazdagépet, amely a saját szál felügyeletet biztosít áthelyezheti a feladat végrehajtása fizikai operációs rendszer egyik szálról a másikra bármikor. Feladatok többsége nem érinti a váltás. Azonban néhány feladat rendelkezik szál affinitását, mert ez azt jelenti, de szükségük van arra a fizikai operációs rendszer szál identitását. Ezek a feladatok tájékoztatnia kell a gazdagép azok kódot, amely nem állítható át végrehajtása közben.       Például, ha az alkalmazás hívások a rendszer alkalmazásprogramozási Felületet szerezni az operációs rendszer zárolja, szálaffinitással, például egy Win32 CRITICAL_SECTION, amelynek meg kell hívnia <xref:System.Threading.Thread.BeginThreadAffinity%2A>a zárolást és a EndThreadAffinity beszerzése után a zárolás feloldása előtt.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       Ezzel a módszerrel a kód, amely az SQL Server 2005 rendszeren fut. a kódot a legmagasabb állomás védelmi szintjén futtatásához szükséges."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges engedélyekkel."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi egy <xref:System.Threading.ExecutionContext>objektum, amely az aktuális szál a különböző környezetek információt tartalmaz.</xref:System.Threading.ExecutionContext>"
  remarks: "A <xref:System.Threading.ExecutionContext>osztály egyetlen tárolót biztosít a végrehajtás logikai szálhoz vonatkozó összes információt.</xref:System.Threading.ExecutionContext> Tartalmazzák a biztonsági környezetet, a hívás környezete, a szinkronizálási környezetet, a honosítási környezetben és a tranzakciós környezet lett átadva."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "Egy <xref:System.Threading.ExecutionContext>objektum, amely egyesíti a környezeti információkat az aktuális szál.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ellenőrzi, hogy az erőforrások felszabadítását, és egyéb törlési művelet végrehajtása közben a szemétgyűjtő úgy szabadít fel a <xref href=&quot;System.Threading.Thread&quot;> </xref> objektum."
  remarks: "A szemétgyűjtő meghívja a véglegesítő, amikor az aktuális objektum véglegesítésre készen áll."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Megszünteti a nevét és helyét, a folyamat szálai összes társítását. A jobb teljesítmény érdekében használja a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       Után a szál hívások `FreeNamedDataSlot`, bármely más meghívó szálon <xref:System.Threading.Thread.GetNamedDataSlot%2A>ugyanazzal a névvel foglal le a névhez társított új tárhely.</xref:System.Threading.Thread.GetNamedDataSlot%2A> Ezt `GetNamedDataSlot` bármely szál visszatér az új tárolóhelyre. Azonban bármely szálon, amely még egy <xref:System.LocalDataStoreSlot?displayProperty=fullName>való egy korábbi hívás által visszaadott `GetNamedDataSlot` továbbra is használhatja a régi tárolóhelye.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       A tárolóhely, amelynek már társítva van egy név megjelent csak akkor, ha minden `LocalDataStoreSlot` , amely kapott hívása előtt `FreeNamedDataSlot` kiadott és szemétgyűjtési gyűjtött.       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, tároló és az adatok beolvasása a tárolóhelyen lévő érték, a tárhely újbóli ingyenes, a szál lejárata után is. Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Az adatok tárhely felszabadítását neve."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értéket ad vissza egy <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> érték apartman állapotát jelzi."
  remarks: "Ezt a módszert, valamint a <xref:System.Threading.Thread.SetApartmentState%2A>metódus és a <xref:System.Threading.Thread.TrySetApartmentState%2A>metódus, a felváltja a <xref:System.Threading.Thread.ApartmentState%2A>tulajdonság.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "Egy a <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> értékek a felügyelt szál apartman állapotát jelzi. Az alapértelmezett érték <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Értéket ad vissza egy <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objektum rögzítheti az aktuális szál a verem használható."
  remarks: "Ez a metódus már nem támogatott."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Nincs."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Minden esetben."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Olvassa be az értéket a megadott tárolóhelyről az aktuális szálon, az aktuális szál aktuális tartományban. A jobb teljesítmény érdekében használja a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, tároló és az adatok beolvasása a tárolóhelyen lévő érték, a tárhely újbóli ingyenes, a szál lejárata után is. Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le.      > [!NOTE] > GetData van egy `Shared` módszer, amely mindig alkalmazza a jelenleg végrehajtás alatt álló szál, még akkor is, ha meghívja a használatával egy változó, amely egy másik szál hivatkozik. Félreértések elkerülése érdekében használja az osztálynevet meghívásakor `Shared` módszerek: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> értéke beszerzéséhez."
    return:
      type: System.Object
      description: "Az érték."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az aktuális tartományban, amelyben az aktuális szál fut. adja vissza."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "Egy <xref href=&quot;System.AppDomain&quot;> </xref> képviselő a futó szál aktuális alkalmazástartományt."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy egyedi alkalmazásnevet tartomány azonosítójának beolvasása."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "Egy 32 bites előjeles egész egyedi módon azonosítja az alkalmazástartományt."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az aktuális szál kódjának kivonatát adja vissza."
  remarks: "A kivonatoló kódot nem garantált egyedinek kell lennie. Használja a <xref:System.Threading.Thread.ManagedThreadId%2A>tulajdonságot, ha egy felügyelt szál egyedi azonosítója szükséges.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Egész kivonatoló kódot értéket."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Elnevezett tárhely keres. A jobb teljesítmény érdekében használja a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, tároló és az adatok beolvasása a tárolóhelyen lévő érték, a tárhely újbóli ingyenes, a szál lejárata után is. Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le.       Ha a nevesített tárolóhelye nem létezik, az új tárhely van lefoglalva. Elnevezett bővítőhelyek nyilvános, és bárki kezelhetők."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "A helyi adatok tárolóhely neve."
    return:
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> lefoglalt ebből a szálból."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál, amely megszakítja a <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> szál állapota."
  remarks: "Ha ebből a szálból jelenleg nincs blokkolva várja meg, készenléti vagy csatlakoztatási állapotnak, ezután kezdetekor blokkolására megszakad.       <xref:System.Threading.ThreadInterruptedException>a megszakított szál, de nem csak a szál blokkok történt.</xref:System.Threading.ThreadInterruptedException> Ha a szál soha ne blokkolja, a kivétel soha nem történt, így a szál előfordulhat, hogy töltse nélkül bármikor megszakadt."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a megfelelő <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az aktuális szál végrehajtási állapotát jelző érték beolvasása."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha ebből a szálból elindult, és nem Befejezve, vagy megszakadt; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja egy érték, amely jelzi, hogy-e egy szál a háttérszálon."
  remarks: "Egy szál, a háttérszálon vagy előtérben történő szálnak. Háttérszál megegyeznek előtér szálak, azzal a különbséggel, hogy háttérszál akadályozza meg, hogy a folyamat leáll. Ha a folyamathoz tartozó összes előtérbeli szál megszakadt, a közös nyelvi futtatókörnyezet befejezi a folyamatot. Minden fennmaradó háttér szálak le van állítva, és nem hajtja végre.       Alapértelmezés szerint a következő szálak hajtható végre az előtérben (Ez azt jelenti, hogy azok IsBackground tulajdonság beolvasása `false`):-az elsődleges szál (vagy egy másik alkalmazás szál).      – Az összes szál meghívásával létrehozott egy <xref:System.Threading.Thread>osztálykonstruktor.</xref:System.Threading.Thread>       Alapértelmezés szerint a következő szálak hajtható végre a háttérben (Ez azt jelenti, hogy azok IsBackground tulajdonság beolvasása `true`):-készlet szálak, amelyek a futtatókörnyezet által fenntartott munkaszál készletét szál. Konfigurálhatja a szál címkészletet és az ütemezés munka a szál készlet szálak <xref:System.Threading.ThreadPool>osztály</xref:System.Threading.ThreadPool> használatával          > [!NOTE] > Feladatalapú aszinkron műveletek automatikusan a szál készlet szálak hajtható végre.      – Adja meg a felügyelt végrehajtási környezet nem felügyelt kódból az összes szál."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha ebből a szálból vagy válik a háttérszálon; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál nem működik."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi a egy érték, amely azt jelzi, a szál a felügyelt szálkészlet tartozik-e."
  remarks: "További információ: [a kezelt szál készlete](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a felügyelt szálkészlet; tartozik ebből a szálból Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Letiltja a hívó szál, amíg ez a példány által képviselt szál leáll, miközben továbbra is hajtsa végre a szabványos COM és <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> az adatok kiolvasása."
  remarks: "Illesztés rendelkező szinkronizálási módszer, amely blokkolja a hívó szál (Ez azt jelenti, hogy a szál, metódus) csak a szál, amelynek csatlakozási módszer neve befejeződött. Ez a módszer segítségével győződjön meg arról, hogy a szál megszakadt. A hívó határozatlan ideig letiltja, ha a szál nem ér véget. A következő példában a `Thread1` szál meghívja a csatlakozási módszer `Thread2`, aminek következtében `Thread1` címblokkra amíg `Thread2` befejeződött.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] Ha a szál már leállt mikor <xref:System.Threading.Thread.Join%2A>nevezik, a metódus azonnal visszaadja.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > Soha nem hívja a csatlakozási mód a <xref:System.Threading.Thread>az aktuális szál az az aktuális szál képviselő objektum.</xref:System.Threading.Thread> Ennek hatására az alkalmazás leállását, mert az aktuális szál várakozik maga után határozatlan ideig, ez a módszer módosítások <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> felvenni a hívó szál állapota Nem lehet meghívni `Join` , amely a szálban a <xref:System.Threading.ThreadState?displayProperty=fullName>állapotát.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A hívó megpróbált csatlakozzon, amely egy szál a <xref href=&quot;System.Threading.ThreadState&quot;> </xref> állapotát."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "A szál való várakozás során megszakad."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A hívó szál, amíg ez a példány által képviselt szál véget nem ér, vagy a megadott idő lejárta, miközben továbbra is hajtsa végre a szabványos COM és az adatok kiolvasása SendMessage blokkokat."
  remarks: "Illesztés, amely blokkolja a hívó szál (Ez azt jelenti, hogy a szál, metódus) vagy a szál amíg szinkronizálási módszer amelynek <xref:System.Threading.Thread.Join%2A>metódust befejeződött vagy az időtúllépési időköz.</xref:System.Threading.Thread.Join%2A> A következő példában a `Thread1` hívások szál a <xref:System.Threading.Thread.Join>metódusában `Thread2`, aminek következtében `Thread1` blokkolására addig `Thread2` befejeződött vagy 2 másodperc eltelt.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] Ha <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>van megadva a `millisecondsTimeout` paraméter, ez a módszer viselkedik-e az azonos a <xref:System.Threading.Thread.Join>metódus túlterhelési, kivéve a visszatérési érték.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Ha a szál már leállt mikor <xref:System.Threading.Thread.Join%2A>nevezik, a metódus azonnal visszaadja.</xref:System.Threading.Thread.Join%2A>       Ez a módszer a hívó szál <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> felvenni állapotának megváltoztatása Nem lehet meghívni `Join` , amely a szálban a <xref:System.Threading.ThreadState?displayProperty=fullName>állapotát.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "A szál leáll várakozási idő milliszekundumban megadva száma."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a szál leállt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha a szál nem leállt a megadott idő után a <code> millisecondsTimeout </code> paraméter lejárt."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Értékének <code> millisecondsTimeout </code> negatív, és nem egyenlő &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; ezredmásodpercben."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál nem indult el."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A hívó szál, amíg ez a példány által képviselt szál véget nem ér, vagy a megadott idő lejárta, miközben továbbra is hajtsa végre a szabványos COM és az adatok kiolvasása SendMessage blokkokat."
  remarks: "Illesztés, amely blokkolja a hívó szál (Ez azt jelenti, hogy a szál, metódus) vagy a szál amíg szinkronizálási módszer amelynek <xref:System.Threading.Thread.Join%2A>metódust befejeződött vagy az időtúllépési időköz.</xref:System.Threading.Thread.Join%2A> A következő példában a `Thread1` hívások szál a <xref:System.Threading.Thread.Join>metódusában `Thread2`, aminek következtében `Thread1` blokkolására addig `Thread2` befejeződött vagy 2 másodperc eltelt.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] Ha <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>megadott `timeout`, ez a módszer az azonos módon viselkedik a <xref:System.Threading.Thread.Join>metódus túlterhelési, kivéve a visszatérési érték.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Ha a szál már leállt mikor <xref:System.Threading.Thread.Join%2A>nevezik, a metódus azonnal visszaadja.</xref:System.Threading.Thread.Join%2A>       Ez a módszer az aktuális szál <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> felvenni állapotának megváltoztatása Nem lehet meghívni `Join` , amely a szálban a <xref:System.Threading.ThreadState?displayProperty=fullName>állapotát.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>beállítani mennyi ideig várjon, amíg a szál leáll.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha a szál megszakadt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Ha a szál nem leállt a megadott idő után a <code> timeout </code> paraméter lejárt."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Értékének <code> timeout </code> negatív, és nem egyenlő &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; ezredmásodpercben, vagy nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; ezredmásodperc."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A hívó megpróbált csatlakozzon, amely egy szál a <xref href=&quot;System.Threading.ThreadState&quot;> </xref> állapotát."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekéri az aktuális felügyelt szál egyedi azonosítója."
  remarks: "A szál ManagedThreadId tulajdonság értéke a folyamaton belül a szál egyedi azonosítására szolgál.       A ManagedThreadId tulajdonság értéke nem változnak az idő múlásával, még akkor is, ha a nem felügyelt kód, amelyen a közös nyelvi futtatókörnyezet megvalósítja a szálon a fiber."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "A felügyelt szál egyedi azonosítója jelölő egész."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Az alábbiak szerint szinkronizálja a memória-hozzáférés: A feldolgozó az aktuális szál nem rendezhetők át utasításait, például úgy, hogy a memória fér hozzá a MemoryBarrier hívása előtt hajtható végre memória fér hozzá az alábbi MemoryBarrier hívása után.'
  remarks: "MemoryBarrier szükséges csak többprocesszoros rendszerek (például a rendszer több Intel Itanium processzorokkal alkalmazó) rendelési gyenge memóriával.       A legtöbb célra, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, vagy a <xref:System.Threading.Monitor>osztály segítségével könnyebben szinkronizálja az adatokat.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja a szál nevét."
  remarks: "Ez a tulajdonság akkor írási-után. Mivel az alapértelmezett érték a szál Name tulajdonság `null`, azt is meghatározhatja, hogy a név már explicit módon rendelték hozzá a szál hasonlítsa össze a `null`.       A karakterlánc a Name tulajdonság rendelt bármely Unicode karaktert tartalmazhatnak."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "A szál nevét tartalmazó karakterlánc vagy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> nevet nem adta meg."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Beállítási művelet kért, de a <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> tulajdonság már be van állítva."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi vagy beállítja a szál az ütemezési prioritását jelző érték."
  remarks: "A szál rendelhetők hozzá a következő prioritását <xref:System.Threading.ThreadPriority>értékek:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` operációs rendszerek nem szükséges, hogy a szál prioritását tiszteletben.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "Egy a <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> értékeket. Az alapértelmezett érték <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Elérte a szál a végső állapot, például a <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Beállítási művelet érvénytelen egy megadott <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> érték."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Megszakítja az <xref:System.Threading.Thread.Abort*>az aktuális szál kérve.</xref:System.Threading.Thread.Abort*>"
  remarks: "Ez a metódus csak a megfelelő engedélyekkel rendelkező kóddal hívható.       Ha a kérés érkezett `Abort` szál leáll, a rendszer az <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> jelez. `ThreadAbortException`egy különös kivétel alkalmazáskód által kezelve is, de a &quot;catch&quot; blokk végén újra van kiváltja kivéve, ha `ResetAbort` nevezik. `ResetAbort`megszakítja a kérelmet, megszakítható, és megakadályozza, hogy a `ThreadAbortException` billentyűk megnyomása leállítsa a szál.       Lásd: <xref:System.Threading.ThreadAbortException>példa azt mutatja be, hívása a `ResetAbort` metódus.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>nem az aktuális szálon lett meghívva."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a szükséges biztonsági engedély az aktuális szál."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Folytatja a szál fel van függesztve."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál nem indult el, elhalt vagy felfüggesztett állapotban van."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a megfelelő <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál apartman állapotának beállítása előtt elindul."
  remarks: "Új szálak inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>Ha az állapot nem lett beállítva ahhoz, azok elindult.</xref:System.Threading.ApartmentState?displayProperty=fullName> A szál indítása előtt apartmanállapotot kell beállítani.      > [!NOTE] > A fő alkalmazás szál inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>alapértelmezés szerint.</xref:System.Threading.ApartmentState?displayProperty=fullName> Az egyetlen lehetőség a fő alkalmazás szál apartman állapotának beállításához <xref:System.Threading.ApartmentState?displayProperty=fullName>kell alkalmazni a <xref:System.STAThreadAttribute>attribútumot belépési pont metódusra.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       A SetApartmentState metódus együtt a <xref:System.Threading.Thread.GetApartmentState%2A>metódus és a <xref:System.Threading.Thread.TrySetApartmentState%2A>metódus, a felváltja a <xref:System.Threading.Thread.ApartmentState%2A>tulajdonság.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Az új állapot."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>nincs érvényes apartmanállapotot."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál már elindult."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Az állapot már inicializálva van."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Alkalmazza a rögzített <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> a jelenlegi szálhoz."
  remarks: "Ez a metódus már nem támogatott."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "A <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> az aktuális szál alkalmazni kívánt objektumot."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Minden esetben."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Azt állítja be az adatokat a tárolóhely megadott éppen futó szálban, a szál aktuális tartomány. A jobb teljesítmény érdekében használjon jelölésű mezőt a <xref:System.ThreadStaticAttribute>attribútum helyett.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> A .NET-keretrendszer szál helyi tároló (TLS) használatával két mechanizmusok: szál relatív statikus mezők (Ez azt jelenti, hogy a kijelölt mezőket a <xref:System.ThreadStaticAttribute>attribútum) és az adatok üzembe helyezési ponti.</xref:System.ThreadStaticAttribute> Szál relatív statikus mezők adatok tárhelyek mennyi jobb teljesítményt biztosít, és engedélyezze a fordítási időben típus ellenőrzése. A TLS használatával kapcsolatos további információkért lásd: [helyi tároló szál: szál relatív statikus mezők és az üzembe helyezési ponti](~/add/includes/ajax-current-ext-md.md).       Szálat a helyi tárolójába memória mechanizmus segítségével szál vonatkozó adatokat tárolja. A közös nyelvi futtatókörnyezet foglal le, mely egy több tárolóhely adatok tárolási tömb minden folyamat létrehozásakor. A szál foglalhatja le a adattár adatok tárhely, a tároló és az adatok beolvasása a tárolóhelyen lévő értéket, és a tárhely újbóli szabad a szál eljárás előfizetés lejárta után és a <xref:System.Threading.Thread>objektum rendelkezik lett visszaigényelt által szemétgyűjtés.</xref:System.Threading.Thread> Adatok üzembe helyezési ponti szálankénti egyediek. Nincs más szál (még egy gyermek szál) adatok kérheti le.      > [!NOTE] > SetData van egy `Shared` módszer, amely mindig alkalmazza a jelenleg végrehajtás alatt álló szál, még akkor is, ha meghívja a használatával egy változó, amely egy másik szál hivatkozik. Félreértések elkerülése érdekében használja az osztálynevet meghívásakor `Shared` módszerek: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> , amelyben az érték beállítása."
    - id: data
      type: System.Object
      description: "Az értéket kell beállítani."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Felfüggeszti a megadott számú ezredmásodperc aktuális szálat."
  remarks: "A szál az időpont van megadva az operációs rendszer nem fogja végrehajtásra ütemezni. Ez a módszer a szál <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> felvenni állapotának megváltoztatása       Megadhat <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>a a `millisecondsTimeout` paraméter a szál határozatlan ideig felfüggesztésére.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> Javasoljuk azonban, hogy más használjon <xref:System.Threading?displayProperty=fullName>osztályok, például a <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, vagy <xref:System.Threading.Semaphore>helyette sychronize szálak számát vagy kezelheti az erőforrásokat.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       A rendszer órája ticks meghatározott arányban hívása az óra felbontását. A tényleges időtúllépési nem feltétlenül pontosan a megadott időkorlát, mert a megadott időkorlátnak módosul óra ticks egybe. Az óra megoldás és a várakozási idő további információkért lásd: a [függvény alvó](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) témakör. Ez a metódus meghívja a [függvény alvó](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) a Windows rendszer API-k.       Ez a módszer nem végez a szabványos COM és az adatok kiolvasása SendMessage.      > [!NOTE] > Kell-e, amely rendelkezik szálon alvó <xref:System.STAThreadAttribute>, de szabványos COM és az adatok kiolvasása SendMessage, érdemes lehet a túlterhelések egyikét szeretné a <xref:System.Threading.Thread.Join%2A>metódus, amely meghatározza egy időkorlátja.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "A szám ezredmásodpercben, amelynek a szál fel van függesztve. Ha az értéke a `millisecondsTimeout` argumentum értéke nulla, a szál elhagyja az időszelet, minden szálhoz a nagyobb prioritású virtuális gép, amely készen áll a futtatásra további része. Ha nincs más futásra az azonos prioritású futtatásra kész van, akkor az aktuális szál végrehajtási nem fel van függesztve."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Az időtúllépési érték negatív, és nincs <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite> egyenlő"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az aktuális szál felfüggeszti a megadott időtartamig."
  remarks: "A szál az időpont van megadva az operációs rendszer nem fogja végrehajtásra ütemezni. Ez a módszer a szál <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> felvenni állapotának megváltoztatása       Megadhat <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>a a `timeout` paraméter a szál határozatlan ideig felfüggesztésére.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> Javasoljuk azonban, hogy más használjon <xref:System.Threading?displayProperty=fullName>osztályok, például a <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, vagy <xref:System.Threading.Semaphore>helyette sychronize szálak számát vagy kezelheti az erőforrásokat.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Ez túlterhelése <xref:System.Threading.Thread.Sleep%2A>használja a teljes száma a teljes ezredmásodperc `timeout`.</xref:System.Threading.Thread.Sleep%2A> A rendszer elveti a tört ezredmásodperc.       Ez a módszer nem végez a szabványos COM és az adatok kiolvasása SendMessage.      > [!NOTE] > Kell-e, amely rendelkezik szálon alvó <xref:System.STAThreadAttribute>, de szabványos COM és az adatok kiolvasása SendMessage, érdemes lehet a túlterhelések egyikét szeretné a <xref:System.Threading.Thread.Join%2A>metódus, amely meghatározza egy időkorlátja.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Az időtartam, amelynek a szál fel van függesztve. Ha az értéke a `millisecondsTimeout` argumentum &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, a szál elhagyja az időszelet, minden szálhoz a nagyobb prioritású virtuális gép, amely készen áll a futtatásra további része. Ha nincs más futásra az azonos prioritású futtatásra kész van, akkor az aktuális szál végrehajtási nem fel van függesztve."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Értékének <code> timeout </code> negatív, és nem egyenlő &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; ezredmásodpercben, vagy nagyobb, mint &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; ezredmásodperc."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál által meghatározott hányszor várakozási hatására a <code> iterations </code> paraméter."
  remarks: "A SpinWait módszer akkor hasznos, zárolások megvalósításához. Osztályok a .NET-keretrendszer, például a <xref:System.Threading.Monitor>és <xref:System.Threading.ReaderWriterLock>, ezt a módszert belsőleg.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait lényegében elhelyezi a processzor a rendkívül szoros hurkot, a hurok számával, amelyet a `iterations` paraméter. A várakozási időtartama ezért függ a processzor sebessége.       A rendelkező ellentétben a <xref:System.Threading.Thread.Sleep%2A>metódus.</xref:System.Threading.Thread.Sleep%2A> A hívó szál <xref:System.Threading.Thread.Sleep%2A>az aktuális szelet, processzoridő, a többi eredményez, akkor is, ha a megadott időköz nulla.</xref:System.Threading.Thread.Sleep%2A> Adja meg egy nem nulla intervallumát <xref:System.Threading.Thread.Sleep%2A>eltávolítja a szál szempont a szál az ütemező által a időtartam elteltével.</xref:System.Threading.Thread.Sleep%2A>       SpinWait nincs szokásos alkalmazások számára általában hasznos. A legtöbb esetben a szinkronizálás osztályok a .NET-keretrendszer; megadott használjon például <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>vagy olyan utasításban, amely becsomagolja <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` C# vagy `SyncLock` a Visual Basic nyelvben).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > A ritka eset, ahol egy környezet kapcsolót, például amikor, hogy állapotváltozás közvetlen, elkerülése érdekében előnyös teszi SpinWait metódus hívásakor a hurok. A kód SpinWait végrehajtja a célja, több processzorral rendelkező számítógépeken előforduló problémák megelőzése érdekében. Például a Hyper-Threading technológia alkalmazó több Intel processzorral működő számítógépeket, SpinWait megakadályozza, hogy a processzor adatforgalom leállásának bizonyos esetekben."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "Egy 32 bites előjeles egész szám, amely azt határozza meg, mennyi ideig szál várnia."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az operációs rendszer az aktuális példány számára az állapot módosítására irányuló hatására <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "Ha a szál már szerepel a <xref:System.Threading.ThreadState?displayProperty=fullName>állapotba kerül, az operációs rendszer ütemezheti a végrehajtáshoz.</xref:System.Threading.ThreadState?displayProperty=fullName> A szál kezdődik, az első sor által képviselt metódus végrehajtása a <xref:System.Threading.ThreadStart>vagy <xref:System.Threading.ParameterizedThreadStart>a szál konstruktor megadott delegált.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Vegye figyelembe, hogy a Start hívása nem blokkolja-e a hívó szál.      > [!NOTE] > Ha létrehozott egy szál a túlterhelési használt egy <xref:System.Threading.ParameterizedThreadStart>delegálása, `null` van a hajtja végre a szál metódusnak átadott.</xref:System.Threading.ParameterizedThreadStart>       Ha a szál leállítása, ezért nem indítható újra egy hívás a `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál már elindult."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a szálat indítani."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az operációs rendszer az aktuális példány számára az állapot módosítására irányuló hatására <xref href=&quot;System.Threading.ThreadState&quot;> </xref>, és opcionálisan megadja a szál végrehajtja a metódus által használt adatokat tartalmazó objektum."
  remarks: "Ha a szál már szerepel a <xref:System.Threading.ThreadState?displayProperty=fullName>állapotba kerül, az operációs rendszer ütemezheti a végrehajtáshoz.</xref:System.Threading.ThreadState?displayProperty=fullName> A szál kezdődik, az első sor által képviselt metódus végrehajtása a <xref:System.Threading.ThreadStart>vagy <xref:System.Threading.ParameterizedThreadStart>a szál konstruktor megadott delegált.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Vegye figyelembe, hogy a Start hívása nem blokkolja-e a hívó szál.       Ha a szál leállítása, ezért nem indítható újra egy hívás a `Start`.       Ez a túlterhelés és a <xref:System.Threading.ParameterizedThreadStart>delegált könnyen mechanizmusok adatok átadására szál eljárás számára, de a technika oka nem biztonságos típusú objektumok adhatók át a túlterhelési.</xref:System.Threading.ParameterizedThreadStart> Egy sokkal hatékonyabban adatok átadása egy szál eljárás módja a szál eljárás, mind az adatmezők üzembe egy munkavégző objektum. További információkért lásd: [szál létrehozása és adatok továbbításához kezdete](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "Olyan objektum, amely tartalmazza a metódus által használt adatok a szálban hajt végre."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál már elindult."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nincs elég memória a szálat indítani."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ebből a szálból lett létrehozva egy <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegálása ahelyett, hogy egy <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegálni."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Felfüggeszti a szál, vagy ha a szál már fel van függesztve, nincs hatása."
  remarks: "Ha a szál már fel van függesztve, ez a metódus nincs hatása.      > [!CAUTION] > Ne használja a felfüggesztés és <xref:System.Threading.Thread.Resume%2A>módszerek szinkronizálni a szálak tevékenységeit.</xref:System.Threading.Thread.Resume%2A> Semmilyen módon nem tudhatja, hogy milyen kódot, a szál végrehajtja az felfüggesztésekor rendelkezik. Amíg egy biztonsági engedély kiértékelése közben zárolások magánál tartja a szál felfüggesztjük, ha más a szálak a <xref:System.AppDomain>blokkolhatja.</xref:System.AppDomain> Amíg osztálykonstruktor végrehajtja a szál felfüggesztjük, ha más a szálak a <xref:System.AppDomain>, amely arról, hogy vannak-e tiltva osztály használatára történt kísérlet.</xref:System.AppDomain> Nagyon egyszerűen holtpont fordulhat elő."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál nem indult el, vagy nem működik."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "A hívó nem rendelkezik a megfelelő <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Nevek csoportja van leképezve a feladó azonosítók meg."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetIDsOfNames`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Jövőbeli használatra fenntartva. IID_NULL kell lennie."
    - id: rgszNames
      type: System.IntPtr
      description: "Az átadott a nevének tömbje le kell képezni."
    - id: cNames
      type: System.UInt32
      description: "Le kell képezni a nevek száma."
    - id: lcid
      type: System.UInt32
      description: "A területi beállítás a környezetben, amelyben a nevek értelmezni."
    - id: rgDispId
      type: System.IntPtr
      description: "Hívó lefoglalt tömbből, amely megkapja a nevének megfelelő azonosítók."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Az objektum, amelyek ezután felhasználhatók a típus adatainak illesztőfelület típusú adatainak beolvasása."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetTypeInfo`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "A típus adatainak való visszatéréshez."
    - id: lcid
      type: System.UInt32
      description: "A típus adatainak területibeállítás-azonosító."
    - id: ppTInfo
      type: System.IntPtr
      description: "A kért típusú információk objektum mutató kap."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekéri a, hogy az objektum tartalmaz (0 vagy 1) típusú információk interfészek száma."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::GetTypeInfoCount`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Pontok olyan helyre, amely megkapja a objektum által megadott típus információ interfészek száma."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Tulajdonságai és metódusai jelennek meg, ha egy objektum hozzáférést biztosít."
  remarks: "Ez a módszer nem felügyelt kódból felügyelt osztályokra való hozzáféréshez van, és a felügyelt kódból nem hívható. További információ `IDispatch::Invoke`, tekintse meg az MSDN könyvtárában."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "A tagot azonosítja."
    - id: riid
      type: System.Guid
      description: "Jövőbeli használatra fenntartva. IID_NULL kell lennie."
    - id: lcid
      type: System.UInt32
      description: "A területi beállítás a környezetben használandó argumentumok értelmezhetők."
    - id: wFlags
      type: System.Int16
      description: "A hívás keretében leíró jelzőket."
    - id: pDispParams
      type: System.IntPtr
      description: "Mutató tartalmazó tömb argumentumok argumentum DISPID-azonosítók elnevezett argumentum, és hány példányban a tömb elemeinek száma tömbje struktúrára."
    - id: pVarResult
      type: System.IntPtr
      description: "A helyet, ahol az eredmény tárolható mutat."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Mutatót, amely tartalmazza a kivételek adatai struktúrára."
    - id: puArgErr
      type: System.IntPtr
      description: "Az index az első argumentum, amely azonban hibát tartalmaz."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Késői kötésű távelérést, a COM `IDispatch` felület nem támogatott."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lekérdezi az aktuális szál állapotát tartalmazó értéket."
  remarks: "A ThreadState tulajdonság nyújt részletesebb információt, mint a <xref:System.Threading.Thread.IsAlive%2A>tulajdonság.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > Szál állapota csak hibakeresési forgatókönyvek jelentőséggel bír. A kód soha ne használja a szál állapota szálak tevékenységeit szinkronizálásához."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "Egy a <xref href=&quot;System.Threading.ThreadState&quot;> </xref> értékeket az aktuális szál állapotát jelzi. A kezdeti érték <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A szál apartman állapotának beállítása előtt elindul."
  remarks: "Új szálak inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>Ha az állapot nem lett beállítva ahhoz, azok elindult.</xref:System.Threading.ApartmentState?displayProperty=fullName> A szál indítása előtt apartmanállapotot kell beállítani.      > [!NOTE] > A fő alkalmazás szál inicializálása <xref:System.Threading.ApartmentState?displayProperty=fullName>alapértelmezés szerint.</xref:System.Threading.ApartmentState?displayProperty=fullName> Az egyetlen lehetőség a fő alkalmazás szál apartman állapotának beállításához <xref:System.Threading.ApartmentState?displayProperty=fullName>kell alkalmazni a <xref:System.STAThreadAttribute>attribútumot belépési pont metódusra.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       A TrySetApartmentState metódus együtt a <xref:System.Threading.Thread.GetApartmentState%2A>metódus és a <xref:System.Threading.Thread.SetApartmentState%2A>metódus, a felváltja a <xref:System.Threading.Thread.ApartmentState%2A>tulajdonság.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Az új állapot."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az állapot értéke; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>nincs érvényes apartmanállapotot."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "A szál már elindult."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "VolatileRead és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben VolatileRead beolvassa a legújabb érték olyan memóriahelyre írni az összes processzor által. Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy rendszeren egyprocesszoros VolatileRead és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazza (például a processzor regisztrálása).</xref:System.Threading.Thread.VolatileWrite%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, VolatileRead vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja VolatileRead vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "Olvassa el a mezőt."
    return:
      type: System.Byte
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "Olvassa el a mezőt."
    return:
      type: System.Double
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "Olvassa el a mezőt."
    return:
      type: System.Int16
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "Olvassa el a mezőt."
    return:
      type: System.Int32
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "Olvassa el a mezőt."
    return:
      type: System.Int64
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Olvassa el a mezőt."
    return:
      type: System.IntPtr
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "Olvassa el a mezőt."
    return:
      type: System.Object
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "Olvassa el a mezőt."
    return:
      type: System.SByte
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "Olvassa el a mezőt."
    return:
      type: System.Single
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "Olvassa el a mezőt."
    return:
      type: System.UInt16
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "Olvassa el a mezőt."
    return:
      type: System.UInt32
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "Olvassa el a mezőt."
    return:
      type: System.UInt64
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A mező értékének beolvasása. A legújabb bármely processzort a számítógépben, függetlenül a processzorok számát vagy a processzor gyorsítótárának állapotának által írt értéke."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileRead%2A>jut hozzá a legújabb érték olyan memóriahelyre összes processzor által írt.</xref:System.Threading.Thread.VolatileRead%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Olvassa el a mezőt."
    return:
      type: System.UIntPtr
      description: "A mező írni az összes processzor által a legutóbbi értékét."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és VolatileWrite szinkronizálási speciális esetekben.</xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben VolatileWrite biztosítja, hogy olyan memóriahelyre írt számnak azonnal látható az összes processzor. Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és VolatileWrite győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazza (például a processzor regisztrálása).</xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Adjon meg egy mező hatékony szinkronizálását, a mező az elérésére kell használnia <xref:System.Threading.Thread.VolatileRead%2A>vagy VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja <xref:System.Threading.Thread.VolatileRead%2A>vagy VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Byte
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Double
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Int16
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Int32
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Int64
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.IntPtr
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Object
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.SByte
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.Single
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.UInt16
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.UInt32
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.UInt64
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Egy értéket ír egy mező azonnal, úgy, hogy az érték látható, hogy a számítógép az összes processzor."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>szinkronizálási bizonyos esetekben a.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Normál körülmények, a C# `lock` utasítás, a Visual Basic `SyncLock` utasítást, és a <xref:System.Threading.Monitor>osztály rendelkezik az egyszerűbb.</xref:System.Threading.Monitor>       Többprocesszoros rendszerekben <xref:System.Threading.Thread.VolatileWrite%2A>biztosítja, hogy egy érték, egy memóriahelyre írni azonnal látható az összes processzor.</xref:System.Threading.Thread.VolatileWrite%2A> Előfordulhat, hogy a processzor-gyorsítótár kiürítése.       Még egy egyprocesszoros rendszeren <xref:System.Threading.Thread.VolatileRead%2A>és <xref:System.Threading.Thread.VolatileWrite%2A>Győződjön meg arról, hogy egy érték olvasása vagy memóriába, és nem gyorsítótárazott (például a processzor nyilvántartásba).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Így használhatja őket egy másik szál vagy hardver által frissíthető mező elérésére szinkronizálásához.       A metódus hívása csak egyetlen memóriaelérés hatással van. Ahhoz, hogy egy mező hatékony szinkronizálását, a mező hozzáférésének kell használnia, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > A C#, használja a `volatile` mező módosító garantálja, hogy ezt a mezőt az elérésére használja, <xref:System.Threading.Thread.VolatileRead%2A>vagy <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "A mező, amelyhez a érték írható."
    - id: value
      type: System.UIntPtr
      description: "Írandó értéket."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "A hívó szál, hogy egy másik szál, amely készen áll a futtatásra az aktuális processzorokon végrehajtás okoz. Az operációs rendszer választja ki a szál a fed fel."
  remarks: "Ez a metódus sikeres, ha a szál aktuális időszelet részeinek van eredményezte. Az operációs rendszer ütemezi a hívó szál a másik időszelet a hozzá tartozó Prioritás és egyéb futtatható szálak állapota alapján.       Ad eredményt a következő korlátozódik, amely a hívó szál végrehajtja a processzor. Az operációs rendszer nem vált végrehajtási másik processzorhoz, még akkor is, ha a processzor üresjáratban, vagy egy alacsonyabb prioritású szál fut. Ha nincs más futásra kész hajt végre az aktuális processzor van, az operációs rendszer nem fed fel végrehajtása és a metódus visszaadja `false`.       Ez a módszer megegyezik a natív Win32 hívására platform használatával meghívni `SwitchToThread` függvény. Célszerű hívni a Yield platform helyett metódushívási, mivel a platform meghívása Mellőzés kér, az állomás bármely egyéni szálkezelési viselkedését."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Ha az operációs rendszer végrehajtási át egy másik szál; Ellenkező esetben <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
